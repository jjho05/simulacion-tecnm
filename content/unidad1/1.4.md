# 1.4 Estructura y etapas de un estudio de simulación

Un estudio de simulación exitoso requiere una estructura bien definida y el seguimiento sistemático de etapas específicas. Esta organización garantiza resultados válidos, reproducibles y útiles para la toma de decisiones.

---

## Importancia de una Estructura Formal

### ¿Por qué seguir una estructura?

1. **Garantiza completitud** - No se omiten pasos críticos
2. **Facilita comunicación** - Equipo y stakeholders hablan el mismo idioma
3. **Permite reproducibilidad** - Otros pueden replicar el estudio
4. **Reduce errores** - Proceso sistemático minimiza omisiones
5. **Mejora calidad** - Cada etapa tiene criterios de aceptación

### Consecuencias de NO seguir una estructura

❌ Modelos inválidos por falta de validación
❌ Resultados no confiables por datos insuficientes
❌ Decisiones erróneas basadas en modelos incorrectos
❌ Desperdicio de tiempo y recursos
❌ Pérdida de credibilidad del estudio

---

## Estructura General de un Estudio de Simulación

### Visión de Alto Nivel

```
INICIO
  ↓
FORMULACIÓN DEL PROBLEMA
  ↓
DESARROLLO DEL MODELO
  ↓
VALIDACIÓN Y VERIFICACIÓN
  ↓
EXPERIMENTACIÓN
  ↓
ANÁLISIS E IMPLEMENTACIÓN
  ↓
FIN
```

### Tres Fases Principales

Un estudio de simulación se organiza en **tres fases principales**, cada una con objetivos y entregables específicos:

1. **Fase de Formulación** - Definir qué se va a hacer
2. **Fase de Desarrollo** - Construir y validar el modelo
3. **Fase de Experimentación** - Usar el modelo para tomar decisiones

---

## FASE 1: Formulación del Problema

### Objetivo
Establecer claramente qué se desea lograr con el estudio de simulación.

### Actividades Principales

#### 1.1 Definición de Objetivos

**Pregunta clave:** ¿Qué queremos lograr?

**Objetivos deben ser SMART:**
- **S**pecific (Específicos)
- **M**easurable (Medibles)
- **A**chievable (Alcanzables)
- **R**elevant (Relevantes)
- **T**ime-bound (Con tiempo definido)

**Ejemplo - Banco:**

❌ **Objetivo vago:** "Mejorar el servicio"

✅ **Objetivo SMART:** "Reducir el tiempo promedio de espera de clientes de 15 a menos de 10 minutos en un plazo de 3 meses, manteniendo la utilización de cajeros entre 70-85%"

#### 1.2 Identificación de Métricas de Desempeño

**Pregunta clave:** ¿Cómo mediremos el éxito?

**Tipos de métricas:**

| Categoría | Ejemplos |
|-----------|----------|
| **Tiempo** | Tiempo de espera, tiempo de ciclo, tiempo de servicio |
| **Utilización** | % de tiempo que recursos están ocupados |
| **Throughput** | Unidades procesadas por hora/día |
| **Costo** | Costo operativo, costo de inventario |
| **Calidad** | % de defectos, satisfacción del cliente |

**Ejemplo - Sistema de manufactura:**
- Tiempo de ciclo promedio (minutos)
- Utilización de máquinas (%)
- Producción diaria (unidades)
- Inventario en proceso (WIP)
- Costo operativo por unidad ($)

#### 1.3 Establecimiento de Alcance y Fronteras

**Pregunta clave:** ¿Qué incluimos y qué excluimos?

**Definir fronteras:**

**Dentro del sistema:**
- Componentes que se modelarán explícitamente
- Procesos que se simularán en detalle
- Variables que se controlarán

**Fuera del sistema:**
- Entorno que afecta pero no se modela
- Procesos simplificados o ignorados
- Variables exógenas

**Ejemplo - Hospital:**

**Dentro:**
- Área de urgencias
- Proceso de triage
- Salas de examen
- Personal médico

**Fuera:**
- Estacionamiento
- Cafetería
- Farmacia
- Origen de los pacientes

#### 1.4 Identificación de Restricciones

**Tipos de restricciones:**

1. **Tiempo:** Fecha límite para entregar resultados
2. **Presupuesto:** Recursos financieros disponibles
3. **Datos:** Disponibilidad y calidad de información
4. **Recursos:** Personal, software, hardware
5. **Políticas:** Regulaciones, estándares corporativos

**Ejemplo:**
```
Restricciones del Proyecto:
- Tiempo: 8 semanas máximo
- Presupuesto: $50,000
- Software: Debe usar herramientas existentes (Python/SimPy)
- Datos: Solo datos de últimos 6 meses disponibles
- Personal: 1 analista tiempo completo
```

### Entregables de la Fase 1

✅ Documento de definición del proyecto
✅ Lista de objetivos SMART
✅ Métricas de desempeño identificadas
✅ Diagrama de fronteras del sistema
✅ Lista de restricciones documentada
✅ Aprobación de stakeholders

---

## FASE 2: Desarrollo del Modelo

### Objetivo
Construir un modelo computacional válido del sistema real.

### Etapa 2.1: Construcción del Modelo Conceptual

**Propósito:** Crear representación abstracta antes de programar

**Herramientas:**
- Diagramas de flujo
- Diagramas de bloques
- Mapas de proceso
- Pseudocódigo

**Ejemplo - Modelo conceptual de cafetería:**

```
ENTIDADES:
- Clientes

ATRIBUTOS:
- Tipo de bebida (café, té, smoothie)
- Tiempo de llegada
- Prioridad (regular, VIP)

RECURSOS:
- Baristas (2)
- Máquina de café (1)
- Caja registradora (1)

PROCESO:
1. Cliente llega
2. Cliente hace pedido en caja
3. Cliente espera bebida
4. Barista prepara bebida
5. Cliente recibe bebida y sale

VARIABLES DE ESTADO:
- Clientes en cola de pedido
- Clientes esperando bebida
- Baristas ocupados/libres
```

**Nivel de detalle apropiado:**

❌ **Demasiado detallado:** Modelar cada grano de café
✅ **Apropiado:** Modelar tiempo de preparación como distribución
❌ **Muy simple:** Ignorar diferencias entre tipos de bebida

### Etapa 2.2: Recolección de Datos

**Tipos de datos necesarios:**

1. **Datos de entrada:**
   - Tasas de llegada
   - Tiempos de servicio
   - Distribuciones de demanda

2. **Datos de configuración:**
   - Número de recursos
   - Capacidades
   - Horarios

3. **Datos de validación:**
   - Métricas históricas del sistema real

**Métodos de recolección:**

```python
# Ejemplo: Recolección de tiempos de servicio
import time

tiempos_servicio = []

def registrar_servicio(inicio, fin):
    duracion = fin - inicio
    tiempos_servicio.append(duracion)
    
# Durante observación del sistema real
inicio = time.time()
# ... cliente es atendido ...
fin = time.time()
registrar_servicio(inicio, fin)
```

**Análisis de datos:**

```python
import numpy as np
import scipy.stats as stats

# Calcular estadísticas
media = np.mean(tiempos_servicio)
desv_std = np.std(tiempos_servicio, ddof=1)

print(f"Media: {media:.2f} minutos")
print(f"Desviación: {desv_std:.2f} minutos")

# Ajustar distribución
params = stats.norm.fit(tiempos_servicio)
print(f"Distribución normal: μ={params[0]:.2f}, σ={params[1]:.2f}")
```

### Etapa 2.3: Implementación Computacional

**Selección de herramienta:**

| Herramienta | Ventajas | Desventajas | Cuándo usar |
|-------------|----------|-------------|-------------|
| Python/SimPy | Gratuito, flexible | Requiere programación | Proyectos personalizados |
| Arena | Interfaz gráfica | Costoso | Proyectos estándar |
| AnyLogic | Multiparadigma | Curva de aprendizaje | Sistemas complejos |
| Excel/VBA | Familiar | Limitado | Modelos simples |

**Ejemplo de implementación:**

```python
import simpy
import random

class Cafeteria:
    def __init__(self, env, num_baristas):
        self.env = env
        self.baristas = simpy.Resource(env, num_baristas)
        self.tiempos_espera = []
    
    def preparar_bebida(self, tipo):
        """Simula preparación de bebida"""
        if tipo == 'cafe':
            yield self.env.timeout(random.normalvariate(3, 0.5))
        elif tipo == 'smoothie':
            yield self.env.timeout(random.normalvariate(5, 1))
        else:
            yield self.env.timeout(random.normalvariate(2, 0.3))
    
    def atender_cliente(self, cliente_id, tipo_bebida):
        llegada = self.env.now
        
        with self.baristas.request() as req:
            yield req
            espera = self.env.now - llegada
            self.tiempos_espera.append(espera)
            
            yield self.env.process(self.preparar_bebida(tipo_bebida))

def generador_clientes(env, cafeteria):
    cliente_id = 0
    while True:
        yield env.timeout(random.expovariate(1/4))  # Llegada cada 4 min
        cliente_id += 1
        tipo = random.choice(['cafe', 'te', 'smoothie'])
        env.process(cafeteria.atender_cliente(cliente_id, tipo))

# Ejecutar simulación
env = simpy.Environment()
cafeteria = Cafeteria(env, num_baristas=2)
env.process(generador_clientes(env, cafeteria))
env.run(until=480)  # 8 horas

print(f"Tiempo promedio de espera: {np.mean(cafeteria.tiempos_espera):.2f} min")
```

### Etapa 2.4: Verificación

**Objetivo:** Asegurar que el código funciona correctamente

**Técnicas:**

1. **Inspección de código**
2. **Pruebas unitarias**
3. **Trazas de eventos**
4. **Casos extremos**
5. **Comparación con cálculos manuales**

**Ejemplo de prueba:**

```python
def test_cafeteria():
    """Prueba básica del modelo"""
    env = simpy.Environment()
    cafeteria = Cafeteria(env, num_baristas=1)
    
    # Simular 1 cliente
    env.process(cafeteria.atender_cliente(1, 'cafe'))
    env.run()
    
    # Verificar que se procesó
    assert len(cafeteria.tiempos_espera) == 1
    print("✓ Prueba pasada")

test_cafeteria()
```

### Etapa 2.5: Validación

**Objetivo:** Asegurar que el modelo representa la realidad

**Métodos:**

1. **Validación de cara (Face Validity)**
   - Mostrar a expertos
   - ¿Se ve razonable?

2. **Validación estadística**
   - Comparar con datos reales
   - Pruebas t, F, K-S

3. **Validación de sensibilidad**
   - Variar parámetros
   - Verificar respuestas lógicas

**Ejemplo de validación:**

```python
# Datos reales del sistema
tiempos_reales = [3.2, 4.1, 2.8, 5.3, 3.9]

# Datos del modelo (múltiples réplicas)
tiempos_modelo = []
for _ in range(30):
    env = simpy.Environment()
    cafeteria = Cafeteria(env, 2)
    env.process(generador_clientes(env, cafeteria))
    env.run(until=480)
    tiempos_modelo.append(np.mean(cafeteria.tiempos_espera))

# Prueba t
from scipy import stats
t_stat, p_value = stats.ttest_ind(tiempos_reales, tiempos_modelo)

if p_value > 0.05:
    print("✓ Modelo VÁLIDO (no hay diferencia significativa)")
else:
    print("✗ Modelo necesita ajustes")
```

### Entregables de la Fase 2

✅ Modelo conceptual documentado
✅ Datos recolectados y analizados
✅ Código fuente del modelo
✅ Reporte de verificación
✅ Reporte de validación
✅ Modelo aprobado para experimentación

---

## FASE 3: Experimentación y Análisis

### Objetivo
Usar el modelo validado para responder preguntas y tomar decisiones.

### Etapa 3.1: Diseño de Experimentos

**Definir escenarios:**

| Escenario | Baristas | Tasa Llegada | Objetivo |
|-----------|----------|--------------|----------|
| Base | 2 | 15/hora | Situación actual |
| A | 3 | 15/hora | ¿Mejora agregar barista? |
| B | 2 | 20/hora | ¿Qué pasa con más demanda? |
| C | 3 | 20/hora | Escenario combinado |

**Determinar:**
- Número de réplicas (mínimo 30)
- Longitud de simulación
- Período de calentamiento
- Variables a medir

### Etapa 3.2: Ejecución

```python
def ejecutar_experimento(num_baristas, tasa_llegada, replicas=30):
    resultados = []
    
    for i in range(replicas):
        random.seed(1000 + i)  # Semillas diferentes
        env = simpy.Environment()
        cafeteria = Cafeteria(env, num_baristas)
        # ... ejecutar simulación ...
        resultados.append({
            'espera_promedio': np.mean(cafeteria.tiempos_espera),
            'clientes_atendidos': len(cafeteria.tiempos_espera)
        })
    
    return resultados

# Ejecutar todos los escenarios
escenarios = {
    'Base': ejecutar_experimento(2, 15),
    'A': ejecutar_experimento(3, 15),
    'B': ejecutar_experimento(2, 20),
    'C': ejecutar_experimento(3, 20)
}
```

### Etapa 3.3: Análisis de Resultados

**Calcular estadísticas:**

```python
for nombre, datos in escenarios.items():
    esperas = [d['espera_promedio'] for d in datos]
    media = np.mean(esperas)
    ic_95 = 1.96 * np.std(esperas) / np.sqrt(len(esperas))
    
    print(f"{nombre}: {media:.2f} ± {ic_95:.2f} min")
```

**Comparar escenarios:**

```python
import matplotlib.pyplot as plt

nombres = list(escenarios.keys())
medias = [np.mean([d['espera_promedio'] for d in escenarios[n]]) 
          for n in nombres]

plt.bar(nombres, medias)
plt.axhline(y=5, color='r', linestyle='--', label='Meta')
plt.ylabel('Tiempo de espera (min)')
plt.title('Comparación de Escenarios')
plt.legend()
plt.show()
```

### Etapa 3.4: Interpretación

**Preguntas a responder:**
1. ¿Qué escenario cumple los objetivos?
2. ¿Cuál es el trade-off costo-beneficio?
3. ¿Hay efectos inesperados?
4. ¿Qué riesgos existen?

**Ejemplo de análisis:**

```
Resultados:
- Base: 6.2 ± 0.4 min (NO cumple meta de <5 min)
- A: 3.1 ± 0.3 min (✓ Cumple meta)
- B: 12.5 ± 0.8 min (Sobrecarga)
- C: 5.8 ± 0.5 min (Apenas cumple)

Recomendación:
Escenario A (3 baristas) es óptimo para demanda actual.
Si demanda aumenta a 20/hora, necesitaremos Escenario C.

Análisis costo-beneficio:
- Costo barista adicional: $2,000/mes
- Reducción de tiempo de espera: 3.1 min
- Mejora en satisfacción: +25% (estimado)
- ROI: Positivo en 3 meses
```

### Etapa 3.5: Documentación

**Estructura del reporte:**

1. **Resumen ejecutivo** (1-2 páginas)
2. **Introducción** (problema, objetivos)
3. **Metodología** (modelo, datos, validación)
4. **Resultados** (tablas, gráficos)
5. **Análisis** (interpretación, recomendaciones)
6. **Conclusiones**
7. **Anexos** (código, datos detallados)

### Etapa 3.6: Implementación

**Plan de acción:**

1. Presentar resultados a stakeholders
2. Obtener aprobación para cambios
3. Implementar en piloto
4. Monitorear resultados reales
5. Ajustar si es necesario

**Seguimiento:**

```python
# Comparar predicciones vs realidad
prediccion_modelo = 3.1  # minutos
realidad_medida = 3.4    # minutos después de implementar

diferencia = abs(prediccion_modelo - realidad_medida)
error_porcentual = (diferencia / prediccion_modelo) * 100

if error_porcentual < 10:
    print("✓ Modelo fue preciso")
else:
    print("⚠ Revisar supuestos del modelo")
```

### Entregables de la Fase 3

✅ Matriz de experimentos
✅ Resultados de todas las réplicas
✅ Análisis estadístico completo
✅ Gráficos y visualizaciones
✅ Reporte final
✅ Presentación ejecutiva
✅ Plan de implementación

---

## Resumen de las Tres Fases

| Fase | Pregunta Clave | Entregable Principal |
|------|----------------|----------------------|
| 1. Formulación | ¿Qué vamos a hacer? | Documento de definición |
| 2. Desarrollo | ¿Cómo lo modelamos? | Modelo validado |
| 3. Experimentación | ¿Qué aprendimos? | Reporte con recomendaciones |

---

## Errores Comunes en la Estructura

### Error 1: Saltar la Formulación

❌ Empezar a programar sin objetivos claros
✅ Definir objetivos SMART primero

### Error 2: Validación Insuficiente

❌ Confiar en el modelo sin validar
✅ Comparar con datos reales, validar con expertos

### Error 3: Pocas Réplicas

❌ Ejecutar 1-5 réplicas
✅ Mínimo 30 réplicas para estadísticas confiables

### Error 4: No Documentar

❌ Solo entregar números
✅ Documentar supuestos, decisiones, limitaciones

### Error 5: Ignorar Implementación

❌ Entregar reporte y olvidarse
✅ Apoyar implementación y monitorear resultados

---

## Checklist de Completitud

**Fase 1:**
- [ ] Objetivos SMART definidos
- [ ] Métricas identificadas
- [ ] Fronteras establecidas
- [ ] Restricciones documentadas
- [ ] Aprobación obtenida

**Fase 2:**
- [ ] Modelo conceptual creado
- [ ] Datos recolectados
- [ ] Código implementado
- [ ] Verificación completada
- [ ] Validación aprobada

**Fase 3:**
- [ ] Experimentos diseñados
- [ ] Réplicas ejecutadas (≥30)
- [ ] Análisis completado
- [ ] Reporte finalizado
- [ ] Implementación planificada

---

*Referencia: Programa SCD-1022 - TecNM*  
*Fuentes: Law & Kelton (1991), Banks et al. (2010)*


---

<div align="center">

⬅️ [1.3 Sistemas y Modelos](1.3.md) &nbsp;&nbsp;|&nbsp;&nbsp; [1.5 Metodología](1.5.md) ➡️

</div>
