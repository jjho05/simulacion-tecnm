# 1.5 Etapas de un proyecto de simulación

Un proyecto de simulación exitoso requiere seguir etapas específicas y bien definidas. Cada etapa tiene objetivos claros, actividades detalladas y entregables concretos que aseguran la calidad y utilidad del estudio.

---

## Visión General de las Etapas

### Diagrama de Flujo del Proyecto

```
INICIO
  ↓
[1] Definición del Sistema
  ↓
[2] Formulación del Modelo
  ↓
[3] Colección de Datos
  ↓
[4] Implementación del Modelo
  ↓
[5] Verificación ──NO──┐
  ↓ SÍ                 │
[6] Validación ──NO────┤
  ↓ SÍ                 │
[7] Experimentación    │
  ↓                    │
[8] Análisis           │
  ↓                    │
[9] Documentación      │
  ↓                    │
FIN ←──────────────────┘
```

### Características de las Etapas

- **Secuenciales pero iterativas** - Se siguen en orden pero se puede regresar
- **Interdependientes** - Cada etapa depende de las anteriores
- **Documentadas** - Cada etapa genera entregables específicos
- **Verificables** - Criterios claros de completitud

---

## Etapa 1: Definición del Sistema

### Objetivo
Establecer claramente QUÉ se va a simular y POR QUÉ.

### Actividades Detalladas

#### 1.1 Establecer Objetivos Específicos

**Técnica SMART:**

| Criterio | Descripción | Ejemplo |
|----------|-------------|---------|
| **S**pecific | Específico y claro | "Reducir tiempo de espera" |
| **M**easurable | Cuantificable | "De 15 a menos de 10 minutos" |
| **A**chievable | Alcanzable | Basado en capacidad real |
| **R**elevant | Relevante al negocio | Mejora satisfacción cliente |
| **T**ime-bound | Con plazo definido | "En 3 meses" |

**Ejemplo completo:**
```
Objetivo: Reducir el tiempo promedio de espera de clientes en el banco
de 15 minutos a menos de 10 minutos en un plazo de 3 meses, manteniendo
la utilización de cajeros entre 70-85%.
```

#### 1.2 Definir Fronteras del Sistema

**Pregunta clave:** ¿Dónde empieza y termina nuestro modelo?

**Ejemplo - Sistema bancario:**

**DENTRO del sistema:**
- Área de cajas
- Cola de espera
- Cajeros
- Proceso de atención

**FUERA del sistema:**
- Estacionamiento
- Cajeros automáticos
- Banca en línea
- Origen de los clientes

**Diagrama de fronteras:**
```
┌─────────────────────────────────┐
│  ENTORNO (No modelado)          │
│  ┌───────────────────────────┐  │
│  │ SISTEMA (Modelado)        │  │
│  │                           │  │
│  │  Entrada → Proceso → Salida │
│  │  (Clientes) (Cajas) (Clientes)│
│  └───────────────────────────┘  │
└─────────────────────────────────┘
```

#### 1.3 Identificar Restricciones

**Tipos de restricciones:**

1. **Tiempo:**
   - Fecha límite: 8 semanas
   - Horas disponibles: 160 horas

2. **Presupuesto:**
   - Total: $50,000
   - Software: $10,000
   - Personal: $35,000
   - Contingencia: $5,000

3. **Recursos:**
   - 1 analista senior
   - 1 programador
   - Software: Python/SimPy (ya disponible)

4. **Datos:**
   - Solo últimos 6 meses disponibles
   - Calidad variable
   - Algunas métricas faltantes

5. **Políticas:**
   - Debe usar herramientas open source
   - Resultados confidenciales
   - Validación requerida por gerencia

### Entregables de Etapa 1

✅ **Documento de definición del proyecto** (5-10 páginas)
✅ **Lista de objetivos SMART**
✅ **Diagrama de fronteras del sistema**
✅ **Matriz de restricciones**
✅ **Aprobación firmada de stakeholders**

### Tiempo Estimado
**1-2 semanas** (10-15% del proyecto total)

---

## Etapa 2: Formulación del Modelo

### Objetivo
Crear una representación abstracta del sistema ANTES de programar.

### Actividades Detalladas

#### 2.1 Crear Representaciones Gráficas

**Herramientas:**
- Diagramas de flujo
- Diagramas de bloques
- Mapas de proceso (BPMN)
- Diagramas de actividad (UML)

**Ejemplo - Diagrama de flujo de banco:**

```
INICIO
  ↓
Cliente llega
  ↓
¿Hay cola? ──NO──→ Ir a caja disponible
  ↓ SÍ               ↓
Entrar a cola        Ser atendido
  ↓                  ↓
Esperar turno        Transacción
  ↓                  ↓
Ir a caja ←──────────┘
  ↓
Salir del sistema
  ↓
FIN
```

#### 2.2 Definir Componentes del Modelo

**Tabla de componentes:**

| Componente | Tipo | Descripción | Ejemplo |
|------------|------|-------------|---------|
| **Entidades** | Dinámicas | Objetos que fluyen | Clientes |
| **Atributos** | Propiedades | Características | Tipo de transacción |
| **Variables de estado** | Medidas | Estado del sistema | # clientes en cola |
| **Eventos** | Cambios | Ocurrencias discretas | Llegada de cliente |
| **Actividades** | Procesos | Duraciones | Tiempo de servicio |
| **Recursos** | Limitados | Capacidades | Cajeros (3) |

**Ejemplo detallado - Sistema bancario:**

```python
# Definición conceptual del modelo

ENTIDADES:
  - Cliente
    Atributos:
      - ID único
      - Tipo de transacción (depósito, retiro, consulta)
      - Tiempo de llegada
      - Prioridad (regular, preferente)

RECURSOS:
  - Cajeros (cantidad: 3)
    Atributos:
      - ID del cajero
      - Estado (ocupado/libre)
      - Velocidad de servicio

VARIABLES DE ESTADO:
  - Número de clientes en cola
  - Número de cajeros ocupados
  - Tiempo promedio de espera
  - Utilización de cajeros

EVENTOS:
  - Llegada de cliente
  - Inicio de servicio
  - Fin de servicio
  - Salida del sistema

ACTIVIDADES:
  - Esperar en cola
  - Ser atendido
```

#### 2.3 Establecer Relaciones Matemáticas

**Ecuaciones clave:**

```
Tiempo en sistema = Tiempo en cola + Tiempo de servicio

Utilización = Tiempo ocupado / Tiempo total

Throughput = Clientes atendidos / Tiempo de simulación

Longitud promedio de cola = Σ(clientes en cola × tiempo) / Tiempo total
```

**Ejemplo de cálculo:**

```python
# Pseudocódigo de relaciones

def calcular_metricas(datos_simulacion):
    tiempo_total = datos_simulacion.tiempo_fin
    
    # Tiempo promedio en sistema
    tiempos_sistema = [cliente.salida - cliente.llegada 
                       for cliente in datos_simulacion.clientes]
    tiempo_prom_sistema = sum(tiempos_sistema) / len(tiempos_sistema)
    
    # Utilización de cajeros
    tiempo_ocupado = sum(cajero.tiempo_ocupado 
                        for cajero in datos_simulacion.cajeros)
    utilizacion = tiempo_ocupado / (len(cajeros) * tiempo_total)
    
    return {
        'tiempo_promedio': tiempo_prom_sistema,
        'utilizacion': utilizacion
    }
```

### Entregables de Etapa 2

✅ **Diagramas de flujo del proceso**
✅ **Tabla de componentes del modelo**
✅ **Especificación de relaciones matemáticas**
✅ **Pseudocódigo del modelo**
✅ **Revisión y aprobación de expertos**

### Tiempo Estimado
**1-2 semanas** (10-15% del proyecto)

---

## Etapa 3: Colección de Datos

### Objetivo
Obtener datos REALES para alimentar el modelo.

### Actividades Detalladas

#### 3.1 Identificar Datos Necesarios

**Categorías de datos:**

1. **Datos de entrada:**
   - Tasas de llegada de clientes
   - Distribución de tipos de transacción
   - Tiempos de servicio por tipo

2. **Datos de configuración:**
   - Número de cajeros
   - Horarios de operación
   - Capacidad de la cola

3. **Datos de validación:**
   - Métricas históricas del sistema real
   - Tiempos promedio actuales
   - Utilización actual de recursos

#### 3.2 Recolectar Datos

**Métodos:**

| Método | Ventajas | Desventajas | Cuándo usar |
|--------|----------|-------------|-------------|
| **Observación directa** | Preciso | Costoso en tiempo | Procesos visibles |
| **Registros históricos** | Abundante | Puede tener gaps | Sistemas con logs |
| **Entrevistas** | Conocimiento experto | Subjetivo | Procesos complejos |
| **Sensores/IoT** | Automático | Requiere infraestructura | Sistemas modernos |

**Ejemplo de recolección:**

```python
import datetime
import csv

class RecolectorDatos:
    def __init__(self, archivo='datos_banco.csv'):
        self.archivo = archivo
        self.datos = []
    
    def registrar_llegada(self, cliente_id, tipo_transaccion):
        """Registra cuando un cliente llega"""
        registro = {
            'evento': 'llegada',
            'cliente_id': cliente_id,
            'timestamp': datetime.datetime.now(),
            'tipo': tipo_transaccion
        }
        self.datos.append(registro)
    
    def registrar_inicio_servicio(self, cliente_id, cajero_id):
        """Registra cuando inicia el servicio"""
        registro = {
            'evento': 'inicio_servicio',
            'cliente_id': cliente_id,
            'cajero_id': cajero_id,
            'timestamp': datetime.datetime.now()
        }
        self.datos.append(registro)
    
    def registrar_fin_servicio(self, cliente_id):
        """Registra cuando termina el servicio"""
        registro = {
            'evento': 'fin_servicio',
            'cliente_id': cliente_id,
            'timestamp': datetime.datetime.now()
        }
        self.datos.append(registro)
    
    def guardar(self):
        """Guarda datos en archivo CSV"""
        with open(self.archivo, 'w', newline='') as f:
            if self.datos:
                writer = csv.DictWriter(f, fieldnames=self.datos[0].keys())
                writer.writeheader()
                writer.writerows(self.datos)

# Uso durante observación
recolector = RecolectorDatos()
recolector.registrar_llegada(1, 'deposito')
# ... más registros ...
recolector.guardar()
```

#### 3.3 Análisis de Entrada

**Proceso:**

1. **Estadística descriptiva**
2. **Identificación de distribuciones**
3. **Pruebas de bondad de ajuste**
4. **Selección de mejor distribución**

**Ejemplo completo:**

```python
import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt

# 1. Cargar datos
tiempos_servicio = [3.2, 4.1, 2.8, 5.3, 3.9, 4.5, 3.1, 4.8, 3.7, 4.2,
                    3.5, 4.0, 3.8, 4.3, 3.6, 4.7, 3.3, 4.4, 3.4, 4.1]

# 2. Estadística descriptiva
media = np.mean(tiempos_servicio)
desv_std = np.std(tiempos_servicio, ddof=1)
minimo = np.min(tiempos_servicio)
maximo = np.max(tiempos_servicio)

print(f"Media: {media:.2f} min")
print(f"Desv. Std: {desv_std:.2f} min")
print(f"Rango: [{minimo:.2f}, {maximo:.2f}]")

# 3. Probar distribuciones candidatas
distribuciones = {
    'Normal': stats.norm,
    'Exponencial': stats.expon,
    'Lognormal': stats.lognorm,
    'Gamma': stats.gamma
}

resultados = {}
for nombre, dist in distribuciones.items():
    # Ajustar parámetros
    params = dist.fit(tiempos_servicio)
    
    # Prueba Kolmogorov-Smirnov
    ks_stat, p_value = stats.kstest(tiempos_servicio, 
                                     lambda x: dist.cdf(x, *params))
    
    resultados[nombre] = {
        'params': params,
        'ks_stat': ks_stat,
        'p_value': p_value
    }
    
    print(f"\n{nombre}:")
    print(f"  K-S statistic: {ks_stat:.4f}")
    print(f"  P-value: {p_value:.4f}")
    print(f"  {'✓ Acepta' if p_value > 0.05 else '✗ Rechaza'} (α=0.05)")

# 4. Seleccionar mejor distribución
mejor = max(resultados.items(), key=lambda x: x[1]['p_value'])
print(f"\nMejor distribución: {mejor[0]}")

# 5. Visualizar
plt.hist(tiempos_servicio, bins=8, density=True, alpha=0.7, label='Datos')
x = np.linspace(min(tiempos_servicio), max(tiempos_servicio), 100)
plt.plot(x, mejor[1]['dist'].pdf(x, *mejor[1]['params']), 
         'r-', label=f'{mejor[0]} ajustada')
plt.xlabel('Tiempo de servicio (min)')
plt.ylabel('Densidad')
plt.legend()
plt.title('Ajuste de Distribución')
plt.show()
```

### Entregables de Etapa 3

✅ **Base de datos de observaciones**
✅ **Reporte de estadística descriptiva**
✅ **Distribuciones ajustadas con parámetros**
✅ **Resultados de pruebas de bondad de ajuste**
✅ **Gráficos de ajuste**

### Tiempo Estimado
**2-3 semanas** (20-25% del proyecto)

---

## Etapa 4: Implementación del Modelo

### Objetivo
Traducir el modelo conceptual a código ejecutable.

### Actividades Detalladas

#### 4.1 Seleccionar Herramienta

**Criterios de selección:**

| Criterio | Python/SimPy | Arena | AnyLogic | Excel |
|----------|--------------|-------|----------|-------|
| Costo | Gratis | $$$ | $$ | $ |
| Flexibilidad | Alta | Media | Alta | Baja |
| Curva aprendizaje | Media | Baja | Alta | Baja |
| Escalabilidad | Alta | Media | Alta | Baja |

#### 4.2 Codificar el Modelo

**Ejemplo completo - Banco con SimPy:**

```python
import simpy
import random
import numpy as np

class Banco:
    def __init__(self, env, num_cajeros):
        self.env = env
        self.cajeros = simpy.Resource(env, num_cajeros)
        
        # Métricas
        self.tiempos_espera = []
        self.tiempos_sistema = []
        self.clientes_atendidos = 0
    
    def tiempo_servicio(self, tipo_transaccion):
        """Retorna tiempo de servicio según tipo"""
        tiempos = {
            'deposito': random.normalvariate(4, 1),
            'retiro': random.normalvariate(3, 0.5),
            'consulta': random.normalvariate(2, 0.3)
        }
        return max(0.5, tiempos.get(tipo_transaccion, 3))
    
    def atender_cliente(self, cliente_id, tipo_transaccion):
        """Proceso de atención de un cliente"""
        llegada = self.env.now
        
        # Solicitar cajero
        with self.cajeros.request() as req:
            yield req
            
            # Calcular tiempo de espera
            espera = self.env.now - llegada
            self.tiempos_espera.append(espera)
            
            # Servicio
            tiempo_serv = self.tiempo_servicio(tipo_transaccion)
            yield self.env.timeout(tiempo_serv)
            
            # Calcular tiempo total en sistema
            tiempo_total = self.env.now - llegada
            self.tiempos_sistema.append(tiempo_total)
            self.clientes_atendidos += 1

def generador_clientes(env, banco, tasa_llegada):
    """Genera llegadas de clientes"""
    cliente_id = 0
    tipos = ['deposito', 'retiro', 'consulta']
    
    while True:
        # Tiempo entre llegadas (exponencial)
        yield env.timeout(random.expovariate(tasa_llegada))
        
        cliente_id += 1
        tipo = random.choice(tipos)
        env.process(banco.atender_cliente(cliente_id, tipo))

# Configuración y ejecución
random.seed(42)
env = simpy.Environment()
banco = Banco(env, num_cajeros=3)
env.process(generador_clientes(env, banco, tasa_llegada=1/5))  # 1 cada 5 min
env.run(until=480)  # 8 horas

# Resultados
print(f"Clientes atendidos: {banco.clientes_atendidos}")
print(f"Tiempo promedio de espera: {np.mean(banco.tiempos_espera):.2f} min")
print(f"Tiempo promedio en sistema: {np.mean(banco.tiempos_sistema):.2f} min")
print(f"Utilización: {sum(banco.tiempos_sistema)/(3*480)*100:.1f}%")
```

#### 4.3 Pruebas de Depuración

**Técnicas:**

1. **Print statements estratégicos**
2. **Logging detallado**
3. **Breakpoints**
4. **Casos de prueba simples**

```python
import logging

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def atender_cliente_debug(self, cliente_id, tipo_transaccion):
    llegada = self.env.now
    logger.debug(f"Cliente {cliente_id} llega en t={llegada:.2f}")
    
    with self.cajeros.request() as req:
        yield req
        espera = self.env.now - llegada
        logger.debug(f"Cliente {cliente_id} esperó {espera:.2f} min")
        
        # ... resto del código ...
```

### Entregables de Etapa 4

✅ **Código fuente completo**
✅ **Documentación del código**
✅ **Manual de usuario**
✅ **Casos de prueba ejecutados**

### Tiempo Estimado
**2-3 semanas** (20-25% del proyecto)

---

## Etapa 5: Verificación

### Objetivo
Asegurar que el CÓDIGO funciona correctamente.

### Actividades

1. **Revisión de código** (peer review)
2. **Pruebas unitarias**
3. **Trazas de eventos**
4. **Casos extremos**
5. **Comparación con cálculos manuales**

**Ejemplo de pruebas:**

```python
def test_banco_basico():
    """Prueba con 1 cliente y 1 cajero"""
    env = simpy.Environment()
    banco = Banco(env, num_cajeros=1)
    
    # Simular 1 cliente
    env.process(banco.atender_cliente(1, 'deposito'))
    env.run()
    
    # Verificaciones
    assert banco.clientes_atendidos == 1
    assert len(banco.tiempos_espera) == 1
    assert banco.tiempos_espera[0] == 0  # No esperó
    print("✓ Prueba básica pasada")

def test_banco_cola():
    """Prueba con 2 clientes y 1 cajero"""
    env = simpy.Environment()
    banco = Banco(env, num_cajeros=1)
    
    # 2 clientes llegan al mismo tiempo
    env.process(banco.atender_cliente(1, 'deposito'))
    env.process(banco.atender_cliente(2, 'deposito'))
    env.run()
    
    # Verificaciones
    assert banco.clientes_atendidos == 2
    assert banco.tiempos_espera[0] == 0  # Primero no esperó
    assert banco.tiempos_espera[1] > 0   # Segundo sí esperó
    print("✓ Prueba de cola pasada")

# Ejecutar pruebas
test_banco_basico()
test_banco_cola()
```

### Entregables de Etapa 5

✅ **Reporte de verificación**
✅ **Resultados de pruebas**
✅ **Código corregido**

### Tiempo Estimado
**1 semana** (8-10% del proyecto)

---

## Etapa 6: Validación

### Objetivo
Asegurar que el MODELO representa la REALIDAD.

### Actividades

1. **Validación de cara** (expertos)
2. **Validación estadística** (comparar con datos reales)
3. **Validación de sensibilidad**

**Ejemplo:**

```python
# Datos reales del banco
tiempos_reales_espera = [5.2, 6.1, 4.8, 7.3, 5.9, 6.5, 5.1]

# Ejecutar modelo 30 veces
tiempos_modelo = []
for i in range(30):
    random.seed(1000 + i)
    env = simpy.Environment()
    banco = Banco(env, 3)
    env.process(generador_clientes(env, banco, 1/5))
    env.run(until=480)
    tiempos_modelo.append(np.mean(banco.tiempos_espera))

# Prueba t
from scipy import stats
t_stat, p_value = stats.ttest_ind(tiempos_reales_espera, tiempos_modelo)

print(f"Estadístico t: {t_stat:.3f}")
print(f"P-value: {p_value:.3f}")

if p_value > 0.05:
    print("✓ MODELO VÁLIDO (no hay diferencia significativa)")
else:
    print("✗ Modelo necesita ajustes")
```

### Entregables de Etapa 6

✅ **Reporte de validación**
✅ **Resultados de pruebas estadísticas**
✅ **Aprobación de expertos**

### Tiempo Estimado
**1 semana** (8-10% del proyecto)

---

## Etapa 7: Experimentación

### Objetivo
Usar el modelo para responder preguntas.

### Actividades

1. **Diseñar experimentos**
2. **Ejecutar réplicas** (mínimo 30)
3. **Analizar sensibilidad**

**Ejemplo:**

```python
def ejecutar_experimento(num_cajeros, tasa_llegada, replicas=30):
    resultados = []
    
    for i in range(replicas):
        random.seed(2000 + i)
        env = simpy.Environment()
        banco = Banco(env, num_cajeros)
        env.process(generador_clientes(env, banco, tasa_llegada))
        env.run(until=480)
        
        resultados.append({
            'espera': np.mean(banco.tiempos_espera),
            'sistema': np.mean(banco.tiempos_sistema),
            'clientes': banco.clientes_atendidos
        })
    
    return resultados

# Experimentos
escenarios = {
    'Base (3 cajeros)': ejecutar_experimento(3, 1/5),
    'Agregar cajero': ejecutar_experimento(4, 1/5),
    'Más demanda': ejecutar_experimento(3, 1/4)
}

for nombre, datos in escenarios.items():
    esperas = [d['espera'] for d in datos]
    media = np.mean(esperas)
    ic = 1.96 * np.std(esperas) / np.sqrt(len(esperas))
    print(f"{nombre}: {media:.2f} ± {ic:.2f} min")
```

### Entregables de Etapa 7

✅ **Matriz de experimentos**
✅ **Resultados de todas las réplicas**
✅ **Análisis estadístico**

### Tiempo Estimado
**1-2 semanas** (10-15% del proyecto)

---

## Etapa 8: Análisis e Interpretación

### Objetivo
Extraer conclusiones y recomendaciones.

### Actividades

1. **Procesar datos de salida**
2. **Calcular intervalos de confianza**
3. **Comparar escenarios**
4. **Interpretar resultados**

### Entregables de Etapa 8

✅ **Tablas de resultados**
✅ **Gráficos comparativos**
✅ **Análisis de trade-offs**

### Tiempo Estimado
**1 semana** (8-10% del proyecto)

---

## Etapa 9: Documentación y Presentación

### Objetivo
Comunicar resultados a stakeholders.

### Estructura del Reporte

1. **Resumen ejecutivo** (1-2 páginas)
2. **Introducción**
3. **Metodología**
4. **Resultados**
5. **Recomendaciones**
6. **Conclusiones**
7. **Anexos**

### Entregables de Etapa 9

✅ **Reporte final**
✅ **Presentación ejecutiva**
✅ **Código fuente documentado**

### Tiempo Estimado
**1 semana** (8-10% del proyecto)

---

## Resumen de Tiempos

| Etapa | Tiempo | % Proyecto |
|-------|--------|------------|
| 1. Definición | 1-2 sem | 10-15% |
| 2. Formulación | 1-2 sem | 10-15% |
| 3. Colección datos | 2-3 sem | 20-25% |
| 4. Implementación | 2-3 sem | 20-25% |
| 5. Verificación | 1 sem | 8-10% |
| 6. Validación | 1 sem | 8-10% |
| 7. Experimentación | 1-2 sem | 10-15% |
| 8. Análisis | 1 sem | 8-10% |
| 9. Documentación | 1 sem | 8-10% |
| **TOTAL** | **12-18 sem** | **100%** |

---

*Referencia: Programa SCD-1022 - TecNM*  
*Fuentes: Law & Kelton (1991), Banks et al. (2010)*


---

<div align="center">

⬅️ [1.4 Fases del Estudio](1.4.md) &nbsp;&nbsp;|&nbsp;&nbsp; [1.6 Componentes DES](1.6.md) ➡️

</div>
