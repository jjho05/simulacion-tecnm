# 1.6 Elementos básicos de un simulador de eventos discretos

Un simulador de eventos discretos (DES - Discrete Event Simulator) es un programa que modela sistemas donde los cambios de estado ocurren en puntos discretos del tiempo. Para funcionar correctamente, todo simulador DES debe implementar cinco componentes fundamentales que trabajan en conjunto.

---

## Visión General de los Componentes

### Arquitectura de un Simulador DES

```
┌─────────────────────────────────────────────────┐
│           SIMULADOR DE EVENTOS DISCRETOS        │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌──────────────┐      ┌──────────────────┐   │
│  │ RELOJ DE     │◄────►│ LISTA DE EVENTOS │   │
│  │ SIMULACIÓN   │      │ (Event Calendar) │   │
│  └──────────────┘      └──────────────────┘   │
│         ▲                      ▲               │
│         │                      │               │
│         ▼                      ▼               │
│  ┌──────────────┐      ┌──────────────────┐   │
│  │ RUTINAS DE   │◄────►│ GENERADOR DE     │   │
│  │ EVENTOS      │      │ NÚMEROS ALEATORIOS│   │
│  └──────────────┘      └──────────────────┘   │
│         ▲                                      │
│         │                                      │
│         ▼                                      │
│  ┌──────────────────────────────────────┐     │
│  │ CONTADOR DE ESTADÍSTICAS             │     │
│  └──────────────────────────────────────┘     │
│                                                 │
└─────────────────────────────────────────────────┘
```

---

## 1. Reloj de Simulación

### Definición
Variable que mantiene el **tiempo actual** de la simulación. A diferencia del tiempo real que avanza continuamente, el reloj de simulación "salta" de un evento al siguiente.

### Características

- **Tiempo discreto:** Solo avanza cuando ocurre un evento
- **No es tiempo real:** Puede simular años en segundos
- **Monotónicamente creciente:** Nunca retrocede
- **Precisión:** Generalmente en punto flotante

### Funcionamiento

```python
class RelojSimulacion:
    def __init__(self):
        self.tiempo_actual = 0.0
    
    def avanzar_a(self, nuevo_tiempo):
        """Avanza el reloj al tiempo del próximo evento"""
        if nuevo_tiempo < self.tiempo_actual:
            raise ValueError("El tiempo no puede retroceder")
        self.tiempo_actual = nuevo_tiempo
    
    def obtener_tiempo(self):
        """Retorna el tiempo actual de la simulación"""
        return self.tiempo_actual

# Ejemplo de uso
reloj = RelojSimulacion()
print(f"Tiempo inicial: {reloj.obtener_tiempo()}")  # 0.0

reloj.avanzar_a(5.3)
print(f"Después del evento 1: {reloj.obtener_tiempo()}")  # 5.3

reloj.avanzar_a(12.7)
print(f"Después del evento 2: {reloj.obtener_tiempo()}")  # 12.7
```

### Ejemplo Visual

```
Tiempo Real (continuo):
|-------|-------|-------|-------|-------|
0       1       2       3       4       5

Reloj de Simulación (discreto):
0.0 ──────► 2.3 ─────► 4.7 ──────► 8.1
    (evento)    (evento)    (evento)
```

### Tipos de Avance del Tiempo

| Tipo | Descripción | Cuándo usar |
|------|-------------|-------------|
| **Next-Event** | Salta al próximo evento | Más eficiente, usado comúnmente |
| **Fixed-Increment** | Avanza en incrementos fijos | Simulaciones continuas |
| **Hybrid** | Combina ambos | Sistemas mixtos |

---

## 2. Lista de Eventos (Event Calendar)

### Definición
Estructura de datos que mantiene todos los **eventos futuros programados**, ordenados por tiempo de ocurrencia.

### Características

- **Ordenada:** Eventos ordenados por tiempo
- **Dinámica:** Se agregan y eliminan eventos constantemente
- **Eficiente:** Debe permitir inserciones y búsquedas rápidas

### Implementación

```python
import heapq
from dataclasses import dataclass, field
from typing import Any

@dataclass(order=True)
class Evento:
    tiempo: float
    tipo: str = field(compare=False)
    datos: Any = field(compare=False, default=None)

class ListaEventos:
    def __init__(self):
        self.eventos = []  # Heap (cola de prioridad)
    
    def programar(self, tiempo, tipo, datos=None):
        """Programa un nuevo evento"""
        evento = Evento(tiempo, tipo, datos)
        heapq.heappush(self.eventos, evento)
    
    def proximo_evento(self):
        """Retorna y elimina el próximo evento"""
        if self.eventos:
            return heapq.heappop(self.eventos)
        return None
    
    def ver_proximo(self):
        """Ve el próximo evento sin eliminarlo"""
        if self.eventos:
            return self.eventos[0]
        return None
    
    def esta_vacia(self):
        """Verifica si hay eventos pendientes"""
        return len(self.eventos) == 0
    
    def mostrar_eventos(self):
        """Muestra todos los eventos programados"""
        eventos_ordenados = sorted(self.eventos)
        for evento in eventos_ordenados:
            print(f"t={evento.tiempo:.2f}: {evento.tipo}")

# Ejemplo de uso
lista = ListaEventos()

# Programar eventos
lista.programar(5.3, "llegada_cliente", {"id": 1})
lista.programar(2.1, "fin_servicio", {"id": 0})
lista.programar(8.7, "llegada_cliente", {"id": 2})

print("Eventos programados:")
lista.mostrar_eventos()

# Procesar eventos en orden
print("\nProcesando eventos:")
while not lista.esta_vacia():
    evento = lista.proximo_evento()
    print(f"t={evento.tiempo:.2f}: {evento.tipo} - {evento.datos}")
```

**Salida:**
```
Eventos programados:
t=2.10: fin_servicio
t=5.30: llegada_cliente
t=8.70: llegada_cliente

Procesando eventos:
t=2.10: fin_servicio - {'id': 0}
t=5.30: llegada_cliente - {'id': 1}
t=8.70: llegada_cliente - {'id': 2}
```

### Estructuras de Datos Comunes

| Estructura | Complejidad Inserción | Complejidad Búsqueda | Uso |
|------------|----------------------|---------------------|-----|
| **Heap** | O(log n) | O(1) | Más común |
| **Lista ordenada** | O(n) | O(1) | Pocas inserciones |
| **Árbol binario** | O(log n) | O(log n) | Búsquedas frecuentes |

---

## 3. Generador de Números Aleatorios

### Definición
Componente que produce la **variabilidad** necesaria para simular la incertidumbre del mundo real.

### Importancia

Sin aleatoriedad, la simulación sería determinística y no capturaría la variabilidad real del sistema.

### Tipos de Generadores

#### 3.1 Generador de Números Pseudoaleatorios (PRNG)

```python
class GeneradorLinealCongruencial:
    """Generador Lineal Congruencial (LCG)"""
    def __init__(self, semilla=12345, a=1664525, c=1013904223, m=2**32):
        self.semilla = semilla
        self.a = a
        self.c = c
        self.m = m
        self.actual = semilla
    
    def siguiente(self):
        """Genera el próximo número pseudoaleatorio"""
        self.actual = (self.a * self.actual + self.c) % self.m
        return self.actual / self.m  # Normalizar a [0, 1)
    
    def reiniciar(self, nueva_semilla=None):
        """Reinicia el generador con una nueva semilla"""
        if nueva_semilla is None:
            nueva_semilla = self.semilla
        self.actual = nueva_semilla

# Ejemplo de uso
gen = GeneradorLinealCongruencial(semilla=42)

print("Primeros 10 números aleatorios:")
for i in range(10):
    print(f"{i+1}: {gen.siguiente():.6f}")

# Reiniciar para reproducibilidad
gen.reiniciar(42)
print(f"\nPrimer número después de reiniciar: {gen.siguiente():.6f}")
```

#### 3.2 Generación de Variables Aleatorias

```python
import math

class GeneradorVariables:
    def __init__(self, generador_base):
        self.gen = generador_base
    
    def exponencial(self, media):
        """Genera variable aleatoria exponencial"""
        u = self.gen.siguiente()
        return -media * math.log(1 - u)
    
    def normal(self, media, desv_std):
        """Genera variable aleatoria normal (Box-Muller)"""
        u1 = self.gen.siguiente()
        u2 = self.gen.siguiente()
        
        z0 = math.sqrt(-2 * math.log(u1)) * math.cos(2 * math.pi * u2)
        return media + desv_std * z0
    
    def uniforme(self, a, b):
        """Genera variable aleatoria uniforme en [a, b]"""
        u = self.gen.siguiente()
        return a + (b - a) * u

# Ejemplo de uso
gen_base = GeneradorLinealCongruencial(semilla=123)
gen_vars = GeneradorVariables(gen_base)

print("Tiempos entre llegadas (exponencial, media=5):")
for i in range(5):
    tiempo = gen_vars.exponencial(5)
    print(f"  {tiempo:.2f} minutos")

print("\nTiempos de servicio (normal, μ=4, σ=1):")
for i in range(5):
    tiempo = gen_vars.normal(4, 1)
    print(f"  {tiempo:.2f} minutos")
```

### Importancia de la Semilla

```python
# Misma semilla = mismos resultados (reproducibilidad)
gen1 = GeneradorLinealCongruencial(semilla=42)
gen2 = GeneradorLinealCongruencial(semilla=42)

print("Generador 1:", [gen1.siguiente() for _ in range(3)])
print("Generador 2:", [gen2.siguiente() for _ in range(3)])
# Ambos producen los mismos números

# Diferente semilla = diferentes resultados
gen3 = GeneradorLinealCongruencial(semilla=99)
print("Generador 3:", [gen3.siguiente() for _ in range(3)])
# Produce números diferentes
```

---

## 4. Rutinas de Eventos

### Definición
Código específico que se ejecuta cuando ocurre cada tipo de evento.

### Tipos Comunes de Eventos

| Evento | Descripción | Acciones Típicas |
|--------|-------------|------------------|
| **Llegada** | Entidad entra al sistema | Programar próxima llegada, verificar recursos |
| **Inicio servicio** | Entidad comienza a ser atendida | Ocupar recurso, programar fin de servicio |
| **Fin servicio** | Entidad termina de ser atendida | Liberar recurso, registrar estadísticas |
| **Salida** | Entidad deja el sistema | Actualizar contadores |

### Implementación

```python
class SimuladorBanco:
    def __init__(self, num_cajeros):
        self.reloj = RelojSimulacion()
        self.lista_eventos = ListaEventos()
        self.cajeros_libres = num_cajeros
        self.cola = []
        self.estadisticas = {
            'clientes_atendidos': 0,
            'tiempo_total_espera': 0
        }
    
    def rutina_llegada(self, cliente_id):
        """Rutina ejecutada cuando llega un cliente"""
        print(f"t={self.reloj.obtener_tiempo():.2f}: Cliente {cliente_id} llega")
        
        # Programar próxima llegada
        tiempo_entre_llegadas = 5  # Simplificado
        self.lista_eventos.programar(
            self.reloj.obtener_tiempo() + tiempo_entre_llegadas,
            "llegada",
            {"id": cliente_id + 1}
        )
        
        # ¿Hay cajero disponible?
        if self.cajeros_libres > 0:
            self.rutina_inicio_servicio(cliente_id)
        else:
            # Agregar a cola
            self.cola.append({
                'id': cliente_id,
                'tiempo_llegada': self.reloj.obtener_tiempo()
            })
            print(f"  Cliente {cliente_id} entra a cola")
    
    def rutina_inicio_servicio(self, cliente_id):
        """Rutina ejecutada cuando inicia el servicio"""
        print(f"t={self.reloj.obtener_tiempo():.2f}: Cliente {cliente_id} inicia servicio")
        
        # Ocupar cajero
        self.cajeros_libres -= 1
        
        # Programar fin de servicio
        tiempo_servicio = 4  # Simplificado
        self.lista_eventos.programar(
            self.reloj.obtener_tiempo() + tiempo_servicio,
            "fin_servicio",
            {"id": cliente_id}
        )
    
    def rutina_fin_servicio(self, cliente_id):
        """Rutina ejecutada cuando termina el servicio"""
        print(f"t={self.reloj.obtener_tiempo():.2f}: Cliente {cliente_id} termina servicio")
        
        # Liberar cajero
        self.cajeros_libres += 1
        self.estadisticas['clientes_atendidos'] += 1
        
        # ¿Hay alguien en cola?
        if self.cola:
            siguiente = self.cola.pop(0)
            tiempo_espera = self.reloj.obtener_tiempo() - siguiente['tiempo_llegada']
            self.estadisticas['tiempo_total_espera'] += tiempo_espera
            self.rutina_inicio_servicio(siguiente['id'])
    
    def ejecutar(self, tiempo_fin):
        """Bucle principal de simulación"""
        # Programar primera llegada
        self.lista_eventos.programar(0, "llegada", {"id": 1})
        
        # Procesar eventos
        while not self.lista_eventos.esta_vacia():
            evento = self.lista_eventos.proximo_evento()
            
            # Avanzar reloj
            if evento.tiempo > tiempo_fin:
                break
            self.reloj.avanzar_a(evento.tiempo)
            
            # Ejecutar rutina apropiada
            if evento.tipo == "llegada":
                self.rutina_llegada(evento.datos['id'])
            elif evento.tipo == "fin_servicio":
                self.rutina_fin_servicio(evento.datos['id'])
        
        # Reporte final
        print(f"\n=== Simulación terminada en t={self.reloj.obtener_tiempo():.2f} ===")
        print(f"Clientes atendidos: {self.estadisticas['clientes_atendidos']}")
        if self.estadisticas['clientes_atendidos'] > 0:
            espera_prom = (self.estadisticas['tiempo_total_espera'] / 
                          self.estadisticas['clientes_atendidos'])
            print(f"Tiempo promedio de espera: {espera_prom:.2f}")

# Ejecutar simulación
sim = SimuladorBanco(num_cajeros=2)
sim.ejecutar(tiempo_fin=30)
```

---

## 5. Contador de Estadísticas

### Definición
Variables que **acumulan datos** durante la simulación para generar el reporte final.

### Tipos de Estadísticas

#### 5.1 Estadísticas de Conteo

```python
class ContadorEstadisticas:
    def __init__(self):
        # Contadores simples
        self.clientes_llegados = 0
        self.clientes_atendidos = 0
        self.clientes_rechazados = 0
        
        # Acumuladores
        self.tiempo_total_espera = 0.0
        self.tiempo_total_servicio = 0.0
        
        # Listas para análisis detallado
        self.tiempos_espera = []
        self.tiempos_servicio = []
        self.tiempos_sistema = []
    
    def registrar_llegada(self):
        """Registra la llegada de un cliente"""
        self.clientes_llegados += 1
    
    def registrar_espera(self, tiempo):
        """Registra tiempo de espera de un cliente"""
        self.tiempo_total_espera += tiempo
        self.tiempos_espera.append(tiempo)
    
    def registrar_servicio(self, tiempo):
        """Registra tiempo de servicio"""
        self.tiempo_total_servicio += tiempo
        self.tiempos_servicio.append(tiempo)
        self.clientes_atendidos += 1
    
    def registrar_sistema(self, tiempo):
        """Registra tiempo total en sistema"""
        self.tiempos_sistema.append(tiempo)
    
    def generar_reporte(self):
        """Genera reporte de estadísticas"""
        print("\n=== REPORTE DE ESTADÍSTICAS ===")
        print(f"Clientes llegados: {self.clientes_llegados}")
        print(f"Clientes atendidos: {self.clientes_atendidos}")
        print(f"Clientes rechazados: {self.clientes_rechazados}")
        
        if self.clientes_atendidos > 0:
            print(f"\nTiempo promedio de espera: "
                  f"{self.tiempo_total_espera/self.clientes_atendidos:.2f}")
            print(f"Tiempo promedio de servicio: "
                  f"{self.tiempo_total_servicio/self.clientes_atendidos:.2f}")
            print(f"Tiempo promedio en sistema: "
                  f"{sum(self.tiempos_sistema)/len(self.tiempos_sistema):.2f}")
            
            # Estadísticas adicionales
            import numpy as np
            print(f"\nEspera máxima: {max(self.tiempos_espera):.2f}")
            print(f"Espera mínima: {min(self.tiempos_espera):.2f}")
            print(f"Desv. std. espera: {np.std(self.tiempos_espera):.2f}")

# Ejemplo de uso
stats = ContadorEstadisticas()

# Simular algunos eventos
stats.registrar_llegada()
stats.registrar_espera(2.3)
stats.registrar_servicio(4.1)
stats.registrar_sistema(6.4)

stats.registrar_llegada()
stats.registrar_espera(0.0)
stats.registrar_servicio(3.8)
stats.registrar_sistema(3.8)

stats.generar_reporte()
```

#### 5.2 Estadísticas Basadas en Tiempo

```python
class EstadisticasTemporales:
    def __init__(self):
        self.tiempo_inicio = 0.0
        self.tiempo_ultimo_cambio = 0.0
        self.valor_actual = 0
        self.area_bajo_curva = 0.0
    
    def actualizar(self, tiempo_actual, nuevo_valor):
        """Actualiza estadística cuando cambia el valor"""
        # Acumular área
        duracion = tiempo_actual - self.tiempo_ultimo_cambio
        self.area_bajo_curva += self.valor_actual * duracion
        
        # Actualizar estado
        self.tiempo_ultimo_cambio = tiempo_actual
        self.valor_actual = nuevo_valor
    
    def promedio_temporal(self, tiempo_actual):
        """Calcula promedio ponderado por tiempo"""
        # Acumular área final
        duracion = tiempo_actual - self.tiempo_ultimo_cambio
        area_total = self.area_bajo_curva + self.valor_actual * duracion
        
        # Calcular promedio
        tiempo_total = tiempo_actual - self.tiempo_inicio
        return area_total / tiempo_total if tiempo_total > 0 else 0

# Ejemplo: Longitud promedio de cola
cola_stats = EstadisticasTemporales()

# t=0: 0 clientes en cola
cola_stats.actualizar(0, 0)

# t=2: llega 1 cliente
cola_stats.actualizar(2, 1)

# t=5: llega otro cliente (2 en cola)
cola_stats.actualizar(5, 2)

# t=8: se atiende 1 cliente (1 en cola)
cola_stats.actualizar(8, 1)

# t=10: se atiende el último (0 en cola)
cola_stats.actualizar(10, 0)

print(f"Longitud promedio de cola: {cola_stats.promedio_temporal(10):.2f}")
# Resultado: (0*2 + 1*3 + 2*3 + 1*2 + 0*0) / 10 = 1.1
```

---

## Integración de Todos los Componentes

### Simulador Completo

```python
import random

class SimuladorCompleto:
    def __init__(self, num_servidores, semilla=42):
        # Componentes básicos
        self.reloj = RelojSimulacion()
        self.lista_eventos = ListaEventos()
        self.generador = GeneradorLinealCongruencial(semilla)
        self.estadisticas = ContadorEstadisticas()
        
        # Estado del sistema
        self.servidores_libres = num_servidores
        self.cola = []
    
    def generar_tiempo_entre_llegadas(self):
        """Genera tiempo hasta próxima llegada"""
        u = self.generador.siguiente()
        return -5 * math.log(1 - u)  # Exponencial(5)
    
    def generar_tiempo_servicio(self):
        """Genera tiempo de servicio"""
        u = self.generador.siguiente()
        return 3 + 2 * u  # Uniforme(3, 5)
    
    def programar_llegada(self, cliente_id):
        """Programa próxima llegada"""
        tiempo_llegada = (self.reloj.obtener_tiempo() + 
                         self.generar_tiempo_entre_llegadas())
        self.lista_eventos.programar(tiempo_llegada, "llegada", 
                                     {"id": cliente_id})
    
    def procesar_llegada(self, cliente_id):
        """Procesa llegada de cliente"""
        self.estadisticas.registrar_llegada()
        
        if self.servidores_libres > 0:
            # Servicio inmediato
            self.servidores_libres -= 1
            self.estadisticas.registrar_espera(0)
            
            tiempo_servicio = self.generar_tiempo_servicio()
            tiempo_fin = self.reloj.obtener_tiempo() + tiempo_servicio
            self.lista_eventos.programar(tiempo_fin, "fin_servicio",
                                        {"id": cliente_id, 
                                         "tiempo_servicio": tiempo_servicio})
        else:
            # Agregar a cola
            self.cola.append({
                'id': cliente_id,
                'tiempo_llegada': self.reloj.obtener_tiempo()
            })
    
    def procesar_fin_servicio(self, datos):
        """Procesa fin de servicio"""
        self.estadisticas.registrar_servicio(datos['tiempo_servicio'])
        self.servidores_libres += 1
        
        if self.cola:
            # Atender siguiente en cola
            siguiente = self.cola.pop(0)
            tiempo_espera = self.reloj.obtener_tiempo() - siguiente['tiempo_llegada']
            self.estadisticas.registrar_espera(tiempo_espera)
            
            self.servidores_libres -= 1
            tiempo_servicio = self.generar_tiempo_servicio()
            tiempo_fin = self.reloj.obtener_tiempo() + tiempo_servicio
            self.lista_eventos.programar(tiempo_fin, "fin_servicio",
                                        {"id": siguiente['id'],
                                         "tiempo_servicio": tiempo_servicio})
    
    def ejecutar(self, tiempo_fin, num_clientes=None):
        """Ejecuta la simulación"""
        # Programar primera llegada
        self.programar_llegada(1)
        cliente_actual = 1
        
        while not self.lista_eventos.esta_vacia():
            evento = self.lista_eventos.proximo_evento()
            
            if evento.tiempo > tiempo_fin:
                break
            
            self.reloj.avanzar_a(evento.tiempo)
            
            if evento.tipo == "llegada":
                self.procesar_llegada(evento.datos['id'])
                cliente_actual += 1
                if num_clientes is None or cliente_actual <= num_clientes:
                    self.programar_llegada(cliente_actual)
            
            elif evento.tipo == "fin_servicio":
                self.procesar_fin_servicio(evento.datos)
        
        # Generar reporte
        self.estadisticas.generar_reporte()

# Ejecutar simulación completa
print("=== SIMULACIÓN COMPLETA ===\n")
sim = SimuladorCompleto(num_servidores=2, semilla=123)
sim.ejecutar(tiempo_fin=100)
```

---

## Resumen de Componentes

| Componente | Función Principal | Implementación Típica |
|------------|-------------------|----------------------|
| **Reloj** | Mantener tiempo actual | Variable flotante |
| **Lista de Eventos** | Ordenar eventos futuros | Heap / Cola de prioridad |
| **Generador Aleatorio** | Producir variabilidad | LCG / Mersenne Twister |
| **Rutinas de Eventos** | Ejecutar lógica de eventos | Funciones/métodos |
| **Estadísticas** | Acumular resultados | Contadores y listas |

---

*Referencia: Programa SCD-1022 - TecNM*  
*Fuentes: Law & Kelton (1991), Banks et al. (2010)*


---

<div align="center">

⬅️ [1.5 Metodología](1.5.md) &nbsp;&nbsp;|&nbsp;&nbsp; [1.7 Decisión de Uso](1.7.md) ➡️

</div>
