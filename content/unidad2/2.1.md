# 2.1 Métodos de generación de números pseudoaleatorios

Los números pseudoaleatorios son la base fundamental de cualquier simulación estocástica. Aunque son generados por algoritmos determinísticos, deben exhibir propiedades estadísticas similares a números verdaderamente aleatorios.

---

## Importancia de los Números Pseudoaleatorios

### ¿Por qué "pseudo"aleatorios?

**Números verdaderamente aleatorios:**
- Imposibles de predecir
- No reproducibles
- Fuente: Fenómenos físicos (ruido atmosférico, decaimiento radiactivo)

**Números pseudoaleatorios:**
- Generados por algoritmos
- Completamente determinísticos
- Reproducibles (misma semilla = misma secuencia)
- Suficientemente "aleatorios" para simulación

### Propiedades Deseables

1. **Uniformidad:** Distribución uniforme en [0,1)
2. **Independencia:** Cada número independiente de los anteriores
3. **Período largo:** Secuencia no se repite rápidamente
4. **Eficiencia:** Generación rápida
5. **Reproducibilidad:** Control mediante semilla

---

## 2.1.1 Método de los Cuadrados Medios (Middle Square)

### Historia

Propuesto por **John von Neumann** en 1946, fue uno de los primeros métodos computacionales para generar números pseudoaleatorios.

### Algoritmo

**Pasos:**

1. Tomar una semilla $X_0$ de $D$ dígitos
2. Calcular $X_0^2$
3. Si necesario, agregar ceros a la izquierda para tener $2D$ dígitos
4. Extraer los $D$ dígitos centrales para obtener $X_1$
5. Calcular $r_1 = X_1 / 10^D$ (normalizar a [0,1))
6. Repetir con $X_1$ como nueva semilla

### Ejemplo Numérico

**Datos:**
- Semilla: $X_0 = 5735$ (D = 4 dígitos)

**Iteración 1:**
```
X₀ = 5735
X₀² = 32,890,225
Agregar ceros: 32,890,225 (ya tiene 8 dígitos)
Extraer centro: 8902
X₁ = 8902
r₁ = 8902/10000 = 0.8902
```

**Iteración 2:**
```
X₁ = 8902
X₁² = 79,245,604
Dígitos centrales: 2456
X₂ = 2456
r₂ = 0.2456
```

**Iteración 3:**
```
X₂ = 2456
X₂² = 6,031,936
Agregar cero: 06,031,936
Dígitos centrales: 0319
X₃ = 319
r₃ = 0.0319
```

### Implementación en Python

```python
def cuadrados_medios(semilla, n, digitos=4):
    """
    Genera números pseudoaleatorios usando método de cuadrados medios.
    
    Args:
        semilla: Número inicial de 'digitos' dígitos
        n: Cantidad de números a generar
        digitos: Número de dígitos (default 4)
    
    Returns:
        Lista de números en [0,1)
    """
    numeros = []
    x = semilla
    
    for i in range(n):
        # Elevar al cuadrado
        x_cuadrado = x ** 2
        
        # Convertir a string con ceros a la izquierda
        str_cuadrado = str(x_cuadrado).zfill(digitos * 2)
        
        # Extraer dígitos centrales
        inicio = digitos // 2
        fin = inicio + digitos
        x = int(str_cuadrado[inicio:fin])
        
        # Normalizar a [0,1)
        r = x / (10 ** digitos)
        numeros.append(r)
        
        print(f"Iteración {i+1}: X={x:0{digitos}d}, r={r:.{digitos}f}")
    
    return numeros

# Ejemplo de uso
numeros = cuadrados_medios(semilla=5735, n=10, digitos=4)
print(f"\nPrimeros 10 números: {numeros}")
```

### Ventajas y Desventajas

**Ventajas:**
- ✅ Muy simple de implementar
- ✅ Fácil de entender
- ✅ Histórico (primer método computacional)

**Desventajas:**
- ❌ Período muy corto
- ❌ Puede caer en ciclos degenerados (ej: 0000)
- ❌ No pasa pruebas estadísticas modernas
- ❌ Depende críticamente de la semilla

**Ejemplo de ciclo degenerado:**
```
Semilla: 0100
0100² = 0,010,000 → 0100 (ciclo de longitud 1!)
```

### Uso Actual

⚠️ **NO recomendado para uso práctico**
- Solo valor histórico y educativo
- Reemplazado por métodos superiores

---

## 2.1.2 Algoritmo Congruencial Lineal (LCG)

### Definición

El método más extendido y estudiado. Propuesto por **Lehmer (1949)**.

**Fórmula recursiva:**
$$X_{i+1} = (aX_i + c) \bmod m$$

**Parámetros:**
- $X_0$: Semilla ($0 \leq X_0 < m$)
- $a$: Multiplicador ($0 < a < m$)
- $c$: Incremento ($0 \leq c < m$)
- $m$: Módulo ($m > 0$)

**Número pseudoaleatorio:**
$$r_i = \frac{X_i}{m}$$

### Variantes

#### LCG Mixto ($c > 0$)

**Ejemplo:** Generador RANDU (IBM, 1960s)
```
X_{i+1} = (65539 · X_i) mod 2³¹
```

**Período máximo:** $m$ (si se cumplen condiciones de Hull-Dobell)

#### LCG Multiplicativo ($c = 0$)

**Ejemplo:** MINSTD
```
X_{i+1} = (16807 · X_i) mod (2³¹ - 1)
```

**Período máximo:** $m - 1$

### Teorema de Hull-Dobell

Para que un LCG mixto tenga **período completo** ($m$), debe cumplir:

1. $\gcd(c, m) = 1$ (c y m coprimos)
2. $a - 1$ divisible por todos los factores primos de $m$
3. Si $m$ es múltiplo de 4, entonces $a - 1$ también

### Ejemplo Numérico Completo

**Parámetros:**
- $X_0 = 7$ (semilla)
- $a = 5$ (multiplicador)
- $c = 3$ (incremento)
- $m = 16$ (módulo)

**Verificar Hull-Dobell:**
1. $\gcd(3, 16) = 1$ ✓
2. Factores primos de 16: solo 2. $(a-1) = 4$ es divisible por 2 ✓
3. 16 es múltiplo de 4, y $(a-1) = 4$ también ✓

**Generación:**

| i | $X_i$ | Cálculo | $X_{i+1}$ | $r_i$ |
|---|-------|---------|-----------|-------|
| 0 | 7 | $(5·7 + 3) \bmod 16$ | 6 | 0.4375 |
| 1 | 6 | $(5·6 + 3) \bmod 16$ | 1 | 0.0625 |
| 2 | 1 | $(5·1 + 3) \bmod 16$ | 8 | 0.5000 |
| 3 | 8 | $(5·8 + 3) \bmod 16$ | 11 | 0.6875 |
| 4 | 11 | $(5·11 + 3) \bmod 16$ | 10 | 0.6250 |
| 5 | 10 | $(5·10 + 3) \bmod 16$ | 5 | 0.3125 |

### Implementación en Python

```python
class LCG:
    """Generador Congruencial Lineal"""
    
    def __init__(self, semilla, a, c, m):
        """
        Args:
            semilla: Valor inicial X₀
            a: Multiplicador
            c: Incremento
            m: Módulo
        """
        self.semilla = semilla
        self.a = a
        self.c = c
        self.m = m
        self.actual = semilla
    
    def siguiente(self):
        """Genera el próximo número pseudoaleatorio"""
        self.actual = (self.a * self.actual + self.c) % self.m
        return self.actual / self.m
    
    def generar_secuencia(self, n):
        """Genera n números"""
        return [self.siguiente() for _ in range(n)]
    
    def reiniciar(self, nueva_semilla=None):
        """Reinicia el generador"""
        if nueva_semilla is None:
            nueva_semilla = self.semilla
        self.actual = nueva_semilla

# Ejemplo de uso
gen = LCG(semilla=7, a=5, c=3, m=16)

print("Primeros 10 números:")
for i in range(10):
    r = gen.siguiente()
    print(f"{i+1}: X={int(r*16):2d}, r={r:.4f}")

# Verificar período
gen.reiniciar(7)
secuencia = []
x = gen.actual

for i in range(20):
    secuencia.append(x)
    x = (gen.a * x + gen.c) % gen.m
    if x == gen.semilla:
        print(f"\nPeríodo encontrado: {i+1}")
        break
```

### Generadores LCG Comunes

| Nombre | a | c | m | Período | Uso |
|--------|---|---|---|---------|-----|
| **RANDU** | 65539 | 0 | 2³¹ | 2²⁹ | IBM (obsoleto) |
| **MINSTD** | 16807 | 0 | 2³¹-1 | 2³¹-2 | Minimal Standard |
| **Numerical Recipes** | 1664525 | 1013904223 | 2³² | 2³² | Libro NR |
| **ANSI C** | 1103515245 | 12345 | 2³¹ | 2³¹ | rand() de C |

### Problemas Conocidos

#### 1. Correlación Serial

**Problema RANDU:**
```python
# RANDU muestra correlación en 3D
# Los puntos caen en solo 15 planos!
a, m = 65539, 2**31
x = 1
puntos = []

for _ in range(1000):
    x = (a * x) % m
    r1 = x / m
    x = (a * x) % m
    r2 = x / m
    x = (a * x) % m
    r3 = x / m
    puntos.append((r1, r2, r3))

# Visualizar revela estructura no aleatoria
```

#### 2. Bits de Baja Calidad

Los bits menos significativos tienen período más corto.

**Ejemplo:**
```python
# Último bit de LCG con m = 2^k alterna 0,1,0,1...
gen = LCG(1, 5, 3, 16)
for i in range(10):
    x = int(gen.siguiente() * 16)
    print(f"X={x:2d}, último bit={x%2}")
# Resultado: 0,1,0,1,0,1,0,1,0,1 (patrón obvio)
```

---

## 2.1.3 Generadores Modernos

### Mersenne Twister (MT19937)

**Características:**
- Período: $2^{19937} - 1$ (enorme!)
- Pasa todas las pruebas estadísticas estándar
- Usado por defecto en Python, MATLAB, R

**Ventajas:**
- ✅ Período extremadamente largo
- ✅ Excelentes propiedades estadísticas
- ✅ Rápido

**Desventajas:**
- ❌ No criptográficamente seguro
- ❌ Requiere más memoria (624 palabras de estado)

**Uso en Python:**
```python
import random

# Python usa Mersenne Twister por defecto
random.seed(42)
numeros = [random.random() for _ in range(10)]
print(numeros)

# Reproducibilidad
random.seed(42)
numeros2 = [random.random() for _ in range(10)]
print(numeros == numeros2)  # True
```

### PCG (Permuted Congruential Generator)

**Características:**
- Más moderno (2014)
- Mejor que Mersenne Twister en muchos aspectos
- Más rápido y usa menos memoria

**Uso en NumPy:**
```python
import numpy as np

# NumPy usa PCG por defecto (desde versión 1.17)
rng = np.random.default_rng(seed=42)
numeros = rng.random(10)
print(numeros)
```

### Xorshift

**Características:**
- Muy rápido
- Basado en operaciones XOR y shift
- Usado en GPUs

**Implementación simple:**
```python
class Xorshift:
    def __init__(self, semilla=123456789):
        self.estado = semilla
    
    def siguiente(self):
        x = self.estado
        x ^= (x << 13) & 0xFFFFFFFF
        x ^= (x >> 17) & 0xFFFFFFFF
        x ^= (x << 5) & 0xFFFFFFFF
        self.estado = x
        return x / 0xFFFFFFFF

gen = Xorshift(42)
print([gen.siguiente() for _ in range(5)])
```

---

## Comparación de Métodos

| Método | Período | Velocidad | Calidad | Uso Actual |
|--------|---------|-----------|---------|------------|
| **Cuadrados Medios** | Muy corto | Lento | Mala | No (histórico) |
| **LCG Simple** | $m$ | Rápido | Regular | Educativo |
| **LCG Bueno** | $2^{31}$ | Rápido | Buena | Limitado |
| **Mersenne Twister** | $2^{19937}$ | Rápido | Excelente | Muy común |
| **PCG** | Configurable | Muy rápido | Excelente | Moderno |
| **Xorshift** | $2^{128}$ | Muy rápido | Buena | GPUs |

---

## Ejercicios Prácticos

### Ejercicio 1: Cuadrados Medios

Genere 5 números usando cuadrados medios con semilla 1234.

**Solución:**
```python
numeros = cuadrados_medios(1234, 5, 4)
# Resultado: [0.5227, 0.3215, 0.3362, 0.3043, 0.2602]
```

### Ejercicio 2: LCG

Dado $X_0=3$, $a=7$, $c=5$, $m=11$:
1. Genere los primeros 15 números
2. Identifique el período
3. Verifique si cumple Hull-Dobell

**Solución:**

1. **Generación:**
```python
gen = LCG(3, 7, 5, 11)
secuencia = gen.generar_secuencia(15)
print(secuencia)
```

2. **Período:** 11 (período completo)

3. **Hull-Dobell:**
   - $\gcd(5, 11) = 1$ ✓
   - 11 es primo, $(a-1)=6$ divisible por 11? No, pero...
   - Para primos, solo necesitamos gcd(c,m)=1 ✓

### Ejercicio 3: Comparación

Compare la calidad de:
- LCG simple (a=5, c=3, m=16)
- Mersenne Twister
- PCG

Genere 10,000 números y calcule:
- Media
- Varianza
- Prueba Chi-cuadrada

**Solución:**
```python
import numpy as np
from scipy import stats

# LCG
gen_lcg = LCG(1, 5, 3, 16)
nums_lcg = gen_lcg.generar_secuencia(10000)

# Mersenne Twister
np.random.seed(1)
nums_mt = np.random.random(10000)

# PCG
rng = np.random.default_rng(1)
nums_pcg = rng.random(10000)

# Análisis
for nombre, nums in [('LCG', nums_lcg), ('MT', nums_mt), ('PCG', nums_pcg)]:
    media = np.mean(nums)
    varianza = np.var(nums)
    
    # Chi-cuadrada (dividir en 10 bins)
    obs, _ = np.histogram(nums, bins=10, range=(0,1))
    esp = len(nums) / 10
    chi2, p = stats.chisquare(obs, [esp]*10)
    
    print(f"\n{nombre}:")
    print(f"  Media: {media:.4f} (esperado: 0.5)")
    print(f"  Varianza: {varianza:.4f} (esperado: 0.0833)")
    print(f"  Chi²: {chi2:.2f}, p-value: {p:.4f}")
```

---

## Mejores Prácticas

### 1. Selección del Generador

**Para simulación general:**
```python
import numpy as np
rng = np.random.default_rng(seed=42)  # PCG
```

**Para reproducibilidad:**
```python
import random
random.seed(42)  # Mersenne Twister
```

**Para educación:**
```python
# Implementar LCG simple para entender el concepto
```

### 2. Uso de Semillas

**Buenas prácticas:**
```python
# ✅ Usar semilla para reproducibilidad
np.random.seed(42)

# ✅ Documentar la semilla usada
SEED = 12345
rng = np.random.default_rng(SEED)

# ✅ Diferentes semillas para réplicas independientes
for replica in range(30):
    rng = np.random.default_rng(1000 + replica)
    # ... simulación ...
```

**Evitar:**
```python
# ❌ No usar semillas predecibles en producción
np.random.seed(1)  # Demasiado simple

# ❌ No reusar la misma semilla para réplicas
for replica in range(30):
    np.random.seed(42)  # ¡Todas iguales!
```

### 3. Testing

**Siempre verificar:**
```python
# Reproducibilidad
rng1 = np.random.default_rng(42)
nums1 = rng1.random(100)

rng2 = np.random.default_rng(42)
nums2 = rng2.random(100)

assert np.allclose(nums1, nums2), "No reproducible!"
```

---

## Recursos Adicionales

### Librerías Recomendadas

**Python:**
- `random` - Mersenne Twister
- `numpy.random` - PCG (default desde 1.17)
- `scipy.stats` - Distribuciones

**Otros lenguajes:**
- R: `set.seed()`, generadores múltiples
- MATLAB: `rng()`, Mersenne Twister
- C++: `<random>`, múltiples generadores

### Lecturas

1. **Knuth (1997)** - "The Art of Computer Programming, Vol 2" - Biblia de RNGs
2. **L'Ecuyer (1999)** - "Tables of Linear Congruential Generators"
3. **Matsumoto & Nishimura (1998)** - Paper original de Mersenne Twister

---

## Resumen

**Conceptos clave:**
- Números pseudoaleatorios son determinísticos pero parecen aleatorios
- LCG es el método más estudiado y usado históricamente
- Generadores modernos (MT, PCG) superiores para uso práctico
- Semilla permite reproducibilidad

**Recomendaciones:**
- Usar generadores modernos (NumPy default)
- Documentar semillas usadas
- Verificar reproducibilidad
- Entender limitaciones del generador elegido

---

*Referencia: Programa SCD-1022 - TecNM*  
*Fuentes: Knuth (1997), Law & Kelton (1991), L'Ecuyer (1999)*


---

<div align="center">

⬅️ [Inicio Unidad 2](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [2.2 Pruebas de Validación](2.2.md) ➡️

</div>
