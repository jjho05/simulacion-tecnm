# 2.2.2 De Aleatoriedad

Las pruebas de aleatoriedad tienen como objetivo detectar patrones o tendencias no aleatorias en una secuencia de números pseudoaleatorios. A diferencia de las pruebas de uniformidad (que validan la distribución), estas pruebas validan que el orden de aparición de los números sea impredecible.

---

## Introducción a las Pruebas de Aleatoriedad

Un generador puede ser perfectamente uniforme pero no aleatorio. Por ejemplo, la secuencia `0.1, 0.2, 0.3, ... 0.9` es muy uniforme pero totalmente predecible. Las pruebas de aleatoriedad buscan "rachas", "huecos", o agrupaciones que sugieran una estructura determinista subyacente que el ojo humano o las pruebas simples no detectan.

### Objetivos de estas Pruebas:
1. **Detectar tendencias:** Verificar que los valores no aumenten o disminuyan de forma sistemática.
2. **Validar la falta de patrones:** Asegurar que no existan secuencias repetitivas.
3. **Confirmar la impredecibilidad:** Garantizar que conocer un número no ayude a predecir el siguiente.

### Diferencia con Uniformidad e Independencia

| Propiedad | Qué Valida | Ejemplo de Fallo |
|-----------|------------|------------------|
| **Uniformidad** | Distribución equitativa | Todos los números entre 0.4-0.6 |
| **Aleatoriedad** | Ausencia de patrones | Secuencia 0.1, 0.2, 0.3, 0.4... |
| **Independencia** | No correlación temporal | $x_{i+1} = 1 - x_i$ |

---

## Prueba de Póker

### Concepto
Esta prueba se basa en analizar grupos de dígitos (generalmente grupos de 5) y clasificarlos según la frecuencia de sus dígitos, de manera análoga a una mano de póker. Se examina si la frecuencia observada de estas combinaciones coincide con las probabilidades teóricas.

### Clasificación de Manos (Grupos de 5 dígitos)

| Categoría | Descripción | Ejemplo | Probabilidad |
|-----------|-------------|---------|--------------|
| **Todos Diferentes (TD)** | 5 dígitos distintos | 12345 | 0.30240 |
| **Un Par (1P)** | 2 iguales, 3 distintos | 11234 | 0.50400 |
| **Dos Pares (2P)** | 2 pares iguales, 1 distinto | 11223 | 0.10800 |
| **Tercia (T)** | 3 iguales, 2 distintos | 11123 | 0.07200 |
| **Full (F)** | 3 iguales, 2 iguales | 11122 | 0.00900 |
| **Póker (P)** | 4 iguales, 1 distinto | 11112 | 0.00450 |
| **Quintilla (Q)** | 5 iguales | 11111 | 0.00010 |

### Cálculo de Probabilidades Teóricas

Para un grupo de 5 dígitos (0-9) independientes:

**Todos Diferentes (TD):**
$$P(TD) = \frac{10 \times 9 \times 8 \times 7 \times 6}{10^5} = 0.30240$$

**Un Par (1P):**
$$P(1P) = \frac{\binom{5}{2} \times 10 \times 9 \times 8 \times 7}{10^5} = 0.50400$$

### Procedimiento de Prueba χ²

**Paso 1: Extraer grupos de dígitos**

De cada número $r_i$ en [0,1], extraer 5 dígitos decimales:
- $r = 0.12345$ → grupo = "12345"
- $r = 0.11223$ → grupo = "11223"

**Paso 2: Clasificar cada grupo**

```python
def clasificar_mano(grupo):
    """Clasifica un grupo de 5 dígitos según tipo de mano"""
    from collections import Counter
    conteo = Counter(grupo)
    frecuencias = sorted(conteo.values(), reverse=True)
    
    if frecuencias == [1, 1, 1, 1, 1]: return 'TD'
    elif frecuencias == [2, 1, 1, 1]:    return '1P'
    elif frecuencias == [2, 2, 1]:       return '2P'
    elif frecuencias == [3, 1, 1]:       return 'T'
    elif frecuencias == [3, 2]:          return 'F'
    elif frecuencias == [4, 1]:          return 'P'
    elif frecuencias == [5]:             return 'Q'
    
# Ejemplo
print(clasificar_mano("12345"))  # TD
print(clasificar_mano("11223"))  # 2P
print(clasificar_mano("11111"))  # Q
```

**Paso 3: Contar frecuencias observadas**

**Paso 4: Calcular estadístico Chi-cuadrada**

$$\chi^2_0 = \sum_{i=1}^{k} \frac{(O_i - E_i)^2}{E_i}$$

**Paso 5: Decisión**

Comparar con $\chi^2_{\alpha, k-1}$ (típicamente k=5 después de agrupar categorías raras).

### Ejemplo Numérico Completo

**Datos:** 1000 números generados, extraemos 1000 grupos de 5 dígitos.

**Frecuencias Observadas:**
- TD: 305
- 1P: 498
- 2P: 112
- T: 68
- Otros (F+P+Q): 17

**Frecuencias Esperadas:**
- E(TD) = 1000 × 0.3024 = 302.4
- E(1P) = 1000 × 0.5040 = 504.0
- E(2P) = 1000 × 0.1080 = 108.0
- E(T) = 1000 × 0.0720 = 72.0
- E(Otros) = 1000 × 0.0136 = 13.6

**Cálculo:**
$$\chi^2_0 = \frac{(305-302.4)^2}{302.4} + \frac{(498-504)^2}{504} + \frac{(112-108)^2}{108} + \frac{(68-72)^2}{72} + \frac{(17-13.6)^2}{13.6}$$

$$= 0.022 + 0.071 + 0.148 + 0.222 + 0.850 = 1.313$$

**Valor Crítico:** $\chi^2_{0.05, 4} = 9.488$

**Decisión:** $1.313 < 9.488$ → ✅ **Acepta aleatoriedad**

### Implementación Completa en Python

```python
import numpy as np
from scipy.stats import chisquare
from collections import Counter

def poker_test(numbers, decimals=5, alpha=0.05):
    """
    Prueba de Póker completa para números pseudoaleatorios.
    
    Args:
        numbers: Lista de números en [0,1]
        decimals: Número de dígitos a extraer (default 5)
        alpha: Nivel de significancia
    
    Returns:
        dict con resultados completos
    """
    # Extraer grupos de dígitos
    grupos = []
    for n in numbers:
        s = format(n, f'.{decimals}f')[2:]
        if len(s) == decimals:
            grupos.append(s)
    
    # Clasificar cada grupo
    categorias = {'TD': 0, '1P': 0, '2P': 0, 'T': 0, 'F': 0, 'P': 0, 'Q': 0}
    
    for g in grupos:
        conteo = Counter(g)
        freqs = sorted(conteo.values(), reverse=True)
        
        if freqs == [1, 1, 1, 1, 1]: categorias['TD'] += 1
        elif freqs == [2, 1, 1, 1]:    categorias['1P'] += 1
        elif freqs == [2, 2, 1]:       categorias['2P'] += 1
        elif freqs == [3, 1, 1]:       categorias['T'] += 1
        elif freqs == [3, 2]:          categorias['F'] += 1
        elif freqs == [4, 1]:          categorias['P'] += 1
        elif freqs == [5]:             categorias['Q'] += 1
    
    # Probabilidades teóricas
    prob = {'TD': 0.3024, '1P': 0.5040, '2P': 0.1080, 
            'T': 0.0720, 'F': 0.0090, 'P': 0.0045, 'Q': 0.0001}
    
    n = len(grupos)
    
    # Agrupar categorías con E < 5
    obs = [categorias['TD'], categorias['1P'], categorias['2P'], 
           categorias['T'], categorias['F'] + categorias['P'] + categorias['Q']]
    
    esp = [n * prob['TD'], n * prob['1P'], n * prob['2P'], 
           n * prob['T'], n * (prob['F'] + prob['P'] + prob['Q'])]
    
    # Chi-cuadrada
    chi2_stat, p_value = chisquare(obs, f_exp=esp)
    
    # Valor crítico
    from scipy.stats import chi2
    df = len(obs) - 1
    chi2_crit = chi2.ppf(1 - alpha, df)
    
    return {
        'chi2_calculado': chi2_stat,
        'chi2_critico': chi2_crit,
        'p_value': p_value,
        'acepta_aleatoriedad': p_value > alpha,
        'observadas': categorias,
        'n_grupos': n
    }

# Ejemplo de uso
np.random.seed(42)
numeros = np.random.random(1000)

resultado = poker_test(numeros)

print("=== PRUEBA DE PÓKER ===")
print(f"Grupos analizados: {resultado['n_grupos']}")
print(f"\nDistribución observada:")
for cat, freq in resultado['observadas'].items():
    print(f"  {cat}: {freq}")

print(f"\nχ² calculado: {resultado['chi2_calculado']:.4f}")
print(f"χ² crítico: {resultado['chi2_critico']:.4f}")
print(f"P-value: {resultado['p_value']:.4f}")
print(f"\nResultado: {'✓ PASA' if resultado['acepta_aleatoriedad'] else '✗ FALLA'}")
```

---

## Prueba de Espacios (Gap Test)

### Concepto
Mide el número de dígitos (o números) que ocurren entre sucesivas apariciones de un dígito específico o un rango de valores. Si los números son aleatorios, la longitud del "espacio" (gap) debe seguir una distribución geométrica.

### Fundamento Teórico

Si definimos un evento $A$ con probabilidad $p$ (ej. número cae en [0.3, 0.5], entonces $p=0.2$), la probabilidad de que el primer éxito ocurra después de exactamente $k$ fallos es:

$$P(\text{gap} = k) = (1-p)^k \cdot p$$

Esta es la distribución geométrica.

### Algoritmo Paso a Paso

**1. Definir el rango objetivo**

Ejemplo: $A = [0.3, 0.5]$, entonces $p = 0.2$

**2. Recorrer la secuencia**

Marcar cada número que cae en $A$ y contar cuántos números hay entre marcas consecutivas.

**3. Tabular longitudes de gaps**

| Longitud Gap | Frecuencia Observada | Frecuencia Esperada |
|--------------|----------------------|---------------------|
| 0 | $O_0$ | $n \cdot p$ |
| 1 | $O_1$ | $n \cdot p(1-p)$ |
| 2 | $O_2$ | $n \cdot p(1-p)^2$ |
| ... | ... | ... |
| k | $O_k$ | $n \cdot p(1-p)^k$ |

**4. Aplicar Chi-cuadrada**

$$\chi^2_0 = \sum_{i=0}^{k} \frac{(O_i - E_i)^2}{E_i}$$

### Ejemplo Numérico

**Secuencia:** 100 números, rango $A = [0.4, 0.6]$ (p = 0.2)

**Números que caen en A:** posiciones 3, 5, 12, 15, 18, ...

**Gaps:** 
- Entre 3 y 5: gap = 1
- Entre 5 y 12: gap = 6
- Entre 12 y 15: gap = 2
- ...

**Distribución de gaps:**

| Gap | Observado | Esperado ($n \cdot p(1-p)^k$) |
|-----|-----------|-------------------------------|
| 0 | 4 | 20 × 0.2 = 4.0 |
| 1 | 3 | 20 × 0.16 = 3.2 |
| 2 | 2 | 20 × 0.128 = 2.56 |
| 3 | 3 | 20 × 0.1024 = 2.05 |
| 4+ | 8 | 20 × 0.4096 = 8.19 |

$$\chi^2_0 = \frac{(4-4)^2}{4} + \frac{(3-3.2)^2}{3.2} + ... = 0.35$$

**Valor crítico:** $\chi^2_{0.05, 4} = 9.488$

**Decisión:** ✅ Acepta aleatoriedad

### Implementación en Python

```python
def gap_test(numbers, a=0.3, b=0.5, alpha=0.05):
    """
    Prueba de Espacios (Gap Test)
    
    Args:
        numbers: Secuencia de números en [0,1]
        a, b: Límites del rango objetivo
        alpha: Nivel de significancia
    """
    p = b - a  # Probabilidad de caer en el rango
    
    # Identificar posiciones que caen en el rango
    en_rango = [i for i, x in enumerate(numbers) if a <= x < b]
    
    # Calcular gaps
    gaps = []
    for i in range(len(en_rango) - 1):
        gap = en_rango[i+1] - en_rango[i] - 1
        gaps.append(gap)
    
    # Tabular frecuencias
    max_gap = 10  # Agrupar gaps >= 10
    obs = [0] * (max_gap + 1)
    
    for g in gaps:
        if g < max_gap:
            obs[g] += 1
        else:
            obs[max_gap] += 1
    
    # Frecuencias esperadas
    n_gaps = len(gaps)
    esp = []
    for k in range(max_gap):
        esp.append(n_gaps * p * ((1-p)**k))
    esp.append(n_gaps * ((1-p)**max_gap))  # Resto
    
    # Chi-cuadrada
    chi2_stat, p_value = chisquare(obs, f_exp=esp)
    
    return {
        'chi2': chi2_stat,
        'p_value': p_value,
        'acepta': p_value > alpha,
        'n_gaps': n_gaps,
        'gaps': gaps[:10]  # Primeros 10 para inspección
    }

# Ejemplo
nums = np.random.random(1000)
res = gap_test(nums)
print(f"Gap Test: χ²={res['chi2']:.2f}, p={res['p_value']:.4f} → {'✓ PASA' if res['acepta'] else '✗ FALLA'}")
```

---

## Prueba de Corridas (Runs Test)

Las corridas evalúan la independencia comparando valores sucesivos.

### Corridas Arriba y Abajo de la Media

**Concepto:** Contar cuántas veces la secuencia cruza la media.

**Algoritmo:**
1. Calcular media $\bar{x}$
2. Asignar '+' si $x_i > \bar{x}$, '-' si $x_i \leq \bar{x}$
3. Contar corridas (secuencias consecutivas de mismo signo)

**Ejemplo:**
```
Números: 0.3, 0.7, 0.8, 0.2, 0.1, 0.6, 0.9
Media: 0.514
Signos:  -    +    +    -    -    +    +
Corridas: 1    2    2    3    3    4    4
```
Total de corridas: 4

**Estadístico:**
$$Z_0 = \frac{R - \mu_R}{\sigma_R}$$

Donde:
- $\mu_R = \frac{2n_1 n_2}{n} + 1$
- $\sigma_R^2 = \frac{2n_1 n_2(2n_1 n_2 - n)}{n^2(n-1)}$
- $n_1$ = cantidad de '+'
- $n_2$ = cantidad de '-'

### Corridas de Crecimiento y Decrecimiento

**Concepto:** Analizar tendencias ascendentes/descendentes.

**Algoritmo:**
1. Comparar $x_i$ con $x_{i+1}$
2. Asignar '+' si aumenta, '-' si disminuye
3. Contar cambios de tendencia

**Ejemplo:**
```
Números: 0.1, 0.3, 0.5, 0.2, 0.4, 0.6, 0.3
Cambios:  +    +    -    +    +    -
Corridas: 1    1    2    3    3    4
```
Total de corridas: 4

**Estadístico:**
$$Z_0 = \frac{R - \mu_R}{\sigma_R}$$

Donde:
- $\mu_R = \frac{2n-1}{3}$
- $\sigma_R^2 = \frac{16n-29}{90}$

### Implementación Completa

```python
def runs_test_above_below(numbers, alpha=0.05):
    """Prueba de corridas arriba/abajo de la media"""
    n = len(numbers)
    media = np.mean(numbers)
    
    # Asignar signos
    signos = ['+' if x > media else '-' for x in numbers]
    
    # Contar corridas
    corridas = 1
    for i in range(1, n):
        if signos[i] != signos[i-1]:
            corridas += 1
    
    # Contar + y -
    n1 = signos.count('+')
    n2 = signos.count('-')
    
    # Estadísticos
    mu_R = (2*n1*n2) / n + 1
    sigma_R = np.sqrt((2*n1*n2*(2*n1*n2 - n)) / (n**2 * (n-1)))
    
    z_stat = (corridas - mu_R) / sigma_R
    p_value = 2 * (1 - stats.norm.cdf(abs(z_stat)))
    
    return {
        'corridas': corridas,
        'z_stat': z_stat,
        'p_value': p_value,
        'acepta': p_value > alpha
    }

def runs_test_up_down(numbers, alpha=0.05):
    """Prueba de corridas arriba/abajo (tendencias)"""
    n = len(numbers)
    
    # Determinar tendencias
    tendencias = []
    for i in range(n-1):
        tendencias.append('+' if numbers[i+1] > numbers[i] else '-')
    
    # Contar corridas
    corridas = 1
    for i in range(1, len(tendencias)):
        if tendencias[i] != tendencias[i-1]:
            corridas += 1
    
    # Estadísticos
    mu_R = (2*n - 1) / 3
    sigma_R = np.sqrt((16*n - 29) / 90)
    
    z_stat = (corridas - mu_R) / sigma_R
    p_value = 2 * (1 - stats.norm.cdf(abs(z_stat)))
    
    return {
        'corridas': corridas,
        'z_stat': z_stat,
        'p_value': p_value,
        'acepta': p_value > alpha
    }

# Ejemplo de uso
nums = np.random.random(100)

res1 = runs_test_above_below(nums)
print(f"Corridas arriba/abajo media: R={res1['corridas']}, Z={res1['z_stat']:.2f}, p={res1['p_value']:.4f}")

res2 = runs_test_up_down(nums)
print(f"Corridas crecimiento/decrecimiento: R={res2['corridas']}, Z={res2['z_stat']:.2f}, p={res2['p_value']:.4f}")
```

---

## Ejercicios Prácticos

### Ejercicio 1: Análisis Manual de Póker

Dada la secuencia de números:
```
0.12345, 0.67890, 0.11223, 0.55555, 0.98765, 0.11111
```

1. Extraiga los grupos de 5 dígitos
2. Clasifique cada grupo
3. Si tuviéramos 1000 grupos con esta distribución, ¿pasaría la prueba?

**Solución:**
- 0.12345 → "12345" → TD
- 0.67890 → "67890" → TD
- 0.11223 → "11223" → 2P
- 0.55555 → "55555" → Q
- 0.98765 → "98765" → TD
- 0.11111 → "11111" → Q

Distribución: TD=3, 2P=1, Q=2

Para 1000 grupos con esta proporción:
- TD: 500 (esperado 302)
- 2P: 167 (esperado 108)
- Q: 333 (esperado 0.1)

**Conclusión:** ✗ FALLARÍA (demasiadas quintillas)

### Ejercicio 2: Gap Test Manual

Secuencia: `0.15, 0.42, 0.28, 0.51, 0.33, 0.47, 0.19, 0.55`
Rango: [0.4, 0.6]

1. Identifique números en el rango
2. Calcule los gaps
3. Compare con distribución geométrica

**Solución:**
- Números en rango: posiciones 1 (0.42), 3 (0.51), 5 (0.47), 7 (0.55)
- Gaps: [1, 1, 1]
- Todos los gaps son 1 → Sospechoso (demasiado regular)

---

## Casos de Estudio Reales

### Caso 1: El Generador RANDU (IBM)

**Problema:** Pasaba pruebas de uniformidad y póker, pero fallaba catastróficamente en pruebas de estructura 3D.

**Lección:** Las pruebas de aleatoriedad 1D no detectan todos los defectos.

### Caso 2: Criptografía y Aleatoriedad

En seguridad informática, una prueba de aleatoriedad fallida no es solo una curiosidad estadística, es una vulnerabilidad de seguridad. El NIST (National Institute of Standards and Technology) mantiene una batería de 15 pruebas estadísticas (STS - Statistical Test Suite) para validar generadores de números aleatorios para uso criptográfico.

---

## Resumen y Mejores Prácticas

**Conceptos Clave:**
- Aleatoriedad ≠ Uniformidad ≠ Independencia
- Póker: Detecta patrones en grupos de dígitos
- Gap: Detecta regularidad en apariciones
- Corridas: Detecta tendencias sistemáticas

**Recomendaciones:**
1. Usar múltiples pruebas (no solo una)
2. Muestras grandes (n > 10,000)
3. Reportar p-values, no solo decisiones binarias
4. Visualizar resultados cuando sea posible

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Law & Kelton (1991), Knuth (1997), NIST SP 800-22*


---

<div align="center">

⬅️ [2.2.1 Uniformidad](2.2.1.md) &nbsp;&nbsp;|&nbsp;&nbsp; [2.2.3 Independencia](2.2.3.md) ➡️

</div>
