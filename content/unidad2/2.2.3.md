# 2.2.3 De Independencia

Las pruebas de independencia verifican la ausencia de correlación entre los términos de una secuencia de números pseudoaleatorios. Una secuencia independiente es aquella donde la probabilidad de obtener un valor determinado no se ve afectada por los valores obtenidos anteriormente.

---

## La Importancia de la Independencia en Simulación

Si los números no son independientes, la simulación puede heredar sesgos estructurales. Por ejemplo, si un número alto siempre es seguido por un número bajo, los tiempos de espera promedio podrían parecer normales mientras que la variabilidad extrema del sistema real se pierde completamente.

### Diferencia entre Aleatoriedad e Independencia
- **Aleatoriedad:** Se refiere a la impredecibilidad global de la secuencia.
- **Independencia:** Se enfoca específicamente en la relación estadística entre pares o grupos de números sucesivos.

### Ejemplo de Falta de Independencia

**Generador defectuoso:**
```python
# Generador que alterna alto-bajo
def gen_alternante(n):
    nums = []
    alto = True
    for i in range(n):
        if alto:
            nums.append(random.uniform(0.7, 1.0))
        else:
            nums.append(random.uniform(0.0, 0.3))
        alto = not alto
    return nums

# Resultado: 0.85, 0.12, 0.91, 0.07, 0.78, 0.15, ...
# Uniforme: ✓ (50% en cada rango)
# Independiente: ✗ (predecible)
```

---

## Prueba de Corridas Arriba y Abajo

Esta prueba analiza las secuencias de incrementos (+) y decrementos (-) entre números sucesivos.

### Fundamento Teórico

En una secuencia verdaderamente aleatoria, la probabilidad de que un número sea mayor que el anterior es 0.5. El número de "corridas" (secuencias consecutivas de incrementos o decrementos) sigue una distribución conocida.

### Algoritmo Paso a Paso:

**1. Crear secuencia binaria**

Dada una secuencia $R = \{r_1, r_2, ..., r_n\}$:
- $s_i = 1$ si $r_{i+1} > r_i$ (sube)
- $s_i = 0$ si $r_{i+1} \leq r_i$ (baja)

**Ejemplo:**
```
Números: 0.3, 0.7, 0.5, 0.9, 0.2, 0.8
Signos:   1    0    1    0    1
```

**2. Contar corridas**

Una **corrida** es una secuencia ininterrumpida del mismo signo.

```
Signos:  1  0  1  0  1
Corridas: 1  2  3  4  5
```
Total de corridas: 5

**3. Calcular estadísticos teóricos**

Para una secuencia aleatoria de longitud $n$:

$$\mu_b = \frac{2n - 1}{3}$$

$$\sigma_b^2 = \frac{16n - 29}{90}$$

**4. Calcular estadístico Z**

$$Z_0 = \frac{b - \mu_b}{\sigma_b}$$

**5. Decisión**

Se acepta independencia si $|Z_0| \leq Z_{\alpha/2}$ (típicamente 1.96 para α=0.05)

### Ejemplo Numérico Completo

**Datos:** n = 100 números, b = 68 corridas observadas

**Cálculos:**
$$\mu_b = \frac{2(100) - 1}{3} = \frac{199}{3} = 66.33$$

$$\sigma_b^2 = \frac{16(100) - 29}{90} = \frac{1571}{90} = 17.46$$

$$\sigma_b = \sqrt{17.46} = 4.18$$

$$Z_0 = \frac{68 - 66.33}{4.18} = \frac{1.67}{4.18} = 0.40$$

**Valor crítico:** $Z_{0.025} = 1.96$

**Decisión:** $|0.40| < 1.96$ → ✅ **Acepta independencia**

### Interpretación de Resultados

| Valor de Z | Interpretación |
|------------|----------------|
| Z ≈ 0 | Número de corridas esperado (independiente) |
| Z << 0 | Muy pocas corridas (tendencia fuerte) |
| Z >> 0 | Demasiadas corridas (oscilación excesiva) |

**Ejemplo de Z negativo:**
```
Secuencia: 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8
Corridas: 1 (solo una corrida ascendente)
Z ≈ -5.2 → Tendencia ascendente clara
```

**Ejemplo de Z positivo:**
```
Secuencia: 0.5, 0.1, 0.9, 0.2, 0.8, 0.3, 0.7, 0.4
Corridas: 7 (alterna constantemente)
Z ≈ +4.8 → Oscilación artificial
```

### Implementación en Python

```python
import numpy as np
from scipy.stats import norm

def runs_test_independence(numbers, alpha=0.05):
    """
    Prueba de corridas arriba y abajo para independencia.
    
    Args:
        numbers: Secuencia de números
        alpha: Nivel de significancia
    
    Returns:
        dict con resultados completos
    """
    n = len(numbers)
    if n < 2:
        return {'error': 'Muestra muy pequeña'}
    
    # Crear secuencia de signos (1 si aumenta, 0 si disminuye)
    s = []
    for i in range(n - 1):
        s.append(1 if numbers[i+1] > numbers[i] else 0)
    
    # Contar corridas (cambios de tendencia)
    corridas = 1
    for i in range(len(s) - 1):
        if s[i] != s[i+1]:
            corridas += 1
    
    # Estadísticos teóricos
    mu = (2*n - 1) / 3
    var = (16*n - 29) / 90
    std = np.sqrt(var)
    
    # Estadístico Z
    z_stat = (corridas - mu) / std
    
    # P-value (prueba de dos colas)
    p_value = 2 * (1 - norm.cdf(abs(z_stat)))
    
    # Valor crítico
    z_crit = norm.ppf(1 - alpha/2)
    
    return {
        'corridas_observadas': corridas,
        'corridas_esperadas': mu,
        'z_stat': z_stat,
        'z_critico': z_crit,
        'p_value': p_value,
        'acepta_independencia': abs(z_stat) < z_crit,
        'interpretacion': interpretar_z(z_stat)
    }

def interpretar_z(z):
    """Interpreta el valor de Z"""
    if abs(z) < 1:
        return "Normal (independiente)"
    elif z < -2:
        return "Tendencia fuerte (dependencia positiva)"
    elif z > 2:
        return "Oscilación excesiva (dependencia negativa)"
    else:
        return "Leve desviación"

# Ejemplo de uso
np.random.seed(42)
numeros = np.random.random(100)

resultado = runs_test_independence(numeros)

print("=== PRUEBA DE CORRIDAS ===")
print(f"Corridas observadas: {resultado['corridas_observadas']}")
print(f"Corridas esperadas: {resultado['corridas_esperadas']:.2f}")
print(f"Z estadístico: {resultado['z_stat']:.4f}")
print(f"Z crítico: ±{resultado['z_critico']:.4f}")
print(f"P-value: {resultado['p_value']:.4f}")
print(f"Interpretación: {resultado['interpretacion']}")
print(f"Resultado: {'✓ PASA' if resultado['acepta_independencia'] else '✗ FALLA'}")
```

---

## Prueba de Autocorrelación

Verifica la correlación entre números que están separados por una distancia constante $m$ (lags).

### Fundamento Teórico

El coeficiente de autocorrelación mide la correlación lineal entre $r_i$ y $r_{i+m}$:

$$\rho_m = \frac{Cov(r_i, r_{i+m})}{\sigma_{r_i} \sigma_{r_{i+m}}}$$

Para una secuencia independiente, $\rho_m \approx 0$ para todo $m > 0$.

### Procedimiento Detallado

**1. Seleccionar lag (m)**

Típicamente se prueban m = 1, 2, 3, 5, 10

**2. Calcular autocorrelación estimada**

$$\hat{\rho}_m = \frac{\frac{1}{n-m}\sum_{i=1}^{n-m}(r_i - \bar{r})(r_{i+m} - \bar{r})}{\frac{1}{n}\sum_{i=1}^{n}(r_i - \bar{r})^2}$$

**3. Calcular error estándar**

Para muestras grandes:
$$\sigma_{\hat{\rho}} \approx \frac{1}{\sqrt{n}}$$

**4. Calcular estadístico Z**

$$Z_0 = \frac{\hat{\rho}_m}{\sigma_{\hat{\rho}}}$$

**5. Decisión**

Se acepta independencia si $|Z_0| \leq Z_{\alpha/2}$

### Ejemplo Numérico

**Datos:** n = 100, m = 1

**Cálculo de $\hat{\rho}_1$:**

```python
# Supongamos que calculamos y obtenemos:
rho_1 = 0.08

# Error estándar
sigma_rho = 1 / np.sqrt(100) = 0.10

# Estadístico Z
Z_0 = 0.08 / 0.10 = 0.80

# Valor crítico (α=0.05)
Z_crit = 1.96

# Decisión
|0.80| < 1.96 → Acepta independencia
```

### Implementación en Python

```python
def autocorrelation_test(numbers, max_lag=5, alpha=0.05):
    """
    Prueba de autocorrelación para múltiples lags.
    
    Args:
        numbers: Secuencia de números
        max_lag: Máximo lag a probar
        alpha: Nivel de significancia
    
    Returns:
        dict con resultados para cada lag
    """
    n = len(numbers)
    media = np.mean(numbers)
    
    # Varianza
    var = np.var(numbers, ddof=0)
    
    resultados = {}
    
    for m in range(1, max_lag + 1):
        # Calcular autocorrelación
        cov = 0
        for i in range(n - m):
            cov += (numbers[i] - media) * (numbers[i+m] - media)
        cov /= (n - m)
        
        rho = cov / var
        
        # Error estándar
        sigma_rho = 1 / np.sqrt(n)
        
        # Estadístico Z
        z_stat = rho / sigma_rho
        
        # P-value
        p_value = 2 * (1 - norm.cdf(abs(z_stat)))
        
        # Valor crítico
        z_crit = norm.ppf(1 - alpha/2)
        
        resultados[m] = {
            'rho': rho,
            'z_stat': z_stat,
            'p_value': p_value,
            'acepta': abs(z_stat) < z_crit
        }
    
    return resultados

# Ejemplo de uso
numeros = np.random.random(200)
resultados = autocorrelation_test(numeros, max_lag=5)

print("=== PRUEBA DE AUTOCORRELACIÓN ===")
print(f"{'Lag':<5} {'ρ':<10} {'Z':<10} {'P-value':<10} {'Resultado'}")
print("-" * 50)

for m, res in resultados.items():
    resultado_str = '✓ PASA' if res['acepta'] else '✗ FALLA'
    print(f"{m:<5} {res['rho']:<10.4f} {res['z_stat']:<10.4f} {res['p_value']:<10.4f} {resultado_str}")
```

---

## Prueba de Series (Prueba de Frecuencia Bidimensional)

Esta prueba verifica si pares de números consecutivos se distribuyen uniformemente en un plano bidimensional.

### Concepto Visual

Imaginemos graficar pares $(r_i, r_{i+1})$ en un plano:

```
1.0 |  •     •  •
    |    •      •  •
0.5 |  •  •  •    •
    | •     •  •
0.0 |_______________
    0.0   0.5   1.0
       r_i
```

Si los números son independientes, los puntos deben distribuirse uniformemente en todo el cuadrado unitario.

### Procedimiento

**1. Formar pares**

$(r_1, r_2), (r_2, r_3), ..., (r_{n-1}, r_n)$

Total de pares: $n-1$

**2. Dividir el cuadrado unitario**

Crear una cuadrícula de $k \times k$ celdas (típicamente k=5 o k=10)

**3. Contar frecuencias observadas**

$O_{ij}$ = número de pares que caen en la celda $(i,j)$

**4. Calcular frecuencias esperadas**

$$E_{ij} = \frac{n-1}{k^2}$$

**5. Aplicar Chi-cuadrada**

$$\chi^2_0 = \sum_{i=1}^{k} \sum_{j=1}^{k} \frac{(O_{ij} - E_{ij})^2}{E_{ij}}$$

**6. Decisión**

Comparar con $\chi^2_{\alpha, k^2-1}$

### Ejemplo Numérico

**Datos:** n = 101 números (100 pares), k = 5 celdas

**Frecuencia esperada:** $E = 100/25 = 4$ pares por celda

**Frecuencias observadas (matriz 5x5):**

|   | 0-0.2 | 0.2-0.4 | 0.4-0.6 | 0.6-0.8 | 0.8-1.0 |
|---|-------|---------|---------|---------|---------|
| **0-0.2** | 3 | 5 | 4 | 3 | 5 |
| **0.2-0.4** | 4 | 4 | 3 | 5 | 4 |
| **0.4-0.6** | 5 | 3 | 4 | 4 | 4 |
| **0.6-0.8** | 4 | 5 | 4 | 3 | 4 |
| **0.8-1.0** | 4 | 3 | 5 | 5 | 3 |

**Cálculo:**
$$\chi^2_0 = \frac{(3-4)^2}{4} + \frac{(5-4)^2}{4} + ... = 5.5$$

**Valor crítico:** $\chi^2_{0.05, 24} = 36.415$

**Decisión:** $5.5 < 36.415$ → ✅ **Acepta independencia**

### Implementación en Python

```python
def series_test(numbers, k=5, alpha=0.05):
    """
    Prueba de Series (frecuencia bidimensional).
    
    Args:
        numbers: Secuencia de números en [0,1]
        k: Número de divisiones por dimensión
        alpha: Nivel de significancia
    
    Returns:
        dict con resultados
    """
    n = len(numbers)
    
    # Formar pares
    pares = [(numbers[i], numbers[i+1]) for i in range(n-1)]
    
    # Crear matriz de frecuencias observadas
    obs = np.zeros((k, k))
    
    for x, y in pares:
        i = min(int(x * k), k-1)
        j = min(int(y * k), k-1)
        obs[i, j] += 1
    
    # Frecuencia esperada
    esp = (n-1) / (k**2)
    
    # Chi-cuadrada
    chi2_stat = np.sum((obs - esp)**2 / esp)
    
    # Grados de libertad
    df = k**2 - 1
    
    # Valor crítico
    from scipy.stats import chi2
    chi2_crit = chi2.ppf(1 - alpha, df)
    
    # P-value
    p_value = 1 - chi2.cdf(chi2_stat, df)
    
    return {
        'chi2_calculado': chi2_stat,
        'chi2_critico': chi2_crit,
        'p_value': p_value,
        'acepta_independencia': chi2_stat < chi2_crit,
        'matriz_observada': obs,
        'n_pares': n-1
    }

# Ejemplo de uso
numeros = np.random.random(101)
resultado = series_test(numeros, k=5)

print("=== PRUEBA DE SERIES ===")
print(f"Pares analizados: {resultado['n_pares']}")
print(f"χ² calculado: {resultado['chi2_calculado']:.4f}")
print(f"χ² crítico: {resultado['chi2_critico']:.4f}")
print(f"P-value: {resultado['p_value']:.4f}")
print(f"Resultado: {'✓ PASA' if resultado['acepta_independencia'] else '✗ FALLA'}")

# Visualizar matriz
import matplotlib.pyplot as plt
plt.figure(figsize=(8, 6))
plt.imshow(resultado['matriz_observada'], cmap='YlOrRd', interpolation='nearest')
plt.colorbar(label='Frecuencia')
plt.title('Distribución de Pares (Prueba de Series)')
plt.xlabel('r_{i+1}')
plt.ylabel('r_i')
plt.show()
```

---

## Ejercicios Prácticos

### Ejercicio 1: Corridas Manual

Dada la secuencia: `0.10, 0.20, 0.15, 0.30, 0.40, 0.25, 0.10, 0.50, 0.60, 0.05`

1. Genere la secuencia de signos (+, -)
2. Cuente el número de corridas
3. Con α = 0.05, determine si existe evidencia de falta de independencia

**Solución:**

```python
nums = [0.10, 0.20, 0.15, 0.30, 0.40, 0.25, 0.10, 0.50, 0.60, 0.05]
n = len(nums)

# Signos
signos = []
for i in range(n-1):
    signos.append('+' if nums[i+1] > nums[i] else '-')

print(f"Signos: {signos}")
# ['+', '-', '+', '+', '-', '-', '+', '+', '-']

# Corridas
corridas = 1
for i in range(len(signos)-1):
    if signos[i] != signos[i+1]:
        corridas += 1

print(f"Corridas: {corridas}")  # 6

# Estadísticos
mu = (2*n - 1) / 3 = 6.33
sigma = np.sqrt((16*n - 29) / 90) = 1.32
Z = (6 - 6.33) / 1.32 = -0.25

# |Z| = 0.25 < 1.96 → Acepta independencia
```

### Ejercicio 2: Autocorrelación

Utilice una muestra de 50 números y calcule la autocorrelación con lag m=3. Interprete el resultado.

### Ejercicio 3: Series Test Visual

Genere 100 números con un generador defectuoso que alterna alto-bajo. Grafique los pares y observe el patrón.

```python
# Generador defectuoso
def gen_alternante(n):
    nums = []
    for i in range(n):
        if i % 2 == 0:
            nums.append(np.random.uniform(0.6, 1.0))
        else:
            nums.append(np.random.uniform(0.0, 0.4))
    return nums

nums_malos = gen_alternante(100)

# Graficar pares
pares_x = nums_malos[:-1]
pares_y = nums_malos[1:]

plt.scatter(pares_x, pares_y, alpha=0.5)
plt.xlabel('r_i')
plt.ylabel('r_{i+1}')
plt.title('Pares de Generador Defectuoso')
plt.grid(True, alpha=0.3)
plt.show()

# Resultado: Se observan dos clusters (alto-bajo, bajo-alto)
```

---

## Casos de Uso en Ingeniería

### Caso 1: Sistemas de Inventario

Si los números que representan la demanda no son independientes, calcularemos niveles de stock de seguridad incorrectos, provocando roturas de stock o exceso de inventario.

**Ejemplo:**
- Demanda real: Autocorrelación positiva (ventas altas tienden a seguir ventas altas)
- Simulación con números independientes: Subestima variabilidad
- Resultado: Stock de seguridad insuficiente

### Caso 2: Tratamiento de Señales

En telecomunicaciones, el ruido aleatorio debe ser independiente; de lo contrario, se pueden generar interferencias periódicas que degradan la señal.

---

## Errores Típicos

### Error 1: Confundir con Uniformidad

❌ **Incorrecto:** "Pasó uniformidad, entonces es independiente"
✅ **Correcto:** Uniformidad e independencia son propiedades diferentes

### Error 2: Tamaño de Paso (Lag) Inadecuado

❌ **Incorrecto:** Solo probar lag=1
✅ **Correcto:** Probar múltiples lags (1, 2, 3, 5, 10)

**Razón:** Dependencias pueden aparecer en lags mayores.

### Error 3: No Considerar el Signo en Z

❌ **Incorrecto:** Solo mirar |Z|
✅ **Correcto:** Interpretar el signo

- Z muy negativo: Tendencia (muy pocas corridas)
- Z muy positivo: Oscilación excesiva (demasiadas corridas)

---

## Resumen y Mejores Prácticas

**Conceptos Clave:**
- Independencia: Ausencia de correlación temporal
- Corridas: Detecta tendencias y oscilaciones
- Autocorrelación: Mide correlación a diferentes lags
- Series: Detecta patrones bidimensionales

**Recomendaciones:**
1. Usar múltiples pruebas (corridas + autocorrelación + series)
2. Probar múltiples lags en autocorrelación
3. Visualizar pares cuando sea posible
4. Interpretar el signo de Z, no solo su magnitud

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Law & Kelton (1991), Knuth (1997), Box & Jenkins (1976)*


---

<div align="center">

⬅️ [2.2.2 Aleatoriedad](2.2.2.md) &nbsp;&nbsp;|&nbsp;&nbsp; [2.3 Monte Carlo](2.3.md) ➡️

</div>
