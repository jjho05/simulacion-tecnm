# 2.2 Pruebas estadísticas

La generación de números pseudoaleatorios es un proceso determinístico que intenta emular el comportamiento del azar. Por definición, estos números NO son aleatorios, pero para ser útiles en simulación, deben comportarse *como si lo fueran*. Las pruebas estadísticas son la herramienta para validar esta hipótesis.

---

## ¿Por qué necesitamos probar los números?

Un generador de números pseudoaleatorios (RNG) es un algoritmo matemático. Como tal, tiene limitaciones inherentes:
1. **Periodicidad:** Eventualmente, la secuencia se repetirá.
2. **Estructura de Retícula:** En dimensiones superiores, los puntos pueden alinearse en planos (como el infame caso RANDU).
3. **Correlación:** Un número puede depender matemáticamente del anterior.

Si usamos un RNG defectuoso en una simulación crítica (ej. diseño de reactores, criptografía financiera), los resultados serán **incorrectos y peligrosos**.

### El Objetivo de las Pruebas

No buscamos probar que los números "son aleatorios" (sabemos que no lo son). Buscamos probar que **no hay evidencia estadística suficiente para rechazar la hipótesis de que son aleatorios**.

> **Hipótesis Nula ($H_0$):** La secuencia de números generados proviene de una distribución independiente y uniforme $U[0,1]$.
> **Hipótesis Alternativa ($H_1$):** La secuencia no es uniforme o no es independiente.

---

## Clasificación de las Pruebas

Existen dos categorías principales de propiedades que todo buen generador debe cumplir:

### 1. Pruebas de Uniformidad (Ver 2.2.1)
Verifican que los números estén distribuidos equitativamente en todo el rango $[0, 1]$.
- Cada subintervalo debe tener la misma probabilidad de contener números.
- Métodos: Chi-cuadrada, Kolmogorov-Smirnov.

### 2. Pruebas de Aleatoriedad (Ver 2.2.2)
Verifican que no existan patrones predecibles en la secuencia.
- Métodos: Póker, Huecos (Gap), Corridas arriba/abajo de la media.

### 3. Pruebas de Independencia (Ver 2.2.3)
Verifican que no exista correlación o dependencia entre los números generados. Saber el valor de $x_i$ no debería ayudar a predecir $x_{i+1}$.
- Métodos: Pruebas de corridas, autocorrelación, series.

---

## Metodología General de Validación

El proceso profesional para validar un generador no se basa en una sola prueba, sino en una "batería" de pruebas.

### Paso 1: Generación de la Muestra
Se genera una secuencia larga (ej. $N > 10,000$) utilizando el generador a evaluar. Es crucial usar la misma semilla o configuración que se usará en producción.

### Paso 2: Aplicación de Pruebas "A Ciegas"
Se aplican múltiples pruebas estadísticas (uniformidad, corridas, póker, etc.).
- Ejemplo: Si pasamos la prueba de medias pero fallamos la de varianza, el generador se rechaza.

### Paso 3: Interpretación del P-value
Cada prueba estadística arroja un "p-value".
- Si $p\text{-value} < \alpha$ (usualmente 0.05): **Rechazamos $H_0$**. El generador es MALO.
- Si $p\text{-value} \ge \alpha$: No podemos rechazar $H_0$. El generador es ACEPTABLE (por ahora).

> **¡Cuidado!** Un p-value de 0.99999 es tan sospechoso como uno de 0.00001. Significa que los datos son "demasiado perfectos", lo cual tampoco es natural en el azar verdadero.

---

## Suites de Pruebas Estándar en la Industria

En el entorno profesional, no programamos las pruebas manualmente cada vez. Utilizamos suites estandarizadas reconocidas internacionalmente:

### 1. Diehard Tests (George Marsaglia)
Una batería de pruebas muy rigurosas ("difíciles de matar") que incluye pruebas como:
- **Birthday Spacings:** Basada en la paradoja del cumpleaños.
- **Overlapping Permutations:** Analiza el orden de 5 números consecutivos.
- **Parking Lot Test:** Simula autos estacionándose aleatoriamente.

### 2. NIST SP 800-22 (Estándar Criptográfico)
Desarrollada por el Instituto Nacional de Estándares y Tecnología de EE.UU. Es el estándar de oro para criptografía. Incluye 15 pruebas fundamentales como:
- Frecuencia de bloques.
- Rangos de matriz binaria.
- Transformada Discreta de Fourier (para detectar patrones periódicos).

### 3. TestU01 (Pierre L'Ecuyer)
Considerada actualmente la biblioteca más completa y estricta. Ha demostrado que muchos generadores antiguos (como los LCG de los libros de texto de los 90s) son defectuosos.

---

## Mapa Conceptual de la Sección 2.2

Para dominar la validación de números pseudoaleatorios, estudiaremos los siguientes temas específicos:

1. **[2.2.1] Pruebas de Uniformidad:** Chi-cuadrada y Kolmogorov-Smirnov. Lo básico e indispensable.
2. **[2.2.2] Pruebas de Aleatoriedad:** Póker, Huecos (Gap). Pruebas de estructura interna.
3. **[2.2.3] Pruebas de Independencia:** Corridas, Series, Autocorrelación. Detectando patrones temporales.

---

## Fundamentos Estadísticos de las Pruebas

### Distribución Chi-Cuadrada ($\chi^2$)

La distribución chi-cuadrada es fundamental para muchas pruebas de bondad de ajuste. Se define como la suma de cuadrados de variables normales estándar independientes.

**Propiedades:**
- Parámetro: grados de libertad ($k$)
- Media: $k$
- Varianza: $2k$
- Asimétrica (sesgada a la derecha)

```python
import numpy as np
from scipy import stats
import matplotlib.pyplot as plt

# Visualizar distribución Chi-cuadrada
x = np.linspace(0, 30, 1000)
for df in [1, 3, 5, 10]:
    plt.plot(x, stats.chi2.pdf(x, df), label=f'df={df}')

plt.xlabel('χ²')
plt.ylabel('Densidad')
plt.title('Distribución Chi-Cuadrada')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

### Distribución Normal Estándar (Z)

Muchas pruebas estadísticas convergen a la distribución normal para muestras grandes (Teorema del Límite Central).

**Regla 68-95-99.7:**
- 68% de los datos caen dentro de ±1σ
- 95% dentro de ±1.96σ (usado para α=0.05)
- 99.7% dentro de ±3σ

---

## Ejemplo Integrador: Validación Completa de un Generador

Vamos a validar un generador LCG completo usando múltiples pruebas:

```python
import numpy as np
from scipy import stats

class LCG:
    def __init__(self, semilla, a, c, m):
        self.semilla = semilla
        self.a, self.c, self.m = a, c, m
        self.actual = semilla
    
    def siguiente(self):
        self.actual = (self.a * self.actual + self.c) % self.m
        return self.actual / self.m
    
    def generar_secuencia(self, n):
        return [self.siguiente() for _ in range(n)]

# Generador a probar
gen = LCG(semilla=12345, a=1664525, c=1013904223, m=2**32)
numeros = gen.generar_secuencia(10000)

print("=== BATERÍA DE PRUEBAS ===\n")

# 1. Prueba de Uniformidad (Chi-Cuadrada)
k = 10  # intervalos
observadas, _ = np.histogram(numeros, bins=k, range=(0,1))
esperadas = np.full(k, len(numeros)/k)
chi2_stat, p_chi2 = stats.chisquare(observadas, f_exp=esperadas)

print(f"1. Prueba Chi-Cuadrada (Uniformidad):")
print(f"   χ² = {chi2_stat:.4f}")
print(f"   p-value = {p_chi2:.4f}")
print(f"   Resultado: {'✓ PASA' if p_chi2 > 0.05 else '✗ FALLA'}\n")

# 2. Prueba de Kolmogorov-Smirnov
d_stat, p_ks = stats.kstest(numeros, 'uniform')
print(f"2. Prueba Kolmogorov-Smirnov (Uniformidad):")
print(f"   D = {d_stat:.4f}")
print(f"   p-value = {p_ks:.4f}")
print(f"   Resultado: {'✓ PASA' if p_ks > 0.05 else '✗ FALLA'}\n")

# 3. Prueba de Corridas
def prueba_corridas(nums):
    n = len(nums)
    corridas = 1
    for i in range(n-1):
        if (nums[i+1] > nums[i]) != (nums[i] > nums[i-1] if i > 0 else False):
            corridas += 1
    
    mu = (2*n - 1) / 3
    sigma = np.sqrt((16*n - 29) / 90)
    z = (corridas - mu) / sigma
    p_value = 2 * (1 - stats.norm.cdf(abs(z)))
    
    return z, p_value, corridas

z_corr, p_corr, num_corr = prueba_corridas(numeros)
print(f"3. Prueba de Corridas (Independencia):")
print(f"   Corridas = {num_corr}")
print(f"   Z = {z_corr:.4f}")
print(f"   p-value = {p_corr:.4f}")
print(f"   Resultado: {'✓ PASA' if p_corr > 0.05 else '✗ FALLA'}\n")

# Resumen
pruebas_pasadas = sum([p_chi2 > 0.05, p_ks > 0.05, p_corr > 0.05])
print(f"=== RESUMEN ===")
print(f"Pruebas pasadas: {pruebas_pasadas}/3")
print(f"Veredicto: {'✓ GENERADOR ACEPTABLE' if pruebas_pasadas == 3 else '✗ GENERADOR RECHAZADO'}")
```

---

## Casos de Estudio: Generadores Famosos

### Caso 1: RANDU - El Peor Generador de la Historia

**Parámetros:**
- $a = 65539$
- $c = 0$
- $m = 2^{31}$

**Problema:** En 3 dimensiones, todos los puntos caen en solo 15 planos paralelos.

```python
# Demostración del problema de RANDU
a, m = 65539, 2**31
x = 1
puntos_3d = []

for _ in range(1000):
    x = (a * x) % m
    r1 = x / m
    x = (a * x) % m
    r2 = x / m
    x = (a * x) % m
    r3 = x / m
    puntos_3d.append((r1, r2, r3))

# Graficar en 3D revela los 15 planos
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
puntos = np.array(puntos_3d)
ax.scatter(puntos[:,0], puntos[:,1], puntos[:,2], s=1)
ax.set_title('RANDU: Estructura de 15 Planos')
plt.show()
```

**Lección:** Pasar pruebas de uniformidad 1D NO garantiza calidad en dimensiones superiores.

### Caso 2: Mersenne Twister - El Estándar Moderno

**Características:**
- Período: $2^{19937} - 1$
- Pasa todas las pruebas de Diehard y TestU01
- Usado por defecto en Python, MATLAB, R

**Limitación:** No es criptográficamente seguro (predecible con 624 salidas consecutivas).

---

## Errores Comunes al Realizar Pruebas

### Error 1: Tamaño de Muestra Insuficiente

❌ **Incorrecto:** Probar con n=100 números
✅ **Correcto:** Usar al menos n=10,000 (preferiblemente 100,000+)

**Razón:** Las pruebas estadísticas requieren muestras grandes para tener poder estadístico.

### Error 2: Probar Solo Uniformidad

❌ **Incorrecto:** Solo hacer Chi-cuadrada
✅ **Correcto:** Batería completa (uniformidad + aleatoriedad + independencia)

**Razón:** Un generador puede ser uniforme pero correlacionado.

### Error 3: Ignorar el P-value

❌ **Incorrecto:** Solo comparar estadístico con valor crítico
✅ **Correcto:** Reportar y analizar el p-value

**Razón:** El p-value da información sobre la magnitud de la evidencia.

### Error 4: No Documentar la Semilla

❌ **Incorrecto:** Probar con semilla aleatoria diferente cada vez
✅ **Correcto:** Documentar y usar la misma semilla para reproducibilidad

### Error 5: Confiar en Una Sola Corrida

❌ **Incorrecto:** Hacer una sola prueba y concluir
✅ **Correcto:** Repetir con diferentes semillas y promediar resultados

---

## Tabla de Valores Críticos de Referencia

### Chi-Cuadrada ($\alpha = 0.05$)

| Grados de Libertad | Valor Crítico |
|--------------------|---------------|
| 1 | 3.841 |
| 2 | 5.991 |
| 3 | 7.815 |
| 4 | 9.488 |
| 5 | 11.070 |
| 9 | 16.919 |
| 10 | 18.307 |
| 19 | 30.144 |
| 29 | 42.557 |

### Distribución Normal ($\alpha = 0.05$)

| Tipo de Prueba | Valor Crítico |
|----------------|---------------|
| Una cola (derecha) | 1.645 |
| Una cola (izquierda) | -1.645 |
| Dos colas | ±1.96 |

---

## Ejercicios Prácticos

### Ejercicio 1: Análisis de Generador Defectuoso

Dado el generador $X_{i+1} = (5X_i + 1) \bmod 16$ con semilla $X_0 = 7$:

1. Genere los primeros 32 números
2. Aplique prueba de uniformidad (Chi-cuadrada con k=4)
3. Aplique prueba de corridas
4. ¿Pasa las pruebas? ¿Por qué sí o por qué no?

**Solución:**

```python
# Generador
def gen_simple(x0, n):
    x, nums = x0, []
    for _ in range(n):
        x = (5*x + 1) % 16
        nums.append(x/16)
    return nums

nums = gen_simple(7, 32)
print(f"Secuencia: {[f'{n:.4f}' for n in nums[:10]]}")

# Chi-cuadrada
obs, _ = np.histogram(nums, bins=4, range=(0,1))
esp = np.full(4, 32/4)
chi2, p = stats.chisquare(obs, f_exp=esp)
print(f"\nChi²: {chi2:.2f}, p={p:.4f} → {'PASA' if p>0.05 else 'FALLA'}")

# Análisis: Pasa uniformidad pero falla independencia (período muy corto)
```

### Ejercicio 2: Comparación de Generadores

Compare 3 generadores usando una batería completa de pruebas:
1. LCG simple (a=5, c=1, m=16)
2. LCG "bueno" (parámetros de Numerical Recipes)
3. Mersenne Twister (numpy.random)

Genere tabla comparativa con resultados de todas las pruebas.

---

## Recursos y Herramientas

### Software Especializado

1. **TestU01 (C):** Biblioteca más completa
   - Descarga: http://simul.iro.umontreal.ca/testu01/tu01.html
   - Incluye SmallCrush, Crush, BigCrush

2. **NIST STS (C):** Suite oficial para criptografía
   - Descarga: https://csrc.nist.gov/projects/random-bit-generation

3. **DieHarder (Linux):** Versión mejorada de Diehard
   ```bash
   sudo apt-get install dieharder
   dieharder -a -f archivo_numeros.txt
   ```

### Librerías Python

```python
# Scipy para pruebas básicas
from scipy import stats

# Statsmodels para pruebas avanzadas
import statsmodels.api as sm

# Ejemplo: Prueba de Ljung-Box para autocorrelación
from statsmodels.stats.diagnostic import acorr_ljungbox
result = acorr_ljungbox(numeros, lags=10)
print(result)
```

---

## Checklist de Validación Profesional

Antes de usar un generador en producción, verificar:

- [ ] Prueba de Uniformidad (Chi-cuadrada)
- [ ] Prueba de Uniformidad (Kolmogorov-Smirnov)
- [ ] Prueba de Medias
- [ ] Prueba de Varianza
- [ ] Prueba de Corridas (arriba/abajo)
- [ ] Prueba de Póker
- [ ] Prueba de Autocorrelación (lag 1, 2, 5)
- [ ] Prueba de Series (2D)
- [ ] Documentación de semilla y parámetros
- [ ] Repetición con múltiples semillas

**Criterio de Aceptación:** Pasar al menos 8/10 pruebas con p-value > 0.05

---

## Conclusión

La validación estadística de generadores de números pseudoaleatorios no es opcional - es **crítica** para la validez de cualquier estudio de simulación. Un generador defectuoso puede:

- Subestimar variabilidad del sistema
- Introducir sesgos sistemáticos
- Invalidar completamente los resultados
- Llevar a decisiones empresariales erróneas

**Regla de Oro:** Nunca confíes en un generador sin probarlo. Y nunca confíes en una sola prueba - usa siempre una batería completa.

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Law & Kelton (1991), Knuth (1997), L'Ecuyer (1999), NIST SP 800-22*


---

<div align="center">

⬅️ [2.1 Generación de Números](2.1.md) &nbsp;&nbsp;|&nbsp;&nbsp; [2.2.1 Uniformidad](2.2.1.md) ➡️

</div>
