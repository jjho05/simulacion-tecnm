# 2.3.2 Aplicaciones del Método de Monte Carlo

El Método de Monte Carlo ha revolucionado campos tan diversos como la física nuclear, las finanzas cuantitativas, la ingeniería de sistemas, la inteligencia artificial y hasta el diseño de videojuegos. En esta sección exploraremos las aplicaciones más relevantes para ingeniería en sistemas computacionales.

---

## Aplicaciones en Finanzas Cuantitativas

### 1. Valoración de Opciones Financieras

**Problema:** Calcular el precio justo de una opción europea (derecho a comprar/vender un activo a un precio fijado en el futuro).

**Modelo Black-Scholes:**

El precio del activo subyacente sigue un movimiento Browniano geométrico:

$$S(T) = S_0 \exp\left[\left(r - \frac{\sigma^2}{2}\right)T + \sigma\sqrt{T}Z\right], \quad Z \sim N(0,1)$$

Donde:
- $S_0$: Precio actual
- $r$: Tasa libre de riesgo
- $\sigma$: Volatilidad
- $T$: Tiempo hasta vencimiento

**Algoritmo Monte Carlo:**

```python
import numpy as np

def precio_opcion_call_mc(S0, K, r, sigma, T, n_sim=100000):
    """
    Calcula el precio de una opción call europea usando Monte Carlo.
    
    Args:
        S0: Precio inicial del activo
        K: Strike (precio de ejercicio)
        r: Tasa libre de riesgo anual
        sigma: Volatilidad anual
        T: Tiempo hasta vencimiento (años)
        n_sim: Número de simulaciones
    
    Returns:
        Precio de la opción y error estándar
    """
    # Simular precios finales del activo
    Z = np.random.standard_normal(n_sim)
    ST = S0 * np.exp((r - 0.5*sigma**2)*T + sigma*np.sqrt(T)*Z)
    
    # Payoff de la opción call: max(ST - K, 0)
    payoffs = np.maximum(ST - K, 0)
    
    # Descontar al presente
    precio = np.exp(-r*T) * np.mean(payoffs)
    
    # Error estándar
    error_std = np.exp(-r*T) * np.std(payoffs) / np.sqrt(n_sim)
    
    return precio, error_std

# Ejemplo: Opción sobre acción de tecnología
S0 = 100      # Precio actual: $100
K = 105       # Strike: $105
r = 0.05      # Tasa libre de riesgo: 5%
sigma = 0.25  # Volatilidad: 25%
T = 1.0       # Vencimiento: 1 año

precio, error = precio_opcion_call_mc(S0, K, r, sigma, T)

print(f"Precio de la opción call: ${precio:.4f} ± ${error:.4f}")
print(f"Intervalo de confianza 95%: [${precio-1.96*error:.4f}, ${precio+1.96*error:.4f}]")

# Comparar con fórmula analítica de Black-Scholes
from scipy.stats import norm

d1 = (np.log(S0/K) + (r + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))
d2 = d1 - sigma*np.sqrt(T)
precio_bs = S0*norm.cdf(d1) - K*np.exp(-r*T)*norm.cdf(d2)

print(f"\nPrecio Black-Scholes (analítico): ${precio_bs:.4f}")
print(f"Error Monte Carlo: ${abs(precio - precio_bs):.4f}")
```

### 2. Opciones Exóticas (Path-Dependent)

Para opciones cuyo valor depende de toda la trayectoria del precio (no solo el precio final), Monte Carlo es **indispensable**.

**Ejemplo: Opción Asiática (promedio)**

```python
def precio_opcion_asiatica_mc(S0, K, r, sigma, T, n_pasos, n_sim):
    """
    Opción asiática: Payoff = max(promedio(S) - K, 0)
    """
    dt = T / n_pasos
    precios_finales = []
    
    for _ in range(n_sim):
        # Simular trayectoria completa
        S = S0
        suma_precios = 0
        
        for _ in range(n_pasos):
            Z = np.random.standard_normal()
            S = S * np.exp((r - 0.5*sigma**2)*dt + sigma*np.sqrt(dt)*Z)
            suma_precios += S
        
        promedio = suma_precios / n_pasos
        payoff = max(promedio - K, 0)
        precios_finales.append(payoff)
    
    precio = np.exp(-r*T) * np.mean(precios_finales)
    return precio

precio_asiatica = precio_opcion_asiatica_mc(100, 105, 0.05, 0.25, 1, n_pasos=252, n_sim=10000)
print(f"Precio opción asiática: ${precio_asiatica:.4f}")
```

### 3. Value at Risk (VaR)

**Problema:** Estimar la pérdida máxima esperada de un portafolio con un nivel de confianza dado.

```python
def calcular_var_mc(portafolio, retornos_esperados, cov_matrix, confianza=0.95, n_sim=100000):
    """
    Calcula el VaR de un portafolio usando Monte Carlo.
    
    Args:
        portafolio: Array de pesos [w1, w2, ..., wn]
        retornos_esperados: Array de retornos esperados
        cov_matrix: Matriz de covarianza de retornos
        confianza: Nivel de confianza (ej. 0.95 para 95%)
        n_sim: Número de simulaciones
    
    Returns:
        VaR (pérdida máxima esperada)
    """
    # Simular retornos del portafolio
    retornos_sim = np.random.multivariate_normal(
        retornos_esperados, 
        cov_matrix, 
        n_sim
    )
    
    # Retorno del portafolio
    retornos_portafolio = retornos_sim @ portafolio
    
    # VaR: percentil (1-confianza)
    var = -np.percentile(retornos_portafolio, (1-confianza)*100)
    
    return var

# Ejemplo: Portafolio de 3 activos
portafolio = np.array([0.5, 0.3, 0.2])  # 50% activo 1, 30% activo 2, 20% activo 3
retornos = np.array([0.08, 0.12, 0.06])  # Retornos esperados anuales
cov = np.array([
    [0.04, 0.01, 0.005],
    [0.01, 0.09, 0.02],
    [0.005, 0.02, 0.03]
])

var_95 = calcular_var_mc(portafolio, retornos, cov, confianza=0.95)
var_99 = calcular_var_mc(portafolio, retornos, cov, confianza=0.99)

print(f"VaR al 95%: {var_95*100:.2f}%")
print(f"VaR al 99%: {var_99*100:.2f}%")
print(f"\nInterpretación: Con 95% de confianza, la pérdida no excederá {var_95*100:.2f}% en un año.")
```

---

## Aplicaciones en Física e Ingeniería

### 1. Transporte de Partículas (Física Nuclear)

**Problema:** Simular el recorrido de neutrones en un reactor nuclear.

**Modelo:** Cada neutrón se mueve en línea recta hasta colisionar, donde puede:
- Ser absorbido (probabilidad $p_a$)
- Dispersarse (probabilidad $p_s$)
- Causar fisión (probabilidad $p_f$)

```python
def simular_neutron(x0, y0, z0, energia_inicial, max_colisiones=100):
    """
    Simula la trayectoria de un neutrón en un reactor.
    """
    x, y, z = x0, y0, z0
    energia = energia_inicial
    colisiones = 0
    
    while energia > 0 and colisiones < max_colisiones:
        # Distancia hasta próxima colisión (distribución exponencial)
        lambd = 0.1  # Sección transversal
        distancia = -np.log(np.random.random()) / lambd
        
        # Dirección aleatoria
        theta = np.random.uniform(0, np.pi)
        phi = np.random.uniform(0, 2*np.pi)
        
        # Nueva posición
        x += distancia * np.sin(theta) * np.cos(phi)
        y += distancia * np.sin(theta) * np.sin(phi)
        z += distancia * np.cos(theta)
        
        # Tipo de colisión
        evento = np.random.random()
        
        if evento < 0.1:  # Absorción
            return 'absorbido', colisiones, (x, y, z)
        elif evento < 0.7:  # Dispersión
            energia *= 0.9  # Pierde energía
            colisiones += 1
        else:  # Fisión
            return 'fision', colisiones, (x, y, z)
    
    return 'escape', colisiones, (x, y, z)

# Simular 1000 neutrones
resultados = {'absorbido': 0, 'fision': 0, 'escape': 0}

for _ in range(1000):
    resultado, _, _ = simular_neutron(0, 0, 0, energia_inicial=2.0)
    resultados[resultado] += 1

print("Resultados de 1000 neutrones:")
for evento, cantidad in resultados.items():
    print(f"  {evento}: {cantidad} ({cantidad/10:.1f}%)")
```

### 2. Análisis de Confiabilidad de Sistemas

**Problema:** Estimar la probabilidad de falla de un sistema complejo con componentes redundantes.

```python
def simular_sistema_redundante(n_sim=100000):
    """
    Sistema con 3 subsistemas en serie, cada uno con componentes redundantes.
    
    Subsistema 1: 2 componentes en paralelo (confiabilidad 0.9 cada uno)
    Subsistema 2: 3 componentes en paralelo (confiabilidad 0.8 cada uno)
    Subsistema 3: 1 componente (confiabilidad 0.95)
    """
    fallas = 0
    
    for _ in range(n_sim):
        # Subsistema 1: Falla si ambos componentes fallan
        comp1_1 = np.random.random() < 0.9
        comp1_2 = np.random.random() < 0.9
        subsistema1_funciona = comp1_1 or comp1_2
        
        # Subsistema 2: Falla si todos los componentes fallan
        comp2_1 = np.random.random() < 0.8
        comp2_2 = np.random.random() < 0.8
        comp2_3 = np.random.random() < 0.8
        subsistema2_funciona = comp2_1 or comp2_2 or comp2_3
        
        # Subsistema 3
        subsistema3_funciona = np.random.random() < 0.95
        
        # Sistema completo: Falla si algún subsistema falla
        sistema_funciona = subsistema1_funciona and subsistema2_funciona and subsistema3_funciona
        
        if not sistema_funciona:
            fallas += 1
    
    confiabilidad = 1 - fallas/n_sim
    return confiabilidad

# Calcular confiabilidad
R = simular_sistema_redundante(100000)
print(f"Confiabilidad del sistema: {R:.4f} ({R*100:.2f}%)")

# Comparar con cálculo analítico
R1 = 1 - (1-0.9)**2  # Subsistema 1
R2 = 1 - (1-0.8)**3  # Subsistema 2
R3 = 0.95            # Subsistema 3
R_analitico = R1 * R2 * R3

print(f"Confiabilidad analítica: {R_analitico:.4f}")
print(f"Error: {abs(R - R_analitico):.4f}")
```

### 3. Simulación de Tráfico de Red

**Problema:** Estimar el tiempo promedio de respuesta en un servidor web con llegadas aleatorias.

```python
def simular_servidor_web(lambd_llegadas, mu_servicio, T_sim, capacidad=float('inf')):
    """
    Simula un servidor web con cola M/M/1.
    
    Args:
        lambd_llegadas: Tasa de llegadas (peticiones/segundo)
        mu_servicio: Tasa de servicio (peticiones/segundo)
        T_sim: Tiempo de simulación (segundos)
        capacidad: Capacidad máxima de la cola
    
    Returns:
        Tiempo promedio de respuesta
    """
    tiempo = 0
    cola = []
    tiempos_respuesta = []
    servidor_ocupado = False
    tiempo_fin_servicio = 0
    
    # Generar eventos
    while tiempo < T_sim:
        # Próxima llegada
        tiempo_llegada = tiempo + np.random.exponential(1/lambd_llegadas)
        
        # Procesar eventos
        if not servidor_ocupado or tiempo_llegada < tiempo_fin_servicio:
            # Llegada
            tiempo = tiempo_llegada
            
            if not servidor_ocupado:
                # Servidor libre, atender inmediatamente
                servidor_ocupado = True
                tiempo_servicio = np.random.exponential(1/mu_servicio)
                tiempo_fin_servicio = tiempo + tiempo_servicio
                tiempos_respuesta.append(tiempo_servicio)
            else:
                # Servidor ocupado, agregar a cola
                if len(cola) < capacidad:
                    cola.append(tiempo)
        else:
            # Fin de servicio
            tiempo = tiempo_fin_servicio
            
            if cola:
                # Atender siguiente en cola
                tiempo_llegada_cliente = cola.pop(0)
                tiempo_espera = tiempo - tiempo_llegada_cliente
                tiempo_servicio = np.random.exponential(1/mu_servicio)
                tiempo_fin_servicio = tiempo + tiempo_servicio
                tiempos_respuesta.append(tiempo_espera + tiempo_servicio)
            else:
                # Servidor queda libre
                servidor_ocupado = False
    
    return np.mean(tiempos_respuesta) if tiempos_respuesta else 0

# Ejemplo: Servidor web
lambd = 8   # 8 peticiones/segundo
mu = 10     # Capacidad de 10 peticiones/segundo

tiempo_respuesta = simular_servidor_web(lambd, mu, T_sim=1000)

print(f"Tiempo promedio de respuesta: {tiempo_respuesta:.4f} segundos")

# Comparar con teoría de colas M/M/1
rho = lambd / mu  # Utilización
W_teorico = 1 / (mu - lambd)  # Tiempo en sistema (Little's Law)

print(f"Tiempo teórico (M/M/1): {W_teorico:.4f} segundos")
print(f"Utilización del servidor: {rho*100:.1f}%")
```

---

## Aplicaciones en Computación Gráfica

### 1. Ray Tracing y Path Tracing

**Problema:** Renderizar imágenes fotorrealistas simulando el comportamiento de la luz.

**Concepto:** Cada píxel se calcula lanzando múltiples rayos aleatorios y promediando el color resultante.

```python
def path_tracing_simple(n_rayos_por_pixel):
    """
    Simulación simplificada de path tracing.
    Calcula el color de un píxel promediando múltiples rayos aleatorios.
    """
    colores = []
    
    for _ in range(n_rayos_por_pixel):
        # Dirección aleatoria del rayo (dentro del hemisferio)
        theta = np.random.uniform(0, np.pi/2)
        phi = np.random.uniform(0, 2*np.pi)
        
        # Simular rebotes del rayo
        intensidad = 1.0
        n_rebotes = 0
        max_rebotes = 5
        
        while intensidad > 0.01 and n_rebotes < max_rebotes:
            # Probabilidad de absorción
            if np.random.random() < 0.2:
                intensidad = 0  # Absorbido
            else:
                intensidad *= 0.7  # Pierde energía en cada rebote
                n_rebotes += 1
        
        colores.append(intensidad)
    
    # Color final: promedio de todos los rayos
    color_final = np.mean(colores)
    return color_final

# Ejemplo: Renderizar un píxel con diferentes calidades
for n_rayos in [1, 10, 100, 1000]:
    color = path_tracing_simple(n_rayos)
    print(f"{n_rayos:>4} rayos: Color = {color:.4f}")
```

### 2. Ambient Occlusion

**Problema:** Calcular cuánta luz ambiental llega a un punto de una superficie.

---

## Aplicaciones en Machine Learning

### 1. Dropout (Regularización en Redes Neuronales)

**Concepto:** Durante el entrenamiento, "apagar" aleatoriamente neuronas con probabilidad $p$ para evitar overfitting.

```python
def forward_pass_con_dropout(x, W, p_dropout=0.5):
    """
    Forward pass de una capa con dropout.
    
    Args:
        x: Input (batch_size, n_features)
        W: Pesos (n_features, n_neurons)
        p_dropout: Probabilidad de apagar neurona
    
    Returns:
        Output con dropout aplicado
    """
    # Activación normal
    z = x @ W
    
    # Máscara de dropout (1 = mantener, 0 = apagar)
    mask = np.random.binomial(1, 1-p_dropout, size=z.shape)
    
    # Aplicar máscara y escalar
    z_dropout = z * mask / (1 - p_dropout)
    
    return z_dropout

# Ejemplo
x = np.random.randn(32, 100)  # Batch de 32 ejemplos, 100 features
W = np.random.randn(100, 50)  # 50 neuronas

z_normal = x @ W
z_dropout = forward_pass_con_dropout(x, W, p_dropout=0.5)

print(f"Activaciones normales: media={np.mean(z_normal):.4f}, std={np.std(z_normal):.4f}")
print(f"Activaciones con dropout: media={np.mean(z_dropout):.4f}, std={np.std(z_dropout):.4f}")
```

### 2. Monte Carlo Tree Search (MCTS)

**Aplicación:** Algoritmo usado en AlphaGo para jugar Go a nivel superhuman.

**Concepto:** Explorar el árbol de decisiones mediante simulaciones aleatorias (playouts).

---

## Aplicaciones en Ingeniería Civil y Mecánica

### 1. Análisis de Incertidumbre en Proyectos

**Problema:** Estimar el tiempo total de un proyecto considerando incertidumbre en cada tarea.

```python
def simular_proyecto_pert(tareas, n_sim=10000):
    """
    Simula un proyecto usando PERT con distribuciones triangulares.
    
    Args:
        tareas: Lista de (optimista, más_probable, pesimista) para cada tarea
        n_sim: Número de simulaciones
    
    Returns:
        Distribución de tiempos totales
    """
    tiempos_totales = []
    
    for _ in range(n_sim):
        tiempo_total = 0
        
        for opt, prob, pes in tareas:
            # Distribución triangular
            tiempo_tarea = np.random.triangular(opt, prob, pes)
            tiempo_total += tiempo_tarea
        
        tiempos_totales.append(tiempo_total)
    
    return np.array(tiempos_totales)

# Ejemplo: Proyecto de software con 5 tareas
tareas = [
    (5, 10, 20),   # Tarea 1: Diseño
    (10, 15, 25),  # Tarea 2: Implementación
    (3, 5, 10),    # Tarea 3: Testing
    (2, 4, 8),     # Tarea 4: Documentación
    (1, 2, 5)      # Tarea 5: Deployment
]

tiempos = simular_proyecto_pert(tareas, n_sim=100000)

print(f"Tiempo esperado: {np.mean(tiempos):.2f} días")
print(f"Desviación estándar: {np.std(tiempos):.2f} días")
print(f"Probabilidad de terminar en ≤40 días: {np.mean(tiempos <= 40)*100:.1f}%")
print(f"Tiempo con 95% de confianza: {np.percentile(tiempos, 95):.2f} días")
```

---

## Ejercicios Prácticos

### Ejercicio 1: Opción Put Europea

Implemente la valoración de una opción put europea (derecho a vender) usando Monte Carlo.

**Payoff:** $\max(K - S_T, 0)$

### Ejercicio 2: Sistema de Inventario Estocástico

Simule un sistema de inventario con:
- Demanda diaria: Poisson(λ=10)
- Lead time: Uniforme[2, 5] días
- Política (s, S): Pedir cuando inventario ≤ s, hasta nivel S

Encuentre los valores óptimos de s y S que minimizan el costo total.

### Ejercicio 3: Simulación de Epidemia (Modelo SIR)

Implemente un modelo SIR (Susceptible-Infected-Recovered) usando Monte Carlo para simular la propagación de una enfermedad.

---

## Casos de Estudio Reales

### Caso 1: Proyecto Manhattan (1940s)

**Aplicación Original:** Simulación de difusión de neutrones en bombas nucleares.

**Impacto:** Permitió diseñar armas nucleares sin necesidad de pruebas físicas extensivas.

### Caso 2: Gestión de Riesgo en JP Morgan (1990s)

**Aplicación:** Cálculo de VaR para portafolios de derivados complejos.

**Impacto:** Revolucionó la gestión de riesgo financiero, ahora estándar en la industria.

### Caso 3: AlphaGo (2016)

**Aplicación:** Monte Carlo Tree Search para jugar Go.

**Impacto:** Primera IA en vencer al campeón mundial de Go.

---

## Resumen y Mejores Prácticas

**Aplicaciones Clave:**
- Finanzas: Opciones, VaR, portafolios
- Física: Transporte de partículas, mecánica cuántica
- Ingeniería: Confiabilidad, proyectos, redes
- Computación Gráfica: Ray tracing, ambient occlusion
- Machine Learning: Dropout, MCTS

**Recomendaciones:**
1. Validar resultados con casos conocidos cuando sea posible
2. Usar técnicas de reducción de varianza para problemas costosos
3. Reportar intervalos de confianza, no solo estimaciones puntuales
4. Documentar todos los supuestos del modelo

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Glasserman (2003), Kroese et al. (2014), Rubinstein & Kroese (2016)*


---

<div align="center">

⬅️ [2.3.1 Características](2.3.1.md) &nbsp;&nbsp;|&nbsp;&nbsp; [2.3.3 Solución Problemas](2.3.3.md) ➡️

</div>
