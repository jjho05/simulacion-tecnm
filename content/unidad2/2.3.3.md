# 2.3.3 Solución de Problemas con Método de Monte Carlo

La verdadera maestría en simulación no está en conocer las fórmulas, sino en saber **plantear, diseñar, implementar y validar** una solución completa a un problema real. Esta sección presenta una metodología sistemática para resolver problemas usando Monte Carlo.

---

## Metodología de Resolución de Problemas

### Fase 1: Comprensión y Formulación del Problema

**Paso 1.1: Identificar el Objetivo**

Definir claramente qué se quiere estimar o calcular.

**Ejemplos:**
- ❌ Mal: "Simular un sistema de inventario"
- ✅ Bien: "Determinar el nivel de reorden óptimo que minimiza el costo total anual"

**Paso 1.2: Identificar Variables Aleatorias**

Listar todas las fuentes de incertidumbre y sus distribuciones.

**Ejemplo: Sistema de Inventario**
- Demanda diaria: $D \sim \text{Poisson}(\lambda=10)$
- Lead time: $L \sim \text{Uniforme}[2, 5]$ días
- Costo de almacenamiento: $h = \$2$/unidad/día (determinístico)
- Costo de faltante: $p = \$50$/unidad (determinístico)

**Paso 1.3: Definir Métricas de Desempeño**

¿Qué vamos a medir?

**Ejemplo:**
- Costo total promedio por semana
- Probabilidad de faltante
- Nivel de servicio (% de demanda satisfecha)

### Fase 2: Diseño del Modelo de Simulación

**Paso 2.1: Diagrama de Flujo**

Crear un diagrama de flujo del proceso a simular.

```
Inicio
  ↓
Generar demanda diaria
  ↓
¿Hay inventario suficiente?
  ├─ Sí → Satisfacer demanda, reducir inventario
  └─ No → Registrar faltante
  ↓
¿Es día de revisión?
  ├─ Sí → Generar orden de compra
  └─ No → Continuar
  ↓
¿Llegó orden anterior?
  ├─ Sí → Incrementar inventario
  └─ No → Continuar
  ↓
Calcular costos del día
  ↓
¿Fin de simulación?
  ├─ No → Volver a generar demanda
  └─ Sí → Calcular estadísticas finales
```

**Paso 2.2: Pseudocódigo**

```python
# Pseudocódigo de simulación de inventario
def simular_inventario(s, S, n_dias):
    inventario = S
    costo_total = 0
    orden_pendiente = None
    
    for dia in range(n_dias):
        # 1. Generar demanda
        demanda = generar_poisson(lambda=10)
        
        # 2. Satisfacer demanda
        if inventario >= demanda:
            inventario -= demanda
            costo_total += h * inventario
        else:
            faltante = demanda - inventario
            inventario = 0
            costo_total += p * faltante
        
        # 3. Revisar política (s, S)
        if inventario <= s and orden_pendiente is None:
            cantidad_orden = S - inventario
            lead_time = generar_uniforme(2, 5)
            orden_pendiente = (cantidad_orden, dia + lead_time)
        
        # 4. Recibir orden
        if orden_pendiente and dia >= orden_pendiente[1]:
            inventario += orden_pendiente[0]
            orden_pendiente = None
    
    return costo_total / n_dias
```

### Fase 3: Implementación

**Paso 3.1: Implementar Generadores de Variables Aleatorias**

```python
import numpy as np

def generar_poisson(lambd):
    """Genera variable Poisson usando método de inversión"""
    L = np.exp(-lambd)
    k = 0
    p = 1
    
    while p > L:
        k += 1
        u = np.random.random()
        p *= u
    
    return k - 1

def generar_uniforme(a, b):
    """Genera variable uniforme en [a, b]"""
    return a + (b - a) * np.random.random()

# Validar generadores
print("Validación de generadores:")
muestras_poisson = [generar_poisson(10) for _ in range(10000)]
print(f"Poisson(10): Media={np.mean(muestras_poisson):.2f}, Var={np.var(muestras_poisson):.2f}")

muestras_uniforme = [generar_uniforme(2, 5) for _ in range(10000)]
print(f"Uniforme[2,5]: Media={np.mean(muestras_uniforme):.2f}, Var={np.var(muestras_uniforme):.2f}")
```

**Paso 3.2: Implementar el Modelo Completo**

```python
class SimuladorInventario:
    def __init__(self, s, S, h, p, lambd_demanda, lead_time_min, lead_time_max):
        self.s = s  # Punto de reorden
        self.S = S  # Nivel máximo
        self.h = h  # Costo de almacenamiento
        self.p = p  # Costo de faltante
        self.lambd_demanda = lambd_demanda
        self.lead_time_min = lead_time_min
        self.lead_time_max = lead_time_max
    
    def simular(self, n_dias):
        """Simula el sistema por n_dias"""
        inventario = self.S
        costo_total = 0
        orden_pendiente = None
        
        # Estadísticas
        faltantes_total = 0
        demanda_total = 0
        
        for dia in range(n_dias):
            # Generar demanda
            demanda = generar_poisson(self.lambd_demanda)
            demanda_total += demanda
            
            # Satisfacer demanda
            if inventario >= demanda:
                inventario -= demanda
                costo_total += self.h * inventario
            else:
                faltante = demanda - inventario
                faltantes_total += faltante
                inventario = 0
                costo_total += self.p * faltante
            
            # Revisar política
            if inventario <= self.s and orden_pendiente is None:
                cantidad_orden = self.S - inventario
                lead_time = generar_uniforme(self.lead_time_min, self.lead_time_max)
                orden_pendiente = {
                    'cantidad': cantidad_orden,
                    'dia_llegada': dia + int(lead_time)
                }
            
            # Recibir orden
            if orden_pendiente and dia >= orden_pendiente['dia_llegada']:
                inventario += orden_pendiente['cantidad']
                orden_pendiente = None
        
        # Calcular métricas
        costo_promedio_dia = costo_total / n_dias
        nivel_servicio = 1 - (faltantes_total / demanda_total)
        
        return {
            'costo_promedio_dia': costo_promedio_dia,
            'nivel_servicio': nivel_servicio,
            'faltantes_total': faltantes_total,
            'demanda_total': demanda_total
        }
    
    def optimizar(self, n_simulaciones=1000, n_dias=365):
        """Encuentra los mejores valores de s y S"""
        mejor_costo = float('inf')
        mejor_s = None
        mejor_S = None
        
        # Búsqueda en grilla
        for s in range(10, 100, 10):
            for S in range(s+20, 150, 10):
                self.s = s
                self.S = S
                
                # Simular múltiples veces
                costos = []
                for _ in range(n_simulaciones):
                    resultado = self.simular(n_dias)
                    costos.append(resultado['costo_promedio_dia'])
                
                costo_promedio = np.mean(costos)
                
                if costo_promedio < mejor_costo:
                    mejor_costo = costo_promedio
                    mejor_s = s
                    mejor_S = S
        
        return mejor_s, mejor_S, mejor_costo

# Ejemplo de uso
sim = SimuladorInventario(
    s=30, S=100,
    h=2, p=50,
    lambd_demanda=10,
    lead_time_min=2, lead_time_max=5
)

resultado = sim.simular(n_dias=365)
print("Resultados de la simulación:")
print(f"  Costo promedio diario: ${resultado['costo_promedio_dia']:.2f}")
print(f"  Nivel de servicio: {resultado['nivel_servicio']*100:.1f}%")
print(f"  Faltantes totales: {resultado['faltantes_total']}")
```

### Fase 4: Validación y Verificación

**Paso 4.1: Validación de Generadores**

Verificar que los generadores de variables aleatorias producen las distribuciones correctas.

```python
def validar_generador_poisson(lambd, n_muestras=10000):
    """Valida generador Poisson con prueba Chi-cuadrada"""
    muestras = [generar_poisson(lambd) for _ in range(n_muestras)]
    
    # Frecuencias observadas
    from collections import Counter
    conteo = Counter(muestras)
    
    # Frecuencias esperadas (usando scipy)
    from scipy.stats import poisson, chisquare
    
    k_max = max(conteo.keys())
    obs = [conteo.get(k, 0) for k in range(k_max+1)]
    esp = [n_muestras * poisson.pmf(k, lambd) for k in range(k_max+1)]
    
    # Chi-cuadrada
    chi2, p_value = chisquare(obs, f_exp=esp)
    
    print(f"Validación Poisson(λ={lambd}):")
    print(f"  Media observada: {np.mean(muestras):.4f} (esperada: {lambd})")
    print(f"  Varianza observada: {np.var(muestras):.4f} (esperada: {lambd})")
    print(f"  Chi²: {chi2:.4f}, p-value: {p_value:.4f}")
    print(f"  Resultado: {'✓ PASA' if p_value > 0.05 else '✗ FALLA'}")

validar_generador_poisson(10)
```

**Paso 4.2: Casos Extremos**

Probar el modelo con casos límite conocidos.

```python
# Caso extremo 1: Demanda = 0 (no debería haber faltantes)
sim_cero = SimuladorInventario(s=30, S=100, h=2, p=50, lambd_demanda=0, lead_time_min=2, lead_time_max=5)
resultado_cero = sim_cero.simular(365)
print(f"Demanda=0: Faltantes={resultado_cero['faltantes_total']} (esperado: 0)")

# Caso extremo 2: Inventario infinito (no debería haber faltantes)
sim_inf = SimuladorInventario(s=0, S=10000, h=2, p=50, lambd_demanda=10, lead_time_min=2, lead_time_max=5)
resultado_inf = sim_inf.simular(365)
print(f"S=10000: Nivel servicio={resultado_inf['nivel_servicio']*100:.1f}% (esperado: ~100%)")
```

**Paso 4.3: Análisis de Sensibilidad**

Estudiar cómo cambian los resultados al variar parámetros.

```python
def analisis_sensibilidad():
    """Analiza sensibilidad del costo a cambios en λ"""
    lambdas = [5, 7, 10, 12, 15]
    costos = []
    
    for lambd in lambdas:
        sim = SimuladorInventario(s=30, S=100, h=2, p=50, lambd_demanda=lambd, lead_time_min=2, lead_time_max=5)
        
        # Múltiples corridas
        costos_lambd = []
        for _ in range(100):
            resultado = sim.simular(365)
            costos_lambd.append(resultado['costo_promedio_dia'])
        
        costos.append(np.mean(costos_lambd))
    
    # Graficar
    import matplotlib.pyplot as plt
    plt.figure(figsize=(10, 6))
    plt.plot(lambdas, costos, 'o-')
    plt.xlabel('Tasa de demanda (λ)')
    plt.ylabel('Costo promedio diario ($)')
    plt.title('Análisis de Sensibilidad')
    plt.grid(True, alpha=0.3)
    plt.show()

analisis_sensibilidad()
```

### Fase 5: Experimentación y Análisis

**Paso 5.1: Diseño de Experimentos**

Definir qué escenarios probar.

**Ejemplo: Comparar 3 políticas**
1. Política conservadora: s=50, S=150
2. Política moderada: s=30, S=100
3. Política agresiva: s=10, S=50

```python
def comparar_politicas(n_simulaciones=1000):
    """Compara diferentes políticas de inventario"""
    politicas = [
        {'nombre': 'Conservadora', 's': 50, 'S': 150},
        {'nombre': 'Moderada', 's': 30, 'S': 100},
        {'nombre': 'Agresiva', 's': 10, 'S': 50}
    ]
    
    resultados = []
    
    for pol in politicas:
        sim = SimuladorInventario(
            s=pol['s'], S=pol['S'],
            h=2, p=50,
            lambd_demanda=10,
            lead_time_min=2, lead_time_max=5
        )
        
        costos = []
        niveles_servicio = []
        
        for _ in range(n_simulaciones):
            res = sim.simular(365)
            costos.append(res['costo_promedio_dia'])
            niveles_servicio.append(res['nivel_servicio'])
        
        resultados.append({
            'nombre': pol['nombre'],
            'costo_promedio': np.mean(costos),
            'costo_std': np.std(costos),
            'nivel_servicio': np.mean(niveles_servicio)
        })
    
    # Mostrar resultados
    print("Comparación de Políticas:")
    print(f"{'Política':<15} {'Costo Promedio':<20} {'Nivel Servicio'}")
    print("-" * 60)
    
    for res in resultados:
        print(f"{res['nombre']:<15} ${res['costo_promedio']:.2f} ± ${res['costo_std']:.2f}    {res['nivel_servicio']*100:.1f}%")

comparar_politicas()
```

**Paso 5.2: Intervalos de Confianza**

Reportar resultados con incertidumbre.

```python
def calcular_intervalo_confianza(muestras, confianza=0.95):
    """Calcula intervalo de confianza para la media"""
    from scipy import stats
    
    media = np.mean(muestras)
    std = np.std(muestras, ddof=1)
    n = len(muestras)
    
    error_std = std / np.sqrt(n)
    t_crit = stats.t.ppf((1 + confianza) / 2, n-1)
    
    ic_inf = media - t_crit * error_std
    ic_sup = media + t_crit * error_std
    
    return media, ic_inf, ic_sup

# Ejemplo
sim = SimuladorInventario(s=30, S=100, h=2, p=50, lambd_demanda=10, lead_time_min=2, lead_time_max=5)
costos = [sim.simular(365)['costo_promedio_dia'] for _ in range(100)]

media, ic_inf, ic_sup = calcular_intervalo_confianza(costos)

print(f"Costo promedio diario: ${media:.2f}")
print(f"IC 95%: [${ic_inf:.2f}, ${ic_sup:.2f}]")
```

---

## Problemas Resueltos Paso a Paso

### Problema 1: Estimación de π usando Método de Buffon

**Enunciado:** Estimar π lanzando agujas sobre un tablero con líneas paralelas.

**Teoría:** Si lanzamos una aguja de longitud $l$ sobre un tablero con líneas separadas por distancia $d$ (con $l \leq d$), la probabilidad de que la aguja cruce una línea es:

$$P = \frac{2l}{\pi d}$$

Por lo tanto: $\pi = \frac{2l}{P \cdot d}$

**Solución:**

```python
def buffon_needle(l, d, n_lanzamientos):
    """
    Estima π usando el método de la aguja de Buffon.
    
    Args:
        l: Longitud de la aguja
        d: Distancia entre líneas (l <= d)
        n_lanzamientos: Número de lanzamientos
    
    Returns:
        Estimación de π
    """
    cruces = 0
    
    for _ in range(n_lanzamientos):
        # Posición del centro de la aguja (distancia a la línea más cercana)
        y = np.random.uniform(0, d/2)
        
        # Ángulo de la aguja
        theta = np.random.uniform(0, np.pi/2)
        
        # Proyección de la aguja
        proyeccion = (l/2) * np.sin(theta)
        
        # ¿Cruza una línea?
        if proyeccion >= y:
            cruces += 1
    
    # Estimar π
    P = cruces / n_lanzamientos
    pi_estimado = (2 * l) / (P * d) if P > 0 else 0
    
    return pi_estimado

# Ejemplo: Aguja de longitud 1, líneas separadas por 2
for n in [100, 1000, 10000, 100000]:
    pi_est = buffon_needle(l=1, d=2, n_lanzamientos=n)
    error = abs(pi_est - np.pi)
    print(f"n={n:>6}: π≈{pi_est:.5f}, Error={error:.5f}")
```

### Problema 2: Integración de Función Compleja

**Enunciado:** Calcular $\int_0^1 \int_0^1 e^{-(x^2+y^2)} \, dx \, dy$

**Solución:**

```python
def integral_2d_mc(f, n_puntos):
    """
    Calcula integral 2D usando Monte Carlo.
    
    Args:
        f: Función f(x, y)
        n_puntos: Número de puntos aleatorios
    
    Returns:
        Estimación de la integral
    """
    suma = 0
    
    for _ in range(n_puntos):
        x = np.random.random()
        y = np.random.random()
        suma += f(x, y)
    
    # Área del dominio (1×1 = 1)
    integral = suma / n_puntos
    
    return integral

# Función a integrar
f = lambda x, y: np.exp(-(x**2 + y**2))

# Calcular con diferentes n
print("Estimación de ∫∫ e^(-(x²+y²)) dx dy:")
for n in [1000, 10000, 100000, 1000000]:
    resultado = integral_2d_mc(f, n)
    print(f"n={n:>7}: {resultado:.6f}")

# Valor aproximado (usando scipy)
from scipy.integrate import dblquad
valor_real, _ = dblquad(f, 0, 1, 0, 1)
print(f"\nValor real (scipy): {valor_real:.6f}")
```

### Problema 3: Simulación de Proyecto con Incertidumbre

**Enunciado:** Un proyecto de software tiene 5 tareas con tiempos inciertos. Estimar la probabilidad de terminar en menos de 40 días.

**Datos:**
- Tarea 1: Triangular(5, 10, 20)
- Tarea 2: Triangular(10, 15, 25)
- Tarea 3: Triangular(3, 5, 10)
- Tarea 4: Triangular(2, 4, 8)
- Tarea 5: Triangular(1, 2, 5)

**Solución:**

```python
def simular_proyecto_completo(tareas, deadline, n_sim):
    """
    Simula proyecto y calcula probabilidad de cumplir deadline.
    
    Args:
        tareas: Lista de (min, mode, max) para cada tarea
        deadline: Fecha límite
        n_sim: Número de simulaciones
    
    Returns:
        Probabilidad de cumplir deadline, estadísticas
    """
    tiempos_totales = []
    
    for _ in range(n_sim):
        tiempo_total = 0
        
        for min_t, mode_t, max_t in tareas:
            tiempo_tarea = np.random.triangular(min_t, mode_t, max_t)
            tiempo_total += tiempo_tarea
        
        tiempos_totales.append(tiempo_total)
    
    tiempos_totales = np.array(tiempos_totales)
    
    # Estadísticas
    prob_cumplir = np.mean(tiempos_totales <= deadline)
    media = np.mean(tiempos_totales)
    std = np.std(tiempos_totales)
    p50 = np.percentile(tiempos_totales, 50)
    p90 = np.percentile(tiempos_totales, 90)
    p95 = np.percentile(tiempos_totales, 95)
    
    return {
        'prob_cumplir_deadline': prob_cumplir,
        'media': media,
        'std': std,
        'p50': p50,
        'p90': p90,
        'p95': p95,
        'tiempos': tiempos_totales
    }

# Datos del problema
tareas = [
    (5, 10, 20),
    (10, 15, 25),
    (3, 5, 10),
    (2, 4, 8),
    (1, 2, 5)
]

resultado = simular_proyecto_completo(tareas, deadline=40, n_sim=100000)

print("Resultados de la Simulación del Proyecto:")
print(f"  Tiempo esperado: {resultado['media']:.2f} días")
print(f"  Desviación estándar: {resultado['std']:.2f} días")
print(f"  Mediana (P50): {resultado['p50']:.2f} días")
print(f"  P90: {resultado['p90']:.2f} días")
print(f"  P95: {resultado['p95']:.2f} días")
print(f"\n  Probabilidad de terminar en ≤40 días: {resultado['prob_cumplir_deadline']*100:.1f}%")

# Visualizar distribución
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
plt.hist(resultado['tiempos'], bins=50, density=True, alpha=0.7, edgecolor='black')
plt.axvline(40, color='r', linestyle='--', linewidth=2, label='Deadline (40 días)')
plt.axvline(resultado['media'], color='g', linestyle='--', linewidth=2, label=f'Media ({resultado["media"]:.1f} días)')
plt.xlabel('Tiempo total (días)')
plt.ylabel('Densidad')
plt.title('Distribución del Tiempo Total del Proyecto')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

## Ejercicios Propuestos

### Ejercicio 1: Sistema de Colas M/M/c

Simule un sistema de colas con:
- Llegadas: Poisson(λ=8 clientes/hora)
- Servicio: Exponencial(μ=3 clientes/hora por servidor)
- c = 3 servidores

Calcule:
1. Tiempo promedio en el sistema
2. Número promedio de clientes en cola
3. Probabilidad de esperar más de 5 minutos

### Ejercicio 2: Simulación de Portafolio de Inversión

Simule un portafolio con:
- 60% acciones (retorno anual 8%, volatilidad 20%)
- 40% bonos (retorno anual 4%, volatilidad 5%)
- Correlación: 0.3

Calcule:
1. Retorno esperado a 10 años
2. VaR al 95%
3. Probabilidad de duplicar el capital

### Ejercicio 3: Optimización de Inventario

Encuentre los valores óptimos de (s, S) que minimizan el costo total para:
- Demanda: Normal(μ=50, σ=10) unidades/día
- Lead time: Constante 7 días
- Costo almacenamiento: $1/unidad/día
- Costo faltante: $20/unidad

---

## Mejores Prácticas y Errores Comunes

### ✅ Mejores Prácticas

1. **Validar siempre los generadores de variables aleatorias**
2. **Usar semillas para reproducibilidad**
3. **Reportar intervalos de confianza, no solo estimaciones puntuales**
4. **Documentar todos los supuestos del modelo**
5. **Realizar análisis de sensibilidad**
6. **Probar casos extremos conocidos**

### ❌ Errores Comunes

1. **No validar el modelo antes de usarlo**
2. **Usar muy pocas simulaciones (n < 1000)**
3. **Ignorar el período de calentamiento (warm-up)**
4. **No verificar la convergencia**
5. **Confundir media con mediana en distribuciones asimétricas**

---

## Resumen y Checklist

**Metodología Completa:**
1. ✅ Formular el problema claramente
2. ✅ Identificar variables aleatorias y sus distribuciones
3. ✅ Diseñar el modelo (diagrama de flujo + pseudocódigo)
4. ✅ Implementar generadores y validarlos
5. ✅ Implementar el modelo completo
6. ✅ Validar con casos extremos
7. ✅ Realizar experimentos y análisis de sensibilidad
8. ✅ Reportar resultados con intervalos de confianza

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Law & Kelton (1991), Banks et al. (2010), Rubinstein & Kroese (2016)*


---

<div align="center">

⬅️ [2.3.2 Aplicaciones](2.3.2.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Inicio Unidad 3](../unidad3/README.md) ➡️

</div>
