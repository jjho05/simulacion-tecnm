# 3.2 Variables aleatorias discretas

Las variables aleatorias discretas son aquellas que toman valores específicos y contables (finitos o infinitos numerables) con probabilidades definidas. Son fundamentales para modelar fenómenos como conteos, decisiones binarias, y eventos que ocurren en cantidades enteras.

---

## Introducción

A diferencia de las variables continuas (que pueden tomar cualquier valor en un intervalo), las variables discretas solo toman valores específicos:

**Ejemplos del mundo real:**
- Número de clientes que llegan a un banco en una hora: $\{0, 1, 2, 3, ...\}$
- Resultado de lanzar un dado: $\{1, 2, 3, 4, 5, 6\}$
- Número de defectos en un lote de producción: $\{0, 1, 2, ..., n\}$
- Éxito/Fracaso de un experimento: $\{0, 1\}$

---

## Función de Masa de Probabilidad (PMF)

Para una variable aleatoria discreta $X$, la **función de masa de probabilidad** (PMF) es:

$$p(x) = P(X = x)$$

**Propiedades:**
1. $p(x) \geq 0$ para todo $x$
2. $\sum_{x} p(x) = 1$ (suma sobre todos los valores posibles)

**Función de Distribución Acumulada (CDF):**

$$F(x) = P(X \leq x) = \sum_{t \leq x} p(t)$$

---

## Distribuciones Discretas Comunes

### 1. Distribución Uniforme Discreta

**Definición:** Todos los valores tienen la misma probabilidad.

**PMF:**
$$P(X = x_i) = \frac{1}{n}, \quad i = 1, 2, ..., n$$

**Parámetros:**
- $n$: Número de valores posibles

**Media y Varianza:**
$$E[X] = \frac{1 + n}{2}, \quad \text{Var}(X) = \frac{n^2 - 1}{12}$$

**Ejemplo: Lanzamiento de dado justo**

```python
import numpy as np
import matplotlib.pyplot as plt

# Dado justo (n=6)
n = 6
x = np.arange(1, n+1)
p = np.ones(n) / n

# Visualizar PMF
plt.figure(figsize=(10, 6))
plt.stem(x, p, basefmt=' ')
plt.xlabel('Valor (x)')
plt.ylabel('Probabilidad P(X=x)')
plt.title('PMF: Dado Justo (Uniforme Discreta)')
plt.xticks(x)
plt.ylim(0, 0.25)
plt.grid(True, alpha=0.3)
plt.show()

# Estadísticos
media = (1 + n) / 2
varianza = (n**2 - 1) / 12
print(f"Media: {media:.2f}")
print(f"Varianza: {varianza:.2f}")
```

**Generación:**

$$X = \lceil n \cdot R \rceil$$

Donde $R \sim U[0,1]$ y $\lceil \cdot \rceil$ es la función techo (redondeo hacia arriba).

```python
def generar_uniforme_discreta(n, size=1):
    """Genera variables uniformes discretas en {1, 2, ..., n}"""
    R = np.random.random(size)
    return np.ceil(n * R).astype(int)

# Ejemplo: Simular 10,000 lanzamientos de dado
lanzamientos = generar_uniforme_discreta(n=6, size=10000)

# Verificar
print("Frecuencias observadas:")
for i in range(1, 7):
    freq = np.sum(lanzamientos == i) / 10000
    print(f"  {i}: {freq:.4f} (esperado: 0.1667)")
```

---

### 2. Distribución de Bernoulli

**Definición:** Experimento con dos resultados posibles (éxito/fracaso).

**PMF:**
$$P(X = 1) = p, \quad P(X = 0) = 1-p$$

**Parámetros:**
- $p$: Probabilidad de éxito ($0 \leq p \leq 1$)

**Media y Varianza:**
$$E[X] = p, \quad \text{Var}(X) = p(1-p)$$

**Ejemplo: Lanzamiento de moneda sesgada**

```python
# Moneda con p=0.7 de cara
p = 0.7
x = [0, 1]
pmf = [1-p, p]

plt.figure(figsize=(10, 6))
plt.stem(x, pmf, basefmt=' ')
plt.xlabel('Valor (x)')
plt.ylabel('Probabilidad P(X=x)')
plt.title(f'PMF: Bernoulli(p={p})')
plt.xticks(x, ['Fracaso (0)', 'Éxito (1)'])
plt.ylim(0, 1)
plt.grid(True, alpha=0.3)
plt.show()
```

**Generación:**

```python
def generar_bernoulli(p, size=1):
    """Genera variables Bernoulli con probabilidad p"""
    R = np.random.random(size)
    return (R <= p).astype(int)

# Ejemplo
p = 0.7
muestras = generar_bernoulli(p, size=10000)

print(f"Probabilidad de éxito (p): {p}")
print(f"Proporción de éxitos simulada: {np.mean(muestras):.4f}")
```

---

### 3. Distribución Binomial

**Definición:** Número de éxitos en $n$ ensayos Bernoulli independientes.

**PMF:**
$$P(X = k) = \binom{n}{k} p^k (1-p)^{n-k}, \quad k = 0, 1, ..., n$$

**Parámetros:**
- $n$: Número de ensayos
- $p$: Probabilidad de éxito en cada ensayo

**Media y Varianza:**
$$E[X] = np, \quad \text{Var}(X) = np(1-p)$$

**Ejemplo: Control de calidad**

Una fábrica produce componentes con 10% de defectos. Si se inspeccionan 20 componentes, ¿cuál es la probabilidad de encontrar exactamente 3 defectuosos?

```python
from scipy.stats import binom

n, p = 20, 0.10
k = 3

# Calcular P(X = 3)
prob = binom.pmf(k, n, p)
print(f"P(X = 3) = {prob:.4f}")

# Visualizar PMF completa
x = np.arange(0, n+1)
pmf = binom.pmf(x, n, p)

plt.figure(figsize=(12, 6))
plt.stem(x, pmf, basefmt=' ')
plt.xlabel('Número de defectos (k)')
plt.ylabel('Probabilidad P(X=k)')
plt.title(f'PMF: Binomial(n={n}, p={p})')
plt.grid(True, alpha=0.3)
plt.show()
```

**Generación (Método de Convolución):**

Sumar $n$ variables Bernoulli independientes:

$$X = \sum_{i=1}^{n} B_i, \quad B_i \sim \text{Bernoulli}(p)$$

```python
def generar_binomial(n, p, size=1):
    """Genera variables Binomial sumando Bernoulli"""
    resultados = []
    
    for _ in range(size):
        # Sumar n ensayos Bernoulli
        exitos = 0
        for _ in range(n):
            R = np.random.random()
            if R <= p:
                exitos += 1
        resultados.append(exitos)
    
    return np.array(resultados)

# Ejemplo
muestras_bin = generar_binomial(n=20, p=0.10, size=10000)

print(f"Media teórica: {20*0.10:.2f}")
print(f"Media simulada: {np.mean(muestras_bin):.2f}")
print(f"Varianza teórica: {20*0.10*0.90:.2f}")
print(f"Varianza simulada: {np.var(muestras_bin):.2f}")
```

---

### 4. Distribución Geométrica

**Definición:** Número de ensayos hasta obtener el primer éxito.

**PMF:**
$$P(X = k) = (1-p)^{k-1} p, \quad k = 1, 2, 3, ...$$

**Parámetros:**
- $p$: Probabilidad de éxito en cada ensayo

**Media y Varianza:**
$$E[X] = \frac{1}{p}, \quad \text{Var}(X) = \frac{1-p}{p^2}$$

**Ejemplo: Llamadas de ventas**

Un vendedor tiene 20% de probabilidad de cerrar una venta en cada llamada. ¿Cuántas llamadas espera hacer hasta cerrar la primera venta?

```python
from scipy.stats import geom

p = 0.20

# Media (número esperado de llamadas)
media = 1 / p
print(f"Número esperado de llamadas: {media:.2f}")

# PMF
x = np.arange(1, 21)
pmf = geom.pmf(x, p)

plt.figure(figsize=(12, 6))
plt.stem(x, pmf, basefmt=' ')
plt.xlabel('Número de ensayos (k)')
plt.ylabel('Probabilidad P(X=k)')
plt.title(f'PMF: Geométrica(p={p})')
plt.grid(True, alpha=0.3)
plt.show()
```

**Generación:**

$$X = \left\lceil \frac{\ln(R)}{\ln(1-p)} \right\rceil$$

```python
def generar_geometrica(p, size=1):
    """Genera variables Geométricas"""
    R = np.random.random(size)
    return np.ceil(np.log(R) / np.log(1 - p)).astype(int)

# Ejemplo
muestras_geom = generar_geometrica(p=0.20, size=10000)

print(f"Media teórica: {1/0.20:.2f}")
print(f"Media simulada: {np.mean(muestras_geom):.2f}")
```

---

### 5. Distribución de Poisson

**Definición:** Número de eventos que ocurren en un intervalo fijo de tiempo o espacio.

**PMF:**
$$P(X = k) = \frac{\lambda^k e^{-\lambda}}{k!}, \quad k = 0, 1, 2, ...$$

**Parámetros:**
- $\lambda$: Tasa promedio de eventos por intervalo ($\lambda > 0$)

**Media y Varianza:**
$$E[X] = \lambda, \quad \text{Var}(X) = \lambda$$

**Ejemplo: Llegadas a un servidor web**

Un servidor web recibe en promedio 5 peticiones por minuto. ¿Cuál es la probabilidad de recibir exactamente 3 peticiones en un minuto?

```python
from scipy.stats import poisson

lambd = 5
k = 3

# Calcular P(X = 3)
prob = poisson.pmf(k, lambd)
print(f"P(X = 3) = {prob:.4f}")

# PMF completa
x = np.arange(0, 16)
pmf = poisson.pmf(x, lambd)

plt.figure(figsize=(12, 6))
plt.stem(x, pmf, basefmt=' ')
plt.xlabel('Número de eventos (k)')
plt.ylabel('Probabilidad P(X=k)')
plt.title(f'PMF: Poisson(λ={lambd})')
plt.grid(True, alpha=0.3)
plt.show()
```

**Generación (Método de Knuth):**

Basado en la relación entre Poisson y Exponencial:

```python
def generar_poisson(lambd, size=1):
    """
    Genera variables Poisson usando el algoritmo de Knuth.
    Basado en: tiempo entre eventos ~ Exp(lambda)
    """
    resultados = []
    
    for _ in range(size):
        L = np.exp(-lambd)
        k = 0
        p = 1
        
        while p > L:
            k += 1
            u = np.random.random()
            p *= u
        
        resultados.append(k - 1)
    
    return np.array(resultados)

# Ejemplo
muestras_poisson = generar_poisson(lambd=5, size=10000)

print(f"Media teórica: {5:.2f}")
print(f"Media simulada: {np.mean(muestras_poisson):.2f}")
print(f"Varianza teórica: {5:.2f}")
print(f"Varianza simulada: {np.var(muestras_poisson):.2f}")

# Histograma
plt.figure(figsize=(12, 6))
plt.hist(muestras_poisson, bins=range(0, 16), density=True, alpha=0.7, edgecolor='black', label='Simulado')

# Superponer PMF teórica
x_teo = np.arange(0, 16)
pmf_teo = poisson.pmf(x_teo, 5)
plt.plot(x_teo, pmf_teo, 'ro-', linewidth=2, markersize=8, label='Teórico')

plt.xlabel('Valor (k)')
plt.ylabel('Probabilidad')
plt.title('Generación de Variables Poisson(λ=5)')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

## Tabla Comparativa de Distribuciones Discretas

| Distribución | Parámetros | Rango | Media | Varianza | Uso Típico |
|--------------|------------|-------|-------|----------|------------|
| **Uniforme Discreta** | $n$ | $\{1, ..., n\}$ | $\frac{n+1}{2}$ | $\frac{n^2-1}{12}$ | Dados, sorteos |
| **Bernoulli** | $p$ | $\{0, 1\}$ | $p$ | $p(1-p)$ | Éxito/Fracaso |
| **Binomial** | $n, p$ | $\{0, ..., n\}$ | $np$ | $np(1-p)$ | Conteo de éxitos |
| **Geométrica** | $p$ | $\{1, 2, ...\}$ | $\frac{1}{p}$ | $\frac{1-p}{p^2}$ | Tiempo hasta éxito |
| **Poisson** | $\lambda$ | $\{0, 1, 2, ...\}$ | $\lambda$ | $\lambda$ | Conteo de eventos |

---

## Ejercicios Prácticos

### Ejercicio 1: Control de Calidad

Una fábrica produce tornillos con 5% de defectos. Si se inspeccionan 50 tornillos:

1. ¿Cuál es la probabilidad de encontrar exactamente 2 defectuosos?
2. ¿Cuál es la probabilidad de encontrar al menos 3 defectuosos?
3. Simule 10,000 inspecciones y compare con los valores teóricos.

**Solución:**

```python
n, p = 50, 0.05

# 1. P(X = 2)
p1 = binom.pmf(2, n, p)
print(f"P(X = 2) = {p1:.4f}")

# 2. P(X >= 3) = 1 - P(X <= 2)
p2 = 1 - binom.cdf(2, n, p)
print(f"P(X ≥ 3) = {p2:.4f}")

# 3. Simulación
muestras = generar_binomial(n, p, size=10000)

print(f"\nSimulación:")
print(f"P(X = 2) simulado: {np.sum(muestras == 2)/10000:.4f}")
print(f"P(X ≥ 3) simulado: {np.sum(muestras >= 3)/10000:.4f}")
```

### Ejercicio 2: Centro de Llamadas

Un centro de llamadas recibe en promedio 12 llamadas por hora.

1. ¿Cuál es la probabilidad de recibir exactamente 10 llamadas en una hora?
2. ¿Cuál es la probabilidad de recibir más de 15 llamadas?
3. Genere 1,000 horas simuladas y grafique la distribución.

**Solución:**

```python
lambd = 12

# 1. P(X = 10)
p1 = poisson.pmf(10, lambd)
print(f"P(X = 10) = {p1:.4f}")

# 2. P(X > 15)
p2 = 1 - poisson.cdf(15, lambd)
print(f"P(X > 15) = {p2:.4f}")

# 3. Simulación
horas_simuladas = generar_poisson(lambd, size=1000)

plt.figure(figsize=(12, 6))
plt.hist(horas_simuladas, bins=range(0, 25), density=True, alpha=0.7, edgecolor='black')

x_teo = np.arange(0, 25)
pmf_teo = poisson.pmf(x_teo, lambd)
plt.plot(x_teo, pmf_teo, 'ro-', linewidth=2, label='Teórico')

plt.xlabel('Llamadas por hora')
plt.ylabel('Probabilidad')
plt.title('Distribución de Llamadas (Poisson λ=12)')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

## Casos de Estudio

### Caso 1: Sistema de Inventario

**Problema:** Una tienda vende un producto con demanda diaria que sigue una distribución Poisson con $\lambda = 8$ unidades/día. El costo de almacenamiento es $2/unidad/día y el costo de faltante es $20/unidad.

**Pregunta:** ¿Cuántas unidades debe tener en stock al inicio del día para minimizar el costo esperado?

```python
def simular_inventario_poisson(stock_inicial, lambd, costo_almacen, costo_faltante, n_dias):
    """Simula sistema de inventario con demanda Poisson"""
    costos_totales = []
    
    for _ in range(n_dias):
        demanda = generar_poisson(lambd, size=1)[0]
        
        if demanda <= stock_inicial:
            # Satisface demanda, paga almacenamiento
            sobrante = stock_inicial - demanda
            costo = costo_almacen * sobrante
        else:
            # Faltante
            faltante = demanda - stock_inicial
            costo = costo_faltante * faltante
        
        costos_totales.append(costo)
    
    return np.mean(costos_totales)

# Probar diferentes niveles de stock
stocks = range(5, 20)
costos = []

for s in stocks:
    costo_promedio = simular_inventario_poisson(s, lambd=8, costo_almacen=2, costo_faltante=20, n_dias=10000)
    costos.append(costo_promedio)

# Encontrar óptimo
stock_optimo = stocks[np.argmin(costos)]
costo_minimo = min(costos)

print(f"Stock óptimo: {stock_optimo} unidades")
print(f"Costo promedio mínimo: ${costo_minimo:.2f}/día")

# Graficar
plt.figure(figsize=(12, 6))
plt.plot(stocks, costos, 'o-', linewidth=2)
plt.axvline(stock_optimo, color='r', linestyle='--', label=f'Óptimo: {stock_optimo}')
plt.xlabel('Stock inicial (unidades)')
plt.ylabel('Costo promedio diario ($)')
plt.title('Optimización de Inventario con Demanda Poisson')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

## Errores Comunes

### Error 1: Confundir Binomial con Poisson

❌ **Incorrecto:** Usar Binomial cuando $n$ es muy grande y $p$ muy pequeño

✅ **Correcto:** Usar aproximación de Poisson cuando $n \geq 20$ y $p \leq 0.05$

**Regla:** Si $n \to \infty$ y $p \to 0$ tal que $np = \lambda$ (constante), entonces:
$$\text{Binomial}(n, p) \approx \text{Poisson}(\lambda)$$

### Error 2: Asumir que Geométrica empieza en 0

❌ **Incorrecto:** $X \in \{0, 1, 2, ...\}$

✅ **Correcto:** $X \in \{1, 2, 3, ...\}$ (número de ensayos hasta el primer éxito)

### Error 3: No Validar las Variables Generadas

❌ **Incorrecto:** Generar y usar sin verificar

✅ **Correcto:** Siempre comparar media y varianza simuladas con teóricas

---

## Resumen y Conceptos Clave

**Distribuciones Discretas Fundamentales:**
- **Uniforme Discreta:** Todos los valores equiprobables
- **Bernoulli:** Éxito/Fracaso (base de otras distribuciones)
- **Binomial:** Conteo de éxitos en $n$ ensayos
- **Geométrica:** Ensayos hasta primer éxito
- **Poisson:** Conteo de eventos en intervalo fijo

**Métodos de Generación:**
- Transformación directa (Uniforme, Bernoulli, Geométrica)
- Convolución (Binomial = suma de Bernoulli)
- Algoritmo de Knuth (Poisson)

**Validación:**
Siempre verificar media y varianza simuladas vs teóricas

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Ross (2014), Law & Kelton (1991), Devroye (1986)*


---

<div align="center">

⬅️ [3.1 Conceptos VA](3.1.md) &nbsp;&nbsp;|&nbsp;&nbsp; [3.3 VA Continuas](3.3.md) ➡️

</div>
