# 3.3 Variables aleatorias continuas

Las variables aleatorias continuas pueden tomar cualquier valor en un intervalo (o en toda la recta real). A diferencia de las discretas, su probabilidad puntual es cero, y trabajamos con densidades de probabilidad e integrales.

---

## Introducción

Las variables continuas modelan fenómenos que pueden medirse con precisión arbitraria:

**Ejemplos del mundo real:**
- Tiempo entre llegadas de clientes: $[0, \infty)$
- Temperatura ambiente: $(-\infty, \infty)$
- Peso de un producto: $[0, \infty)$
- Tiempo de vida de un componente: $[0, \infty)$

**Diferencia clave con discretas:**
- Discretas: $P(X = x) > 0$ (probabilidad puntual)
- Continuas: $P(X = x) = 0$ (probabilidad puntual es cero)

Para continuas, calculamos probabilidades sobre intervalos:
$$P(a \leq X \leq b) = \int_a^b f(x)dx$$

---

## Función de Densidad de Probabilidad (PDF)

Para una variable aleatoria continua $X$, la **función de densidad de probabilidad** (PDF) $f(x)$ cumple:

**Propiedades:**
1. $f(x) \geq 0$ para todo $x$
2. $\int_{-\infty}^{\infty} f(x)dx = 1$
3. $P(a \leq X \leq b) = \int_a^b f(x)dx$

**Función de Distribución Acumulada (CDF):**
$$F(x) = P(X \leq x) = \int_{-\infty}^{x} f(t)dt$$

**Relación inversa:**
$$f(x) = \frac{dF(x)}{dx}$$

---

## Distribuciones Continuas Fundamentales

### 1. Distribución Uniforme Continua

**Definición:** Todos los valores en el intervalo $[a,b]$ son igualmente probables.

**PDF:**
$$f(x) = \begin{cases}
\frac{1}{b-a} & \text{si } a \leq x \leq b \\
0 & \text{en otro caso}
\end{cases}$$

**CDF:**
$$F(x) = \begin{cases}
0 & \text{si } x < a \\
\frac{x-a}{b-a} & \text{si } a \leq x \leq b \\
1 & \text{si } x > b
\end{cases}$$

**Parámetros:**
- $a$: Límite inferior
- $b$: Límite superior

**Media y Varianza:**
$$E[X] = \frac{a+b}{2}, \quad \text{Var}(X) = \frac{(b-a)^2}{12}$$

**Generación:**
$$X = a + (b-a)R, \quad R \sim U[0,1]$$

```python
import numpy as np
import matplotlib.pyplot as plt

def generar_uniforme_continua(a, b, size=1):
    """Genera variables uniformes continuas en [a, b]"""
    R = np.random.random(size)
    return a + (b - a) * R

# Ejemplo: Tiempo de espera entre 2 y 8 minutos
a, b = 2, 8
muestras = generar_uniforme_continua(a, b, size=10000)

# Verificar
print(f"Media teórica: {(a+b)/2:.2f}, Simulada: {np.mean(muestras):.2f}")
print(f"Varianza teórica: {(b-a)**2/12:.2f}, Simulada: {np.var(muestras):.2f}")

# Visualizar
plt.figure(figsize=(12, 5))

# PDF
plt.subplot(1, 2, 1)
x = np.linspace(0, 10, 1000)
pdf = np.where((x >= a) & (x <= b), 1/(b-a), 0)
plt.plot(x, pdf, linewidth=2)
plt.fill_between(x, pdf, alpha=0.3)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('PDF: Uniforme[2, 8]')
plt.grid(True, alpha=0.3)

# Histograma
plt.subplot(1, 2, 2)
plt.hist(muestras, bins=50, density=True, alpha=0.7, edgecolor='black')
plt.axhline(y=1/(b-a), color='r', linestyle='--', linewidth=2, label='Teórico')
plt.xlabel('x')
plt.ylabel('Densidad')
plt.title('Muestras Generadas')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

---

### 2. Distribución Exponencial

**Definición:** Modela tiempos entre eventos en un proceso de Poisson (llegadas, fallas, etc.).

**PDF:**
$$f(x) = \lambda e^{-\lambda x}, \quad x \geq 0$$

**CDF:**
$$F(x) = 1 - e^{-\lambda x}, \quad x \geq 0$$

**Parámetros:**
- $\lambda$: Tasa de eventos por unidad de tiempo ($\lambda > 0$)

**Media y Varianza:**
$$E[X] = \frac{1}{\lambda}, \quad \text{Var}(X) = \frac{1}{\lambda^2}$$

**Propiedad de falta de memoria:**
$$P(X > s+t | X > s) = P(X > t)$$

**Generación (Transformada Inversa):**

De $F(x) = 1 - e^{-\lambda x}$, despejando:
$$R = 1 - e^{-\lambda X} \implies X = -\frac{1}{\lambda}\ln(1-R)$$

Como $1-R \sim U[0,1]$ también:
$$X = -\frac{1}{\lambda}\ln(R)$$

```python
def generar_exponencial(lambd, size=1):
    """Genera variables exponenciales con tasa lambda"""
    R = np.random.random(size)
    return -np.log(R) / lambd

# Ejemplo: Tiempo entre llegadas (λ=3 clientes/hora)
lambd = 3
muestras_exp = generar_exponencial(lambd, size=10000)

# Verificar
print(f"Media teórica: {1/lambd:.4f}, Simulada: {np.mean(muestras_exp):.4f}")
print(f"Varianza teórica: {1/lambd**2:.4f}, Simulada: {np.var(muestras_exp):.4f}")

# Visualizar
from scipy.stats import expon

plt.figure(figsize=(12, 5))

# PDF teórica
x = np.linspace(0, 3, 1000)
pdf_teorica = lambd * np.exp(-lambd * x)

plt.subplot(1, 2, 1)
plt.plot(x, pdf_teorica, linewidth=2, label='PDF teórica')
plt.fill_between(x, pdf_teorica, alpha=0.3)
plt.xlabel('x (horas)')
plt.ylabel('f(x)')
plt.title('PDF: Exponencial(λ=3)')
plt.legend()
plt.grid(True, alpha=0.3)

# Histograma
plt.subplot(1, 2, 2)
plt.hist(muestras_exp, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado')
plt.plot(x, pdf_teorica, 'r-', linewidth=2, label='Teórico')
plt.xlabel('x (horas)')
plt.ylabel('Densidad')
plt.title('Muestras Generadas')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

---

### 3. Distribución Normal (Gaussiana)

**Definición:** La distribución más importante en estadística. Describe muchos fenómenos naturales y es la base del Teorema del Límite Central.

**PDF:**
$$f(x) = \frac{1}{\sigma\sqrt{2\pi}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}, \quad -\infty < x < \infty$$

**Parámetros:**
- $\mu$: Media (centro de la distribución)
- $\sigma$: Desviación estándar (dispersión)

**Media y Varianza:**
$$E[X] = \mu, \quad \text{Var}(X) = \sigma^2$$

**Regla 68-95-99.7:**
- 68% de los datos caen en $[\mu - \sigma, \mu + \sigma]$
- 95% en $[\mu - 2\sigma, \mu + 2\sigma]$
- 99.7% en $[\mu - 3\sigma, \mu + 3\sigma]$

**Generación (Método Box-Muller):**

Dados $R_1, R_2 \sim U[0,1]$ independientes:

$$Z_1 = \sqrt{-2\ln(R_1)}\cos(2\pi R_2)$$
$$Z_2 = \sqrt{-2\ln(R_1)}\sin(2\pi R_2)$$

Donde $Z_1, Z_2 \sim N(0,1)$ independientes.

Para generar $X \sim N(\mu, \sigma^2)$:
$$X = \mu + \sigma Z_1$$

```python
def generar_normal_box_muller(mu, sigma, size=1):
    """Genera variables normales usando Box-Muller"""
    # Generar pares
    n_pares = (size + 1) // 2
    
    R1 = np.random.random(n_pares)
    R2 = np.random.random(n_pares)
    
    Z1 = np.sqrt(-2 * np.log(R1)) * np.cos(2 * np.pi * R2)
    Z2 = np.sqrt(-2 * np.log(R1)) * np.sin(2 * np.pi * R2)
    
    # Combinar y transformar
    Z = np.concatenate([Z1, Z2])[:size]
    X = mu + sigma * Z
    
    return X

# Ejemplo: Alturas de personas (μ=170 cm, σ=10 cm)
mu, sigma = 170, 10
muestras_norm = generar_normal_box_muller(mu, sigma, size=10000)

# Verificar
print(f"Media teórica: {mu:.2f}, Simulada: {np.mean(muestras_norm):.2f}")
print(f"Desv.Est. teórica: {sigma:.2f}, Simulada: {np.std(muestras_norm):.2f}")

# Visualizar
from scipy.stats import norm

plt.figure(figsize=(12, 5))

# PDF teórica
x = np.linspace(mu - 4*sigma, mu + 4*sigma, 1000)
pdf_teorica = norm.pdf(x, mu, sigma)

plt.subplot(1, 2, 1)
plt.plot(x, pdf_teorica, linewidth=2)
plt.fill_between(x, pdf_teorica, alpha=0.3)
plt.axvline(mu, color='r', linestyle='--', label=f'μ={mu}')
plt.axvline(mu-sigma, color='g', linestyle='--', alpha=0.5, label=f'μ±σ')
plt.axvline(mu+sigma, color='g', linestyle='--', alpha=0.5)
plt.xlabel('x (cm)')
plt.ylabel('f(x)')
plt.title('PDF: Normal(μ=170, σ=10)')
plt.legend()
plt.grid(True, alpha=0.3)

# Histograma
plt.subplot(1, 2, 2)
plt.hist(muestras_norm, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado')
plt.plot(x, pdf_teorica, 'r-', linewidth=2, label='Teórico')
plt.xlabel('x (cm)')
plt.ylabel('Densidad')
plt.title('Muestras Generadas')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

---

### 4. Distribución Triangular

**Definición:** Útil cuando solo se conocen tres valores: mínimo ($a$), más probable ($c$), y máximo ($b$).

**PDF:**
$$f(x) = \begin{cases}
\frac{2(x-a)}{(b-a)(c-a)} & \text{si } a \leq x \leq c \\
\frac{2(b-x)}{(b-a)(b-c)} & \text{si } c < x \leq b \\
0 & \text{en otro caso}
\end{cases}$$

**Parámetros:**
- $a$: Mínimo
- $c$: Moda (valor más probable)
- $b$: Máximo

**Media y Varianza:**
$$E[X] = \frac{a+b+c}{3}, \quad \text{Var}(X) = \frac{a^2+b^2+c^2-ab-ac-bc}{18}$$

**Generación:**

```python
def generar_triangular(a, c, b, size=1):
    """Genera variables triangulares"""
    R = np.random.random(size)
    
    F_c = (c - a) / (b - a)  # CDF en el modo
    
    X = np.where(
        R < F_c,
        a + np.sqrt(R * (b - a) * (c - a)),  # Rama ascendente
        b - np.sqrt((1 - R) * (b - a) * (b - c))  # Rama descendente
    )
    
    return X

# Ejemplo: Tiempo de proyecto (optimista=10, probable=15, pesimista=25 días)
a, c, b = 10, 15, 25
muestras_tri = generar_triangular(a, c, b, size=10000)

# Verificar
media_teo = (a + b + c) / 3
print(f"Media teórica: {media_teo:.2f}, Simulada: {np.mean(muestras_tri):.2f}")

# Visualizar
plt.figure(figsize=(12, 5))

# PDF teórica
x1 = np.linspace(a, c, 500)
x2 = np.linspace(c, b, 500)
pdf1 = 2*(x1-a) / ((b-a)*(c-a))
pdf2 = 2*(b-x2) / ((b-a)*(b-c))

plt.subplot(1, 2, 1)
plt.plot(x1, pdf1, 'b-', linewidth=2)
plt.plot(x2, pdf2, 'b-', linewidth=2)
plt.fill_between(x1, pdf1, alpha=0.3)
plt.fill_between(x2, pdf2, alpha=0.3)
plt.axvline(c, color='r', linestyle='--', label=f'Moda={c}')
plt.xlabel('x (días)')
plt.ylabel('f(x)')
plt.title('PDF: Triangular(10, 15, 25)')
plt.legend()
plt.grid(True, alpha=0.3)

# Histograma
plt.subplot(1, 2, 2)
plt.hist(muestras_tri, bins=50, density=True, alpha=0.7, edgecolor='black')
plt.axvline(media_teo, color='g', linestyle='--', linewidth=2, label=f'Media={media_teo:.1f}')
plt.xlabel('x (días)')
plt.ylabel('Densidad')
plt.title('Muestras Generadas')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

---

### 5. Distribución Weibull

**Definición:** Modela tiempos de vida y confiabilidad. Muy flexible (puede modelar fallas tempranas, aleatorias, o por desgaste).

**PDF:**
$$f(x) = \frac{\beta}{\alpha}\left(\frac{x}{\alpha}\right)^{\beta-1}e^{-(x/\alpha)^\beta}, \quad x \geq 0$$

**CDF:**
$$F(x) = 1 - e^{-(x/\alpha)^\beta}$$

**Parámetros:**
- $\alpha > 0$: Parámetro de escala
- $\beta > 0$: Parámetro de forma
  - $\beta < 1$: Tasa de falla decreciente (fallas tempranas)
  - $\beta = 1$: Tasa de falla constante (equivale a Exponencial)
  - $\beta > 1$: Tasa de falla creciente (desgaste)

**Generación (Transformada Inversa):**

$$X = \alpha(-\ln(R))^{1/\beta}$$

```python
def generar_weibull(alpha, beta, size=1):
    """Genera variables Weibull"""
    R = np.random.random(size)
    return alpha * (-np.log(R))**(1/beta)

# Ejemplo: Tiempo de vida de componente (α=1000 horas, β=2)
alpha, beta = 1000, 2
muestras_weib = generar_weibull(alpha, beta, size=10000)

# Verificar
from scipy.stats import weibull_min
dist_teo = weibull_min(c=beta, scale=alpha)
print(f"Media teórica: {dist_teo.mean():.2f}, Simulada: {np.mean(muestras_weib):.2f}")

# Visualizar
plt.figure(figsize=(12, 5))

# PDF teórica
x = np.linspace(0, 3000, 1000)
pdf_teorica = dist_teo.pdf(x)

plt.subplot(1, 2, 1)
plt.plot(x, pdf_teorica, linewidth=2)
plt.fill_between(x, pdf_teorica, alpha=0.3)
plt.xlabel('x (horas)')
plt.ylabel('f(x)')
plt.title(f'PDF: Weibull(α={alpha}, β={beta})')
plt.grid(True, alpha=0.3)

# Histograma
plt.subplot(1, 2, 2)
plt.hist(muestras_weib, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado')
plt.plot(x, pdf_teorica, 'r-', linewidth=2, label='Teórico')
plt.xlabel('x (horas)')
plt.ylabel('Densidad')
plt.title('Muestras Generadas')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

---

### 6. Distribución Lognormal

**Definición:** Variable cuyo logaritmo sigue una distribución normal.

**Relación:**
Si $Y \sim N(\mu, \sigma^2)$, entonces $X = e^Y \sim \text{Lognormal}(\mu, \sigma^2)$

**Parámetros:**
- $\mu$: Media del logaritmo
- $\sigma$: Desviación estándar del logaritmo

**Media y Varianza:**
$$E[X] = e^{\mu + \sigma^2/2}, \quad \text{Var}(X) = (e^{\sigma^2} - 1)e^{2\mu + \sigma^2}$$

**Generación:**

$$X = e^{\mu + \sigma Z}, \quad Z \sim N(0,1)$$

```python
def generar_lognormal(mu, sigma, size=1):
    """Genera variables Lognormales"""
    Z = generar_normal_box_muller(0, 1, size)
    return np.exp(mu + sigma * Z)

# Ejemplo: Ingresos (μ=10, σ=0.5)
mu, sigma = 10, 0.5
muestras_lognorm = generar_lognormal(mu, sigma, size=10000)

# Verificar
from scipy.stats import lognorm
dist_teo = lognorm(s=sigma, scale=np.exp(mu))
print(f"Media teórica: {dist_teo.mean():.2f}, Simulada: {np.mean(muestras_lognorm):.2f}")

# Visualizar
plt.figure(figsize=(12, 5))

# PDF teórica
x = np.linspace(0, 100000, 1000)
pdf_teorica = dist_teo.pdf(x)

plt.subplot(1, 2, 1)
plt.plot(x, pdf_teorica, linewidth=2)
plt.fill_between(x, pdf_teorica, alpha=0.3)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title(f'PDF: Lognormal(μ={mu}, σ={sigma})')
plt.grid(True, alpha=0.3)

# Histograma
plt.subplot(1, 2, 2)
plt.hist(muestras_lognorm, bins=50, density=True, alpha=0.7, edgecolor='black')
plt.xlabel('x')
plt.ylabel('Densidad')
plt.title('Muestras Generadas')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

---

## Tabla Comparativa de Distribuciones Continuas

| Distribución | Parámetros | Rango | Media | Uso Típico |
|--------------|------------|-------|-------|------------|
| **Uniforme** | $a, b$ | $[a, b]$ | $\frac{a+b}{2}$ | Números aleatorios base |
| **Exponencial** | $\lambda$ | $[0, \infty)$ | $\frac{1}{\lambda}$ | Tiempos entre eventos |
| **Normal** | $\mu, \sigma$ | $(-\infty, \infty)$ | $\mu$ | Mediciones, errores |
| **Triangular** | $a, c, b$ | $[a, b]$ | $\frac{a+b+c}{3}$ | Estimaciones PERT |
| **Weibull** | $\alpha, \beta$ | $[0, \infty)$ | Compleja | Confiabilidad |
| **Lognormal** | $\mu, \sigma$ | $(0, \infty)$ | $e^{\mu+\sigma^2/2}$ | Ingresos, tamaños |

---

## Ejercicios Prácticos

### Ejercicio 1: Sistema de Colas

Un banco tiene tiempos entre llegadas que siguen una distribución Exponencial con $\lambda = 12$ clientes/hora. Simule 1 hora de operación y calcule:

1. Número total de clientes que llegaron
2. Tiempo promedio entre llegadas
3. Probabilidad de que pasen más de 10 minutos sin llegadas

**Solución:**

```python
lambd = 12  # clientes/hora
T_sim = 1   # hora

# Generar tiempos entre llegadas
tiempos_entre_llegadas = []
tiempo_acumulado = 0

while tiempo_acumulado < T_sim:
    tiempo = generar_exponencial(lambd, size=1)[0]
    if tiempo_acumulado + tiempo <= T_sim:
        tiempos_entre_llegadas.append(tiempo)
        tiempo_acumulado += tiempo
    else:
        break

# 1. Número de clientes
n_clientes = len(tiempos_entre_llegadas)
print(f"1. Clientes que llegaron: {n_clientes}")

# 2. Tiempo promedio entre llegadas
tiempo_promedio = np.mean(tiempos_entre_llegadas)
print(f"2. Tiempo promedio entre llegadas: {tiempo_promedio*60:.2f} minutos")

# 3. P(X > 10/60 horas)
prob_teorica = np.exp(-lambd * (10/60))
print(f"3. P(X > 10 min) teórica: {prob_teorica:.4f}")
```

### Ejercicio 2: Control de Calidad

Los pesos de productos siguen una distribución Normal con $\mu = 500$ g y $\sigma = 10$ g. Un producto se rechaza si pesa menos de 480 g o más de 520 g. ¿Qué porcentaje de productos se rechaza?

**Solución:**

```python
mu, sigma = 500, 10

# P(X < 480 o X > 520)
from scipy.stats import norm

p_rechazo = norm.cdf(480, mu, sigma) + (1 - norm.cdf(520, mu, sigma))
print(f"Porcentaje de rechazo: {p_rechazo*100:.2f}%")

# Simulación
muestras = generar_normal_box_muller(mu, sigma, size=100000)
rechazados = np.sum((muestras < 480) | (muestras > 520))
print(f"Porcentaje simulado: {rechazados/100000*100:.2f}%")
```

---

## Resumen y Conceptos Clave

**Distribuciones Continuas Fundamentales:**
- **Uniforme:** Base para generación, todos los valores equiprobables
- **Exponencial:** Tiempos entre eventos, falta de memoria
- **Normal:** La más importante, Teorema del Límite Central
- **Triangular:** Estimaciones con min/mode/max
- **Weibull:** Confiabilidad, muy flexible
- **Lognormal:** Logaritmo es normal

**Métodos de Generación:**
- Transformada inversa (Uniforme, Exponencial, Weibull)
- Box-Muller (Normal)
- Transformación (Lognormal = exp(Normal))

**Validación:**
Siempre verificar media, varianza y hacer pruebas de bondad de ajuste

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Law & Kelton (1991), Ross (2014), Devroye (1986)*


---

<div align="center">

⬅️ [3.2 VA Discretas](3.2.md) &nbsp;&nbsp;|&nbsp;&nbsp; [3.4 Métodos Generación](3.4.md) ➡️

</div>
