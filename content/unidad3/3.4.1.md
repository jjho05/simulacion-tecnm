# 3.4.1 Método de la transformada inversa

El método de la transformada inversa es el algoritmo más fundamental y elegante para generar variables aleatorias. Se basa en una propiedad matemática profunda: la CDF de cualquier variable aleatoria, cuando se evalúa en esa variable, produce una distribución uniforme.

---

## Fundamento Teórico

### Teorema de la Transformada Inversa

**Teorema:** Si $X$ es una variable aleatoria continua con función de distribución acumulada $F(x)$, y $R \sim U[0,1]$, entonces:

$$X = F^{-1}(R)$$

tiene la misma distribución que $X$.

**Demostración:**

Sea $Y = F^{-1}(R)$. Queremos demostrar que $P(Y \leq y) = F(y)$.

$$P(Y \leq y) = P(F^{-1}(R) \leq y)$$

Aplicando $F$ a ambos lados (como $F$ es monótona creciente):

$$= P(R \leq F(y))$$

Como $R \sim U[0,1]$:

$$= F(y) \quad \checkmark$$

### Intuición Geométrica

Imagina la CDF como una "escalera" que va de 0 a 1. El método de la transformada inversa es como:

1. Lanzar un dardo uniformemente en el eje Y (entre 0 y 1)
2. Proyectar horizontalmente hasta tocar la curva CDF
3. Proyectar verticalmente al eje X

El valor en X es nuestra variable aleatoria generada.

```python
import numpy as np
import matplotlib.pyplot as plt

# Visualizar transformada inversa para Exponencial
lambd = 2
R_values = [0.1, 0.3, 0.5, 0.7, 0.9]

# CDF de exponencial
x = np.linspace(0, 3, 1000)
F_x = 1 - np.exp(-lambd * x)

plt.figure(figsize=(12, 8))
plt.plot(x, F_x, 'b-', linewidth=2, label='F(x) = 1 - e^(-λx)')

# Mostrar transformación para cada R
for R in R_values:
    # Inversa: X = -ln(1-R)/λ
    X = -np.log(1 - R) / lambd
    
    # Dibujar líneas de proyección
    plt.plot([0, X], [R, R], 'r--', alpha=0.5)
    plt.plot([X, X], [0, R], 'r--', alpha=0.5)
    plt.plot(X, R, 'ro', markersize=8)
    plt.text(X+0.05, R+0.05, f'R={R}', fontsize=9)

plt.xlabel('x')
plt.ylabel('F(x) y R')
plt.title('Método de la Transformada Inversa: Visualización Geométrica')
plt.legend()
plt.grid(True, alpha=0.3)
plt.xlim(-0.1, 3)
plt.ylim(-0.05, 1.05)
plt.show()
```

---

## Procedimiento Paso a Paso

### Algoritmo General

**Paso 1:** Obtener la función de densidad $f(x)$ de la distribución objetivo

**Paso 2:** Calcular la CDF integrando:
$$F(x) = \int_{-\infty}^{x} f(t)dt$$

**Paso 3:** Igualar la CDF a un número uniforme:
$$F(x) = R, \quad R \sim U[0,1]$$

**Paso 4:** Despejar $x$ para obtener la función inversa:
$$x = F^{-1}(R)$$

**Paso 5:** Generar $R \sim U[0,1]$ y calcular $X = F^{-1}(R)$

---

## Ejemplos Detallados

### Ejemplo 1: Distribución Exponencial

**Paso 1: PDF**
$$f(x) = \lambda e^{-\lambda x}, \quad x \geq 0$$

**Paso 2: CDF**
$$F(x) = \int_0^x \lambda e^{-\lambda t}dt = [-e^{-\lambda t}]_0^x = 1 - e^{-\lambda x}$$

**Paso 3: Igualar a R**
$$1 - e^{-\lambda x} = R$$

**Paso 4: Despejar x**
$$e^{-\lambda x} = 1 - R$$
$$-\lambda x = \ln(1-R)$$
$$x = -\frac{1}{\lambda}\ln(1-R)$$

**Simplificación:** Como $1-R \sim U[0,1]$ también, podemos usar:
$$x = -\frac{1}{\lambda}\ln(R)$$

**Paso 5: Implementación**

```python
def generar_exponencial_inversa(lambd, size=1):
    """Genera variables exponenciales usando transformada inversa"""
    R = np.random.random(size)
    return -np.log(R) / lambd

# Ejemplo
lambd = 3
muestras = generar_exponencial_inversa(lambd, size=10000)

# Verificar
print(f"Media teórica: {1/lambd:.4f}")
print(f"Media simulada: {np.mean(muestras):.4f}")
print(f"Varianza teórica: {1/lambd**2:.4f}")
print(f"Varianza simulada: {np.var(muestras):.4f}")

# Visualizar
from scipy.stats import expon

plt.figure(figsize=(10, 6))
plt.hist(muestras, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado')

x = np.linspace(0, 3, 1000)
pdf_teo = expon.pdf(x, scale=1/lambd)
plt.plot(x, pdf_teo, 'r-', linewidth=2, label='Teórico')

plt.xlabel('x')
plt.ylabel('Densidad')
plt.title('Generación Exponencial: Transformada Inversa')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

### Ejemplo 2: Distribución Uniforme Continua

**Paso 1: PDF**
$$f(x) = \frac{1}{b-a}, \quad a \leq x \leq b$$

**Paso 2: CDF**
$$F(x) = \int_a^x \frac{1}{b-a}dt = \frac{x-a}{b-a}$$

**Paso 3: Igualar a R**
$$\frac{x-a}{b-a} = R$$

**Paso 4: Despejar x**
$$x-a = R(b-a)$$
$$x = a + (b-a)R$$

**Paso 5: Implementación**

```python
def generar_uniforme_inversa(a, b, size=1):
    """Genera variables uniformes en [a,b] usando transformada inversa"""
    R = np.random.random(size)
    return a + (b - a) * R

# Ejemplo: Tiempo de espera entre 5 y 15 minutos
a, b = 5, 15
muestras = generar_uniforme_inversa(a, b, size=10000)

print(f"Media teórica: {(a+b)/2:.2f}")
print(f"Media simulada: {np.mean(muestras):.2f}")

# Visualizar
plt.figure(figsize=(10, 6))
plt.hist(muestras, bins=50, density=True, alpha=0.7, edgecolor='black')
plt.axhline(y=1/(b-a), color='r', linestyle='--', linewidth=2, label='Densidad teórica')
plt.xlabel('x (minutos)')
plt.ylabel('Densidad')
plt.title('Generación Uniforme[5,15]: Transformada Inversa')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

### Ejemplo 3: Distribución Weibull

**Paso 1: PDF**
$$f(x) = \frac{\beta}{\alpha}\left(\frac{x}{\alpha}\right)^{\beta-1}e^{-(x/\alpha)^\beta}, \quad x \geq 0$$

**Paso 2: CDF**
$$F(x) = 1 - e^{-(x/\alpha)^\beta}$$

**Paso 3: Igualar a R**
$$1 - e^{-(x/\alpha)^\beta} = R$$

**Paso 4: Despejar x**
$$e^{-(x/\alpha)^\beta} = 1 - R$$
$$-(x/\alpha)^\beta = \ln(1-R)$$
$$(x/\alpha)^\beta = -\ln(1-R) = \ln(1/R)$$
$$x/\alpha = [\ln(1/R)]^{1/\beta}$$
$$x = \alpha[-\ln(R)]^{1/\beta}$$

**Paso 5: Implementación**

```python
def generar_weibull_inversa(alpha, beta, size=1):
    """Genera variables Weibull usando transformada inversa"""
    R = np.random.random(size)
    return alpha * (-np.log(R))**(1/beta)

# Ejemplo: Tiempo de vida de componente
alpha, beta = 1000, 2  # α=escala, β=forma
muestras = generar_weibull_inversa(alpha, beta, size=10000)

# Verificar
from scipy.stats import weibull_min
dist_teo = weibull_min(c=beta, scale=alpha)

print(f"Media teórica: {dist_teo.mean():.2f}")
print(f"Media simulada: {np.mean(muestras):.2f}")

# Visualizar
plt.figure(figsize=(10, 6))
plt.hist(muestras, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado')

x = np.linspace(0, 3000, 1000)
pdf_teo = dist_teo.pdf(x)
plt.plot(x, pdf_teo, 'r-', linewidth=2, label='Teórico')

plt.xlabel('x (horas)')
plt.ylabel('Densidad')
plt.title(f'Generación Weibull(α={alpha}, β={beta}): Transformada Inversa')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

### Ejemplo 4: Distribución Triangular

**Paso 1: PDF**
$$f(x) = \begin{cases}
\frac{2(x-a)}{(b-a)(c-a)} & \text{si } a \leq x \leq c \\
\frac{2(b-x)}{(b-a)(b-c)} & \text{si } c < x \leq b
\end{cases}$$

**Paso 2: CDF**
$$F(x) = \begin{cases}
\frac{(x-a)^2}{(b-a)(c-a)} & \text{si } a \leq x \leq c \\
1 - \frac{(b-x)^2}{(b-a)(b-c)} & \text{si } c < x \leq b
\end{cases}$$

**Paso 3 y 4: Inversa (por casos)**

Definir $F_c = F(c) = \frac{c-a}{b-a}$

$$F^{-1}(R) = \begin{cases}
a + \sqrt{R(b-a)(c-a)} & \text{si } R < F_c \\
b - \sqrt{(1-R)(b-a)(b-c)} & \text{si } R \geq F_c
\end{cases}$$

**Paso 5: Implementación**

```python
def generar_triangular_inversa(a, c, b, size=1):
    """Genera variables Triangulares usando transformada inversa"""
    R = np.random.random(size)
    
    F_c = (c - a) / (b - a)
    
    X = np.where(
        R < F_c,
        a + np.sqrt(R * (b - a) * (c - a)),
        b - np.sqrt((1 - R) * (b - a) * (b - c))
    )
    
    return X

# Ejemplo: Estimación PERT de proyecto
a, c, b = 10, 15, 30  # optimista, más probable, pesimista (días)
muestras = generar_triangular_inversa(a, c, b, size=10000)

# Verificar
media_teo = (a + b + c) / 3
print(f"Media teórica: {media_teo:.2f} días")
print(f"Media simulada: {np.mean(muestras):.2f} días")

# Visualizar
plt.figure(figsize=(10, 6))
plt.hist(muestras, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado')

# PDF teórica
x1 = np.linspace(a, c, 500)
x2 = np.linspace(c, b, 500)
pdf1 = 2*(x1-a) / ((b-a)*(c-a))
pdf2 = 2*(b-x2) / ((b-a)*(b-c))

plt.plot(x1, pdf1, 'r-', linewidth=2)
plt.plot(x2, pdf2, 'r-', linewidth=2, label='Teórico')

plt.xlabel('x (días)')
plt.ylabel('Densidad')
plt.title(f'Generación Triangular({a}, {c}, {b}): Transformada Inversa')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

## Ventajas y Limitaciones

### Ventajas

1. **Exactitud:** Método exacto, no aproximado
2. **Simplicidad conceptual:** Fácil de entender y explicar
3. **Eficiencia:** Muy rápido cuando $F^{-1}$ tiene forma cerrada
4. **Reproducibilidad:** Misma semilla → mismos resultados
5. **Monotonía:** Preserva orden: si $R_1 < R_2$ entonces $F^{-1}(R_1) < F^{-1}(R_2)$

### Limitaciones

1. **Requiere forma cerrada:** No todas las distribuciones tienen $F^{-1}$ analítica
   - **Ejemplos sin forma cerrada:** Normal, Gamma, Beta

2. **Inversión numérica costosa:** Si $F^{-1}$ no es explícita, requiere métodos numéricos
   - Bisección, Newton-Raphson, etc.
   - Puede ser lento

3. **Complejidad algebraica:** Derivar $F^{-1}$ puede ser difícil

### Tabla de Aplicabilidad

| Distribución | ¿Tiene $F^{-1}$ cerrada? | Fórmula |
|--------------|-------------------------|---------|
| **Uniforme** | ✅ Sí | $a + (b-a)R$ |
| **Exponencial** | ✅ Sí | $-\frac{1}{\lambda}\ln(R)$ |
| **Weibull** | ✅ Sí | $\alpha(-\ln R)^{1/\beta}$ |
| **Triangular** | ✅ Sí | Por casos |
| **Logística** | ✅ Sí | $\mu + s\ln\left(\frac{R}{1-R}\right)$ |
| **Normal** | ❌ No | Usar Box-Muller |
| **Gamma** | ❌ No | Usar Aceptación-Rechazo |
| **Beta** | ❌ No | Usar Aceptación-Rechazo |

---

## Ejercicios Prácticos

### Ejercicio 1: Derivar Inversa de Logística

La distribución logística tiene CDF:
$$F(x) = \frac{1}{1 + e^{-(x-\mu)/s}}$$

Derive $F^{-1}(R)$ y genere 10,000 muestras con $\mu=0$, $s=1$.

**Solución:**

```python
# Derivación:
# F(x) = 1/(1 + e^(-(x-μ)/s)) = R
# 1 + e^(-(x-μ)/s) = 1/R
# e^(-(x-μ)/s) = 1/R - 1 = (1-R)/R
# -(x-μ)/s = ln((1-R)/R)
# x = μ + s*ln(R/(1-R))

def generar_logistica_inversa(mu, s, size=1):
    R = np.random.random(size)
    return mu + s * np.log(R / (1 - R))

# Generar
muestras = generar_logistica_inversa(mu=0, s=1, size=10000)

# Verificar
from scipy.stats import logistic
dist_teo = logistic(loc=0, scale=1)

print(f"Media teórica: {dist_teo.mean():.4f}")
print(f"Media simulada: {np.mean(muestras):.4f}")

# Visualizar
plt.figure(figsize=(10, 6))
plt.hist(muestras, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado')

x = np.linspace(-10, 10, 1000)
pdf_teo = dist_teo.pdf(x)
plt.plot(x, pdf_teo, 'r-', linewidth=2, label='Teórico')

plt.xlabel('x')
plt.ylabel('Densidad')
plt.title('Distribución Logística: Transformada Inversa')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

### Ejercicio 2: Comparar Eficiencia

Compare el tiempo de ejecución de generar 100,000 variables exponenciales usando:
1. Transformada inversa manual
2. Scipy (optimizado)

**Solución:**

```python
import time

lambd = 2
n = 100000

# Método 1: Manual
inicio = time.time()
R = np.random.random(n)
X_manual = -np.log(R) / lambd
tiempo_manual = time.time() - inicio

# Método 2: Scipy
inicio = time.time()
X_scipy = expon.rvs(scale=1/lambd, size=n)
tiempo_scipy = time.time() - inicio

print(f"Transformada Inversa manual: {tiempo_manual:.4f}s")
print(f"Scipy (optimizado): {tiempo_scipy:.4f}s")
print(f"Ratio: {tiempo_manual/tiempo_scipy:.2f}x")
```

---

## Casos de Estudio

### Caso 1: Simulación de Tiempos de Falla

**Problema:** Una empresa fabrica componentes electrónicos cuyo tiempo de vida sigue una distribución Weibull con $\alpha=5000$ horas y $\beta=1.5$ (fallas por desgaste).

**Pregunta:** ¿Cuál es la probabilidad de que un componente falle antes de 3000 horas?

```python
# Parámetros
alpha, beta = 5000, 1.5

# Generar 100,000 tiempos de vida
tiempos_vida = generar_weibull_inversa(alpha, beta, size=100000)

# P(X < 3000)
prob_falla = np.mean(tiempos_vida < 3000)

print(f"Probabilidad de falla antes de 3000h: {prob_falla*100:.2f}%")

# Comparar con teórico
from scipy.stats import weibull_min
prob_teo = weibull_min.cdf(3000, c=beta, scale=alpha)
print(f"Probabilidad teórica: {prob_teo*100:.2f}%")

# Visualizar
plt.figure(figsize=(10, 6))
plt.hist(tiempos_vida, bins=50, density=True, alpha=0.7, edgecolor='black')
plt.axvline(3000, color='r', linestyle='--', linewidth=2, label='3000 horas')

x = np.linspace(0, 15000, 1000)
pdf_teo = weibull_min.pdf(x, c=beta, scale=alpha)
plt.plot(x, pdf_teo, 'b-', linewidth=2, label='PDF Weibull')

plt.xlabel('Tiempo de vida (horas)')
plt.ylabel('Densidad')
plt.title('Distribución de Tiempos de Vida')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

## Resumen y Mejores Prácticas

**Conceptos Clave:**
- Transformada Inversa: $X = F^{-1}(R)$
- Funciona para cualquier distribución con $F^{-1}$ en forma cerrada
- Método exacto y eficiente

**Cuándo Usar:**
- Exponencial, Weibull, Uniforme, Triangular, Logística
- Cuando se necesita exactitud
- Cuando se requiere reproducibilidad estricta

**Cuándo NO Usar:**
- Normal, Gamma, Beta (sin forma cerrada)
- Usar Box-Muller para Normal
- Usar Aceptación-Rechazo para Gamma/Beta

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Devroye (1986), Law & Kelton (1991), Ross (2014)*


---

<div align="center">

⬅️ [3.4 Métodos Generación](3.4.md) &nbsp;&nbsp;|&nbsp;&nbsp; [3.4.2 Convolución](3.4.2.md) ➡️

</div>
