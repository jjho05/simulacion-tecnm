# 3.4.2 Método de convolución

El método de convolución se basa en un principio matemático fundamental: algunas distribuciones de probabilidad pueden expresarse como la suma de otras variables aleatorias más simples e independientes. Este método es especialmente útil cuando la distribución objetivo tiene una interpretación física natural como suma de eventos.

---

## Principio Fundamental

### Definición de Convolución

Si $X = Y_1 + Y_2 + ... + Y_n$ donde las $Y_i$ son variables aleatorias **independientes** e **idénticamente distribuidas** (i.i.d.), entonces podemos generar $X$ simplemente sumando $n$ valores generados de $Y$.

**Notación matemática:**
$$X = \sum_{i=1}^{n} Y_i, \quad Y_i \stackrel{iid}{\sim} f_Y(y)$$

### Fundamento Teórico

La **convolución** de dos distribuciones de probabilidad es la distribución de la suma de dos variables aleatorias independientes.

Para variables continuas:
$$f_X(x) = \int_{-\infty}^{\infty} f_Y(y) f_Z(x-y) dy = (f_Y * f_Z)(x)$$

**Ejemplo conceptual:**

Si lanzamos dos dados independientes, la suma de los resultados sigue la convolución de dos distribuciones uniformes discretas.

```python
import numpy as np
import matplotlib.pyplot as plt

# Simular suma de dos dados
n_sim = 100000
dado1 = np.random.randint(1, 7, n_sim)
dado2 = np.random.randint(1, 7, n_sim)
suma = dado1 + dado2

# Visualizar
plt.figure(figsize=(12, 5))

# Distribución de un dado
plt.subplot(1, 2, 1)
plt.hist(dado1, bins=np.arange(0.5, 7.5, 1), density=True, alpha=0.7, edgecolor='black')
plt.xlabel('Valor')
plt.ylabel('Probabilidad')
plt.title('Distribución de UN Dado')
plt.xticks(range(1, 7))
plt.grid(True, alpha=0.3)

# Distribución de la suma (convolución)
plt.subplot(1, 2, 2)
plt.hist(suma, bins=np.arange(1.5, 13.5, 1), density=True, alpha=0.7, edgecolor='black')
plt.xlabel('Suma')
plt.ylabel('Probabilidad')
plt.title('Distribución de la SUMA de Dos Dados (Convolución)')
plt.xticks(range(2, 13))
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

---

## Aplicaciones Principales

### 1. Distribución Erlang-k

**Definición:** La distribución Erlang-$k$ es la suma de $k$ variables exponenciales independientes con el mismo parámetro $\lambda$.

$$X = \sum_{i=1}^{k} Y_i, \quad Y_i \sim \text{Exp}(\lambda)$$

**Interpretación física:**
- Tiempo total para completar $k$ etapas secuenciales
- Cada etapa tiene duración exponencial con tasa $\lambda$

**PDF de Erlang-k:**
$$f(x) = \frac{\lambda^k x^{k-1} e^{-\lambda x}}{(k-1)!}, \quad x \geq 0$$

**Media y Varianza:**
$$E[X] = \frac{k}{\lambda}, \quad \text{Var}(X) = \frac{k}{\lambda^2}$$

**Generación (Método 1: Suma directa):**

```python
def generar_erlang_suma(k, lambd, size=1):
    """Genera variables Erlang-k sumando k exponenciales"""
    resultados = []
    
    for _ in range(size):
        suma = 0
        for _ in range(k):
            R = np.random.random()
            suma += -np.log(R) / lambd
        resultados.append(suma)
    
    return np.array(resultados)

# Ejemplo: Tiempo de procesamiento de 5 etapas
k, lambd = 5, 2
muestras = generar_erlang_suma(k, lambd, size=10000)

# Verificar
print(f"Media teórica: {k/lambd:.4f}")
print(f"Media simulada: {np.mean(muestras):.4f}")
print(f"Varianza teórica: {k/lambd**2:.4f}")
print(f"Varianza simulada: {np.var(muestras):.4f}")

# Visualizar
from scipy.stats import erlang

plt.figure(figsize=(10, 6))
plt.hist(muestras, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado')

x = np.linspace(0, 8, 1000)
pdf_teo = erlang.pdf(x, a=k, scale=1/lambd)
plt.plot(x, pdf_teo, 'r-', linewidth=2, label='Teórico')

plt.xlabel('x')
plt.ylabel('Densidad')
plt.title(f'Erlang-{k}: Suma de {k} Exponenciales')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

**Generación (Método 2: Optimizado con producto):**

Usando la propiedad $\sum \ln(R_i) = \ln(\prod R_i)$:

$$X = -\frac{1}{\lambda}\sum_{i=1}^{k}\ln(R_i) = -\frac{1}{\lambda}\ln\left(\prod_{i=1}^{k}R_i\right)$$

```python
def generar_erlang_producto(k, lambd, size=1):
    """Genera variables Erlang-k usando producto de uniformes"""
    resultados = []
    
    for _ in range(size):
        producto = 1
        for _ in range(k):
            R = np.random.random()
            producto *= R
        
        X = -np.log(producto) / lambd
        resultados.append(X)
    
    return np.array(resultados)

# Comparar eficiencia
import time

n = 10000

# Método suma
inicio = time.time()
muestras_suma = generar_erlang_suma(k, lambd, n)
tiempo_suma = time.time() - inicio

# Método producto
inicio = time.time()
muestras_producto = generar_erlang_producto(k, lambd, n)
tiempo_producto = time.time() - inicio

print(f"Tiempo método suma: {tiempo_suma:.4f}s")
print(f"Tiempo método producto: {tiempo_producto:.4f}s")
print(f"Ratio: {tiempo_suma/tiempo_producto:.2f}x")
```

---

### 2. Distribución Binomial

**Definición:** La distribución Binomial es la suma de $n$ variables Bernoulli independientes con probabilidad $p$.

$$X = \sum_{i=1}^{n} B_i, \quad B_i \sim \text{Bernoulli}(p)$$

**Interpretación física:**
- Número de éxitos en $n$ ensayos independientes
- Cada ensayo tiene probabilidad $p$ de éxito

**PMF:**
$$P(X = k) = \binom{n}{k} p^k (1-p)^{n-k}$$

**Media y Varianza:**
$$E[X] = np, \quad \text{Var}(X) = np(1-p)$$

**Generación:**

```python
def generar_binomial_convolucion(n, p, size=1):
    """Genera variables Binomial sumando Bernoulli"""
    resultados = []
    
    for _ in range(size):
        exitos = 0
        for _ in range(n):
            R = np.random.random()
            if R <= p:
                exitos += 1
        resultados.append(exitos)
    
    return np.array(resultados)

# Ejemplo: 20 lanzamientos de moneda con p=0.6
n, p = 20, 0.6
muestras = generar_binomial_convolucion(n, p, size=10000)

# Verificar
print(f"Media teórica: {n*p:.2f}")
print(f"Media simulada: {np.mean(muestras):.2f}")
print(f"Varianza teórica: {n*p*(1-p):.2f}")
print(f"Varianza simulada: {np.var(muestras):.2f}")

# Visualizar
from scipy.stats import binom

plt.figure(figsize=(10, 6))
plt.hist(muestras, bins=range(0, n+2), density=True, alpha=0.7, edgecolor='black', label='Simulado', align='left')

x = np.arange(0, n+1)
pmf_teo = binom.pmf(x, n, p)
plt.plot(x, pmf_teo, 'ro-', linewidth=2, markersize=8, label='Teórico')

plt.xlabel('Número de éxitos')
plt.ylabel('Probabilidad')
plt.title(f'Binomial({n}, {p}): Suma de {n} Bernoulli')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

### 3. Aproximación a la Normal (Teorema del Límite Central)

**Teorema del Límite Central (TLC):**

Si $X_1, X_2, ..., X_n$ son variables aleatorias i.i.d. con media $\mu$ y varianza $\sigma^2$, entonces:

$$\frac{\sum_{i=1}^{n} X_i - n\mu}{\sigma\sqrt{n}} \xrightarrow{d} N(0,1)$$

**Aplicación práctica:** Suma de 12 uniformes

Para $R_i \sim U[0,1]$:
- $E[R_i] = 0.5$
- $\text{Var}(R_i) = 1/12$

Suma de 12 uniformes:
$$S = \sum_{i=1}^{12} R_i$$

- $E[S] = 12 \times 0.5 = 6$
- $\text{Var}(S) = 12 \times 1/12 = 1$

Por lo tanto:
$$Z = S - 6 \approx N(0,1)$$

**Generación:**

```python
def generar_normal_suma_uniformes(mu, sigma, size=1):
    """
    Genera variables normales sumando 12 uniformes.
    Método histórico (antes de Box-Muller).
    """
    resultados = []
    
    for _ in range(size):
        suma = 0
        for _ in range(12):
            R = np.random.random()
            suma += R
        
        Z = suma - 6  # N(0,1)
        X = mu + sigma * Z
        resultados.append(X)
    
    return np.array(resultados)

# Ejemplo
mu, sigma = 100, 15
muestras = generar_normal_suma_uniformes(mu, sigma, size=10000)

# Verificar
print(f"Media teórica: {mu:.2f}")
print(f"Media simulada: {np.mean(muestras):.2f}")
print(f"Desv.Est. teórica: {sigma:.2f}")
print(f"Desv.Est. simulada: {np.std(muestras):.2f}")

# Visualizar
from scipy.stats import norm

plt.figure(figsize=(10, 6))
plt.hist(muestras, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado (12 uniformes)')

x = np.linspace(mu - 4*sigma, mu + 4*sigma, 1000)
pdf_teo = norm.pdf(x, mu, sigma)
plt.plot(x, pdf_teo, 'r-', linewidth=2, label='Normal teórica')

plt.xlabel('x')
plt.ylabel('Densidad')
plt.title('Aproximación Normal: Suma de 12 Uniformes')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

**Limitación:** Esta aproximación tiene colas más cortas que la verdadera normal (limitada a $\pm 6$). Para aplicaciones serias, usar Box-Muller.

---

### 4. Distribución Gamma

**Definición:** La distribución Gamma con parámetro de forma entero $\alpha = k$ es equivalente a Erlang-$k$.

Para $\alpha$ no entero, se puede usar convolución aproximada o métodos más avanzados.

---

## Ventajas y Limitaciones

### Ventajas

1. **Conceptualmente simple:** Fácil de entender e implementar
2. **Físicamente intuitivo:** Refleja procesos naturales (etapas secuenciales, ensayos repetidos)
3. **No requiere inversión:** No necesita calcular $F^{-1}$
4. **Exacto:** Produce la distribución correcta (no aproximada)

### Limitaciones

1. **Requiere múltiples números aleatorios:** Necesita $n$ uniformes para generar una variable
2. **Computacionalmente costoso:** Para $n$ grande, puede ser lento
3. **Aplicabilidad limitada:** Solo funciona para distribuciones que son sumas
4. **Eficiencia:** Menos eficiente que transformada inversa cuando esta existe

### Comparación de Eficiencia

```python
# Comparar Erlang-10: Convolución vs Scipy

k, lambd = 10, 2
n = 10000

# Convolución
inicio = time.time()
muestras_conv = generar_erlang_suma(k, lambd, n)
tiempo_conv = time.time() - inicio

# Scipy (optimizado)
inicio = time.time()
muestras_scipy = erlang.rvs(a=k, scale=1/lambd, size=n)
tiempo_scipy = time.time() - inicio

print(f"Convolución: {tiempo_conv:.4f}s")
print(f"Scipy: {tiempo_scipy:.4f}s")
print(f"Ratio: {tiempo_conv/tiempo_scipy:.2f}x más lento")
```

---

## Ejercicios Prácticos

### Ejercicio 1: Sistema de Producción

Una línea de producción tiene 7 estaciones secuenciales. El tiempo de procesamiento en cada estación sigue una distribución Exponencial con $\lambda = 4$ unidades/hora.

1. Genere 10,000 tiempos totales de producción
2. Calcule el tiempo promedio total
3. ¿Cuál es la probabilidad de que un producto tarde más de 2 horas?

**Solución:**

```python
# Parámetros
k = 7  # estaciones
lambd = 4  # unidades/hora por estación

# 1. Generar tiempos totales
tiempos_totales = generar_erlang_suma(k, lambd, size=10000)

# 2. Tiempo promedio
tiempo_promedio = np.mean(tiempos_totales)
tiempo_teorico = k / lambd

print(f"Tiempo promedio simulado: {tiempo_promedio:.4f} horas")
print(f"Tiempo promedio teórico: {tiempo_teorico:.4f} horas")

# 3. P(X > 2)
prob_mas_2h = np.mean(tiempos_totales > 2)
print(f"P(X > 2h) simulado: {prob_mas_2h*100:.2f}%")

# Comparar con teórico
from scipy.stats import erlang
prob_teo = 1 - erlang.cdf(2, a=k, scale=1/lambd)
print(f"P(X > 2h) teórico: {prob_teo*100:.2f}%")

# Visualizar
plt.figure(figsize=(10, 6))
plt.hist(tiempos_totales, bins=50, density=True, alpha=0.7, edgecolor='black')
plt.axvline(2, color='r', linestyle='--', linewidth=2, label='2 horas')

x = np.linspace(0, 5, 1000)
pdf_teo = erlang.pdf(x, a=k, scale=1/lambd)
plt.plot(x, pdf_teo, 'b-', linewidth=2, label='PDF teórica')

plt.xlabel('Tiempo total (horas)')
plt.ylabel('Densidad')
plt.title('Distribución de Tiempos de Producción (Erlang-7)')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

### Ejercicio 2: Control de Calidad

Se inspeccionan lotes de 50 componentes. La probabilidad de que un componente sea defectuoso es 0.08.

1. Genere 1,000 lotes y cuente los defectos en cada uno
2. ¿Cuál es el número promedio de defectos por lote?
3. ¿Cuál es la probabilidad de encontrar más de 5 defectos en un lote?

**Solución:**

```python
n, p = 50, 0.08

# 1. Generar lotes
defectos_por_lote = generar_binomial_convolucion(n, p, size=1000)

# 2. Promedio
promedio_defectos = np.mean(defectos_por_lote)
print(f"Promedio de defectos por lote: {promedio_defectos:.2f}")
print(f"Teórico: {n*p:.2f}")

# 3. P(X > 5)
prob_mas_5 = np.mean(defectos_por_lote > 5)
print(f"P(X > 5) simulado: {prob_mas_5*100:.2f}%")

# Teórico
prob_teo = 1 - binom.cdf(5, n, p)
print(f"P(X > 5) teórico: {prob_teo*100:.2f}%")
```

---

## Casos de Estudio

### Caso 1: Centro de Llamadas

**Problema:** Un centro de llamadas tiene 4 agentes que atienden llamadas secuencialmente. El tiempo de atención de cada agente sigue una distribución Exponencial con $\lambda = 6$ llamadas/hora.

**Pregunta:** ¿Cuál es el tiempo total promedio que una llamada pasa en el sistema?

```python
# Parámetros
k_agentes = 4
lambd = 6  # llamadas/hora

# Generar tiempos totales
tiempos_sistema = generar_erlang_suma(k_agentes, lambd, size=100000)

# Estadísticos
tiempo_promedio = np.mean(tiempos_sistema)
tiempo_mediano = np.median(tiempos_sistema)
percentil_90 = np.percentile(tiempos_sistema, 90)

print(f"Tiempo promedio en sistema: {tiempo_promedio*60:.2f} minutos")
print(f"Tiempo mediano: {tiempo_mediano*60:.2f} minutos")
print(f"90% de llamadas terminan en: {percentil_90*60:.2f} minutos")

# Visualizar
plt.figure(figsize=(10, 6))
plt.hist(tiempos_sistema, bins=50, density=True, alpha=0.7, edgecolor='black')
plt.axvline(tiempo_promedio, color='r', linestyle='--', linewidth=2, label=f'Media: {tiempo_promedio*60:.1f} min')
plt.axvline(percentil_90, color='g', linestyle='--', linewidth=2, label=f'P90: {percentil_90*60:.1f} min')

x = np.linspace(0, 3, 1000)
pdf_teo = erlang.pdf(x, a=k_agentes, scale=1/lambd)
plt.plot(x, pdf_teo, 'b-', linewidth=2, label='PDF teórica')

plt.xlabel('Tiempo en sistema (horas)')
plt.ylabel('Densidad')
plt.title('Distribución de Tiempos en Centro de Llamadas')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

## Comparación con Otros Métodos

### Tabla Comparativa para Erlang-k

| Aspecto | Convolución | Transformada Inversa | Scipy |
|---------|-------------|---------------------|-------|
| **Complejidad** | Simple | Requiere $F^{-1}$ | Caja negra |
| **Velocidad** | Lento ($k$ uniformes) | Rápido (1 uniforme + cálculo) | Muy rápido (optimizado) |
| **Precisión** | Exacto | Exacto | Exacto |
| **Educativo** | ✅ Muy intuitivo | ⚠️ Requiere matemáticas | ❌ No transparente |
| **Producción** | ❌ No recomendado | ✅ Aceptable | ✅ Recomendado |

---

## Resumen y Mejores Prácticas

**Conceptos Clave:**
- Convolución: Suma de variables aleatorias independientes
- Erlang-k: Suma de k exponenciales
- Binomial: Suma de n Bernoulli
- TLC: Suma de muchas variables → Normal

**Cuándo Usar:**
- Erlang, Binomial (distribuciones naturalmente sumas)
- Cuando la interpretación física es importante
- Para propósitos educativos

**Cuándo NO Usar:**
- Cuando existe transformada inversa más eficiente
- Para $k$ muy grande (usar aproximaciones)
- En código de producción (usar librerías optimizadas)

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Law & Kelton (1991), Ross (2014), Devroye (1986)*


---

<div align="center">

⬅️ [3.4.1 Transformada Inversa](3.4.1.md) &nbsp;&nbsp;|&nbsp;&nbsp; [3.4.3 Composición](3.4.3.md) ➡️

</div>
