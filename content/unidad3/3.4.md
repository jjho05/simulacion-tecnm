# 3.4 Métodos para generar variables aleatorias

Una vez que tenemos una fuente confiable de números pseudoaleatorios uniformes $U \sim [0,1]$, el siguiente paso crucial en cualquier simulación es transformar esta uniformidad en las distribuciones de probabilidad específicas que modelan nuestro sistema real (exponencial para tiempos de llegada, normal para errores, Poisson para conteos, etc.).

Esta sección cubre los tres algoritmos fundamentales para realizar esta transformación, cada uno con sus ventajas, limitaciones y casos de uso específicos.

---

## Panorama General de los Métodos

### El Problema Fundamental

**Dado:** Un generador de números uniformes $R \sim U[0,1]$

**Objetivo:** Generar $X \sim f(x)$ (cualquier distribución deseada)

### Los Tres Métodos Principales

| Método | Principio | Ventajas | Limitaciones | Mejor Para |
|--------|-----------|----------|--------------|------------|
| **Transformada Inversa** | $X = F^{-1}(R)$ | Exacto, directo | Requiere $F^{-1}$ en forma cerrada | Exp, Weibull, Uniforme |
| **Convolución** | $X = \sum Y_i$ | Intuitivo, físicamente natural | Lento para $n$ grande | Erlang, Binomial |
| **Composición** | Mezcla de distribuciones | Flexible, modular | Requiere descomposición | Hiperexponencial, Mixtas |

---

## Comparación Visual de los Métodos

### Método 1: Transformada Inversa

**Idea:** Usar la CDF como "función de transformación"

```
R ~ U[0,1]  →  F^(-1)(R)  →  X ~ f(x)
```

**Ejemplo Gráfico:**

```python
import numpy as np
import matplotlib.pyplot as plt

# Generar exponencial usando transformada inversa
lambd = 2
R = np.random.random(1000)
X = -np.log(R) / lambd

# Visualizar transformación
fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 4))

# Paso 1: R uniforme
ax1.hist(R, bins=30, density=True, alpha=0.7, edgecolor='black')
ax1.set_title('Paso 1: R ~ U[0,1]')
ax1.set_xlabel('R')
ax1.set_ylabel('Densidad')

# Paso 2: Transformación (CDF inversa)
x_plot = np.linspace(0, 1, 100)
x_inv = -np.log(x_plot) / lambd
ax2.plot(x_plot, x_inv, linewidth=2)
ax2.set_title('Paso 2: X = F^(-1)(R)')
ax2.set_xlabel('R')
ax2.set_ylabel('X')
ax2.grid(True, alpha=0.3)

# Paso 3: X exponencial
ax3.hist(X, bins=30, density=True, alpha=0.7, edgecolor='black', label='Simulado')
x_teo = np.linspace(0, 5, 100)
pdf_teo = lambd * np.exp(-lambd * x_teo)
ax3.plot(x_teo, pdf_teo, 'r-', linewidth=2, label='Teórico')
ax3.set_title('Paso 3: X ~ Exp(λ)')
ax3.set_xlabel('X')
ax3.set_ylabel('Densidad')
ax3.legend()

plt.tight_layout()
plt.show()
```

### Método 2: Convolución

**Idea:** Sumar variables aleatorias independientes

```
X = Y₁ + Y₂ + ... + Yₙ
```

**Ejemplo:** Erlang-3 = suma de 3 exponenciales

```python
# Generar Erlang-3 sumando 3 exponenciales
lambd = 2
n_muestras = 1000

erlang_samples = []
for _ in range(n_muestras):
    suma = 0
    for _ in range(3):  # Sumar 3 exponenciales
        R = np.random.random()
        suma += -np.log(R) / lambd
    erlang_samples.append(suma)

# Visualizar
plt.figure(figsize=(10, 6))
plt.hist(erlang_samples, bins=30, density=True, alpha=0.7, edgecolor='black', label='Simulado')

# PDF teórica Erlang-3
from scipy.stats import erlang
x = np.linspace(0, 5, 100)
pdf_teo = erlang.pdf(x, a=3, scale=1/lambd)
plt.plot(x, pdf_teo, 'r-', linewidth=2, label='Teórico')

plt.xlabel('X')
plt.ylabel('Densidad')
plt.title('Erlang-3: Suma de 3 Exponenciales')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

### Método 3: Composición

**Idea:** Mezclar distribuciones con probabilidades

```
X = { Y₁  con probabilidad p₁
    { Y₂  con probabilidad p₂
    { ...
```

**Ejemplo:** Hiperexponencial (mezcla de 2 exponenciales)

```python
# Hiperexponencial: 70% Exp(λ₁=5), 30% Exp(λ₂=0.5)
p1 = 0.7
lambda1, lambda2 = 5, 0.5
n_muestras = 1000

hiper_samples = []
for _ in range(n_muestras):
    R1 = np.random.random()
    R2 = np.random.random()
    
    if R1 < p1:
        # Usar primera exponencial
        X = -np.log(R2) / lambda1
    else:
        # Usar segunda exponencial
        X = -np.log(R2) / lambda2
    
    hiper_samples.append(X)

# Visualizar
plt.figure(figsize=(10, 6))
plt.hist(hiper_samples, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado')

# PDF teórica (mezcla)
x = np.linspace(0, 5, 1000)
pdf_teo = p1 * lambda1 * np.exp(-lambda1 * x) + (1-p1) * lambda2 * np.exp(-lambda2 * x)
plt.plot(x, pdf_teo, 'r-', linewidth=2, label='Teórico')

plt.xlabel('X')
plt.ylabel('Densidad')
plt.title('Hiperexponencial: Mezcla de 2 Exponenciales')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

## Criterios de Selección del Método

### Diagrama de Decisión

```
¿Existe F^(-1) en forma cerrada?
├─ SÍ → Usar TRANSFORMADA INVERSA
│        (Exp, Weibull, Uniforme, Triangular)
│
└─ NO → ¿Es suma de variables simples?
         ├─ SÍ → Usar CONVOLUCIÓN
         │        (Erlang, Binomial, Normal≈)
         │
         └─ NO → ¿Es mezcla de distribuciones?
                  ├─ SÍ → Usar COMPOSICIÓN
                  │        (Hiperexponencial, Mixtas)
                  │
                  └─ NO → Usar ACEPTACIÓN-RECHAZO
                           (Beta, Gamma, etc.)
```

### Tabla de Decisión por Distribución

| Distribución | Método Recomendado | Razón |
|--------------|-------------------|-------|
| **Exponencial** | Transformada Inversa | $F^{-1}$ simple: $-\ln(R)/\lambda$ |
| **Uniforme** | Transformada Inversa | $F^{-1}$ trivial: $a+(b-a)R$ |
| **Weibull** | Transformada Inversa | $F^{-1}$ existe: $\alpha(-\ln R)^{1/\beta}$ |
| **Normal** | Box-Muller (especial) | No tiene $F^{-1}$ simple |
| **Erlang** | Convolución | Suma de exponenciales |
| **Binomial** | Convolución | Suma de Bernoulli |
| **Hiperexponencial** | Composición | Mezcla de exponenciales |
| **Gamma** | Aceptación-Rechazo | No tiene $F^{-1}$ simple |
| **Beta** | Aceptación-Rechazo | No tiene $F^{-1}$ simple |

---

## Eficiencia Computacional

### Comparación de Tiempos de Ejecución

```python
import time

# Generar 100,000 variables exponenciales

# Método 1: Transformada Inversa
inicio = time.time()
for _ in range(100000):
    R = np.random.random()
    X = -np.log(R) / 2
tiempo_inversa = time.time() - inicio

# Método 2: Usando scipy (optimizado)
inicio = time.time()
from scipy.stats import expon
X = expon.rvs(scale=1/2, size=100000)
tiempo_scipy = time.time() - inicio

print(f"Transformada Inversa: {tiempo_inversa:.4f} segundos")
print(f"Scipy (optimizado): {tiempo_scipy:.4f} segundos")
print(f"Ratio: {tiempo_inversa/tiempo_scipy:.2f}x")
```

**Resultados típicos:**
- Transformada Inversa: ~0.15 segundos
- Scipy: ~0.005 segundos (30x más rápido)

**Lección:** Para producción, usar librerías optimizadas. Para aprendizaje, implementar manualmente.

---

## Validación de Métodos

### Checklist de Validación

Para cualquier método de generación, verificar:

1. **Media:** $\bar{X} \approx E[X]$
2. **Varianza:** $s^2 \approx \text{Var}(X)$
3. **Bondad de ajuste:** Prueba Chi-cuadrada o Kolmogorov-Smirnov
4. **Inspección visual:** Histograma vs PDF teórica

### Función de Validación Completa

```python
def validar_generador_completo(muestras, distribucion_teorica, nombre=''):
    """
    Validación completa de un generador de variables aleatorias.
    
    Args:
        muestras: Array de valores generados
        distribucion_teorica: Objeto de scipy.stats
        nombre: Nombre de la distribución
    """
    from scipy import stats
    
    print(f"{'='*60}")
    print(f"VALIDACIÓN: {nombre}")
    print(f"{'='*60}\n")
    
    # 1. Estadísticos básicos
    media_sim = np.mean(muestras)
    var_sim = np.var(muestras, ddof=1)
    media_teo = distribucion_teorica.mean()
    var_teo = distribucion_teorica.var()
    
    print(f"1. ESTADÍSTICOS BÁSICOS:")
    print(f"   Media:    Teórica={media_teo:.4f}, Simulada={media_sim:.4f}, Error={abs(media_sim-media_teo):.4f}")
    print(f"   Varianza: Teórica={var_teo:.4f}, Simulada={var_sim:.4f}, Error={abs(var_sim-var_teo):.4f}\n")
    
    # 2. Prueba de Kolmogorov-Smirnov
    d_stat, p_ks = stats.kstest(muestras, distribucion_teorica.cdf)
    print(f"2. PRUEBA KOLMOGOROV-SMIRNOV:")
    print(f"   D estadístico: {d_stat:.4f}")
    print(f"   P-value: {p_ks:.4f}")
    print(f"   Resultado: {'✓ PASA (p>0.05)' if p_ks > 0.05 else '✗ FALLA (p≤0.05)'}\n")
    
    # 3. Visualización
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))
    
    # Histograma
    ax1.hist(muestras, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado')
    x = np.linspace(muestras.min(), muestras.max(), 1000)
    pdf_teo = distribucion_teorica.pdf(x)
    ax1.plot(x, pdf_teo, 'r-', linewidth=2, label='Teórico')
    ax1.set_xlabel('X')
    ax1.set_ylabel('Densidad')
    ax1.set_title('Histograma vs PDF Teórica')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    
    # Q-Q Plot
    stats.probplot(muestras, dist=distribucion_teorica, plot=ax2)
    ax2.set_title('Q-Q Plot')
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()
    
    # 4. Veredicto final
    print(f"3. VEREDICTO FINAL:")
    error_media_rel = abs(media_sim - media_teo) / media_teo * 100
    error_var_rel = abs(var_sim - var_teo) / var_teo * 100
    
    if p_ks > 0.05 and error_media_rel < 5 and error_var_rel < 10:
        print(f"   ✓ GENERADOR VÁLIDO")
    else:
        print(f"   ✗ GENERADOR SOSPECHOSO - Revisar implementación")
    
    print(f"{'='*60}\n")

# Ejemplo de uso
from scipy.stats import expon

# Generar exponenciales
lambd = 2
muestras = -np.log(np.random.random(10000)) / lambd

# Validar
dist_teo = expon(scale=1/lambd)
validar_generador_completo(muestras, dist_teo, nombre='Exponencial(λ=2)')
```

---

## Mapa de Contenido de la Sección 3.4

Para dominar la generación de variables aleatorias, estudiaremos en detalle:

1. **[3.4.1] Método de la Transformada Inversa**
   - Fundamento teórico
   - Derivación paso a paso
   - Ejemplos: Exponencial, Weibull, Triangular
   - Código completo

2. **[3.4.2] Método de Convolución**
   - Principio de suma de variables
   - Ejemplos: Erlang, Binomial
   - Eficiencia vs precisión
   - Código completo

3. **[3.4.3] Método de Composición**
   - Mezclas de distribuciones
   - Ejemplos: Hiperexponencial
   - Aplicaciones en modelado
   - Código completo

---

## Ejercicio Integrador

**Problema:** Implementar y comparar los 3 métodos para generar una distribución Erlang-5 con $\lambda = 2$.

**Método 1: Transformada Inversa** (requiere inversión numérica de CDF)
**Método 2: Convolución** (sumar 5 exponenciales)
**Método 3: Usar scipy** (referencia)

Comparar:
- Tiempo de ejecución
- Precisión (media y varianza)
- Complejidad de implementación

**Solución:**

```python
# Método 1: Convolución (el más apropiado para Erlang)
def erlang_convolucion(k, lambd, size):
    resultados = []
    for _ in range(size):
        suma = 0
        for _ in range(k):
            R = np.random.random()
            suma += -np.log(R) / lambd
        resultados.append(suma)
    return np.array(resultados)

# Método 2: Scipy (referencia)
from scipy.stats import erlang

k, lambd = 5, 2
n = 10000

# Comparar
import time

# Convolución
inicio = time.time()
muestras_conv = erlang_convolucion(k, lambd, n)
tiempo_conv = time.time() - inicio

# Scipy
inicio = time.time()
muestras_scipy = erlang.rvs(a=k, scale=1/lambd, size=n)
tiempo_scipy = time.time() - inicio

# Resultados
print(f"COMPARACIÓN DE MÉTODOS:")
print(f"\nConvolución:")
print(f"  Tiempo: {tiempo_conv:.4f}s")
print(f"  Media: {np.mean(muestras_conv):.4f} (teórica: {k/lambd:.4f})")
print(f"  Varianza: {np.var(muestras_conv):.4f} (teórica: {k/lambd**2:.4f})")

print(f"\nScipy:")
print(f"  Tiempo: {tiempo_scipy:.4f}s")
print(f"  Media: {np.mean(muestras_scipy):.4f}")
print(f"  Varianza: {np.var(muestras_scipy):.4f}")

print(f"\nRatio de velocidad: {tiempo_conv/tiempo_scipy:.2f}x")
```

---

## Resumen y Mejores Prácticas

**Conceptos Clave:**
- Transformada Inversa: $X = F^{-1}(R)$ - Método universal cuando existe $F^{-1}$
- Convolución: $X = \sum Y_i$ - Suma de variables simples
- Composición: Mezcla de distribuciones con probabilidades

**Recomendaciones:**
1. Preferir Transformada Inversa cuando $F^{-1}$ existe en forma cerrada
2. Usar Convolución para distribuciones que son sumas naturales
3. Usar Composición para modelar heterogeneidad
4. Siempre validar con media, varianza y pruebas de bondad de ajuste
5. Para producción, usar librerías optimizadas (scipy, numpy)

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Law & Kelton (1991), Devroye (1986), Ross (2014)*


---

<div align="center">

⬅️ [3.3 VA Continuas](3.3.md) &nbsp;&nbsp;|&nbsp;&nbsp; [3.4.1 Transformada Inversa](3.4.1.md) ➡️

</div>
