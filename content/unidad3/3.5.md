# 3.5 Procedimientos especiales

Existen técnicas especializadas para distribuciones que no se ajustan fácilmente a los métodos estándar (transformada inversa, convolución, composición). Estos procedimientos son esenciales para generar variables de distribuciones complejas como Normal, Gamma, Beta, y Poisson.

---

## Método de Aceptación-Rechazo

### Concepto

El método de aceptación-rechazo es una técnica universal que funciona cuando:
- La CDF $F^{-1}$ no tiene forma cerrada
- Podemos evaluar la PDF $f(x)$
- Podemos encontrar una función "envoltura" $g(x)$ fácil de generar

**Idea geométrica:** Generar puntos aleatorios bajo una curva y aceptar solo los que caen bajo $f(x)$.

### Algoritmo General

**Paso 1:** Encontrar una función $g(x)$ (fácil de generar) y una constante $c$ tal que:
$$f(x) \leq c \cdot g(x) \quad \forall x$$

**Paso 2:** Generar $Y$ de $g(x)$

**Paso 3:** Generar $R \sim U[0,1]$

**Paso 4:** Calcular la razón de aceptación:
$$\rho = \frac{f(Y)}{c \cdot g(Y)}$$

**Paso 5:** Si $R \leq \rho$, aceptar $X = Y$. Si no, rechazar y volver al Paso 2.

**Eficiencia:** La probabilidad de aceptación es $1/c$, por lo que $c$ debe ser lo más pequeño posible.

### Ejemplo: Distribución Beta(2,2)

**PDF objetivo:**
$$f(x) = 6x(1-x), \quad 0 \leq x \leq 1$$

**Función envoltura:** $g(x) = 1$ (Uniforme[0,1])

**Constante:** $c = \max f(x) = f(0.5) = 1.5$

```python
import numpy as np
import matplotlib.pyplot as plt

def generar_beta_22_rechazo(size=1):
    """Genera Beta(2,2) usando aceptación-rechazo"""
    resultados = []
    rechazos = 0
    
    while len(resultados) < size:
        # Generar candidato de U[0,1]
        Y = np.random.random()
        R = np.random.random()
        
        # f(y) = 6y(1-y), c*g(y) = 1.5*1
        rho = 6*Y*(1-Y) / 1.5
        
        if R <= rho:
            resultados.append(Y)
        else:
            rechazos += 1
    
    tasa_aceptacion = size / (size + rechazos)
    print(f"Tasa de aceptación: {tasa_aceptacion*100:.1f}% (teórica: {1/1.5*100:.1f}%)")
    
    return np.array(resultados)

# Generar
muestras = generar_beta_22_rechazo(10000)

# Verificar
from scipy.stats import beta
dist_teo = beta(a=2, b=2)

print(f"Media teórica: {dist_teo.mean():.4f}")
print(f"Media simulada: {np.mean(muestras):.4f}")

# Visualizar
plt.figure(figsize=(12, 5))

# Histograma
plt.subplot(1, 2, 1)
plt.hist(muestras, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado')

x = np.linspace(0, 1, 1000)
pdf_teo = dist_teo.pdf(x)
plt.plot(x, pdf_teo, 'r-', linewidth=2, label='Teórico')

plt.xlabel('x')
plt.ylabel('Densidad')
plt.title('Beta(2,2): Aceptación-Rechazo')
plt.legend()
plt.grid(True, alpha=0.3)

# Visualizar envoltura
plt.subplot(1, 2, 2)
plt.plot(x, pdf_teo, 'b-', linewidth=2, label='f(x) = 6x(1-x)')
plt.axhline(y=1.5, color='r', linestyle='--', linewidth=2, label='c*g(x) = 1.5')
plt.fill_between(x, pdf_teo, alpha=0.3)
plt.xlabel('x')
plt.ylabel('Densidad')
plt.title('Función Objetivo y Envoltura')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

---

## Método de Box-Muller (Normal)

### Fundamento Teórico

El método de Box-Muller transforma dos variables uniformes independientes en dos variables normales estándar independientes.

**Teorema:** Si $R_1, R_2 \sim U[0,1]$ independientes, entonces:

$$Z_1 = \sqrt{-2\ln(R_1)}\cos(2\pi R_2)$$
$$Z_2 = \sqrt{-2\ln(R_1)}\sin(2\pi R_2)$$

donde $Z_1, Z_2 \sim N(0,1)$ independientes.

Para generar $X \sim N(\mu, \sigma^2)$:
$$X = \mu + \sigma Z_1$$

### Implementación

```python
def generar_normal_box_muller(mu, sigma, size=1):
    """Genera variables normales usando Box-Muller"""
    # Generar pares
    n_pares = (size + 1) // 2
    
    R1 = np.random.random(n_pares)
    R2 = np.random.random(n_pares)
    
    # Transformación Box-Muller
    Z1 = np.sqrt(-2 * np.log(R1)) * np.cos(2 * np.pi * R2)
    Z2 = np.sqrt(-2 * np.log(R1)) * np.sin(2 * np.pi * R2)
    
    # Combinar y transformar
    Z = np.concatenate([Z1, Z2])[:size]
    X = mu + sigma * Z
    
    return X

# Ejemplo
mu, sigma = 100, 15
muestras = generar_normal_box_muller(mu, sigma, size=10000)

# Verificar
from scipy.stats import norm

print(f"Media teórica: {mu:.2f}")
print(f"Media simulada: {np.mean(muestras):.2f}")
print(f"Desv.Est. teórica: {sigma:.2f}")
print(f"Desv.Est. simulada: {np.std(muestras):.2f}")

# Visualizar
plt.figure(figsize=(10, 6))
plt.hist(muestras, bins=50, density=True, alpha=0.7, edgecolor='black', label='Simulado')

x = np.linspace(mu - 4*sigma, mu + 4*sigma, 1000)
pdf_teo = norm.pdf(x, mu, sigma)
plt.plot(x, pdf_teo, 'r-', linewidth=2, label='Teórico')

plt.xlabel('x')
plt.ylabel('Densidad')
plt.title('Normal(100, 15): Box-Muller')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

---

## Método Polar de Marsaglia

### Concepto

Alternativa más eficiente a Box-Muller que evita el cálculo de funciones trigonométricas.

### Algoritmo

```python
def generar_normal_polar(mu, sigma, size=1):
    """Genera variables normales usando método polar de Marsaglia"""
    resultados = []
    
    while len(resultados) < size:
        # Generar punto en cuadrado [-1,1] × [-1,1]
        U1 = 2*np.random.random() - 1
        U2 = 2*np.random.random() - 1
        
        S = U1**2 + U2**2
        
        # Aceptar solo si está dentro del círculo unitario
        if 0 < S < 1:
            factor = np.sqrt(-2 * np.log(S) / S)
            Z1 = U1 * factor
            Z2 = U2 * factor
            
            resultados.append(mu + sigma * Z1)
            if len(resultados) < size:
                resultados.append(mu + sigma * Z2)
    
    return np.array(resultados[:size])

# Comparar eficiencia
import time

n = 10000

# Box-Muller
inicio = time.time()
muestras_bm = generar_normal_box_muller(100, 15, n)
tiempo_bm = time.time() - inicio

# Polar
inicio = time.time()
muestras_polar = generar_normal_polar(100, 15, n)
tiempo_polar = time.time() - inicio

print(f"Box-Muller: {tiempo_bm:.4f}s")
print(f"Polar: {tiempo_polar:.4f}s")
print(f"Ratio: {tiempo_bm/tiempo_polar:.2f}x")
```

---

## Generación de Poisson

### Método de Búsqueda Secuencial (λ pequeño)

**Algoritmo de Knuth:**

```python
def generar_poisson_knuth(lambd, size=1):
    """Genera Poisson usando algoritmo de Knuth (para λ pequeño)"""
    resultados = []
    
    L = np.exp(-lambd)
    
    for _ in range(size):
        k = 0
        p = 1
        
        while p > L:
            k += 1
            u = np.random.random()
            p *= u
        
        resultados.append(k - 1)
    
    return np.array(resultados)

# Ejemplo
lambd = 5
muestras = generar_poisson_knuth(lambd, size=10000)

# Verificar
from scipy.stats import poisson

print(f"Media teórica: {lambd:.2f}")
print(f"Media simulada: {np.mean(muestras):.2f}")
print(f"Varianza teórica: {lambd:.2f}")
print(f"Varianza simulada: {np.var(muestras):.2f}")

# Visualizar
plt.figure(figsize=(10, 6))
plt.hist(muestras, bins=range(0, 16), density=True, alpha=0.7, edgecolor='black', align='left', label='Simulado')

x = np.arange(0, 16)
pmf_teo = poisson.pmf(x, lambd)
plt.plot(x, pmf_teo, 'ro-', linewidth=2, markersize=8, label='Teórico')

plt.xlabel('k')
plt.ylabel('Probabilidad')
plt.title(f'Poisson(λ={lambd}): Método de Knuth')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```

### Aproximación Normal (λ grande)

Para $\lambda \geq 10$, Poisson se aproxima a Normal:

$$X \sim \text{Poisson}(\lambda) \approx N(\lambda, \lambda)$$

```python
def generar_poisson_normal(lambd, size=1):
    """Genera Poisson usando aproximación normal (para λ grande)"""
    # Generar normales
    X_normal = generar_normal_box_muller(lambd, np.sqrt(lambd), size)
    
    # Redondear y asegurar no negativos
    X_poisson = np.maximum(0, np.round(X_normal)).astype(int)
    
    return X_poisson

# Ejemplo con λ grande
lambd_grande = 50
muestras_normal = generar_poisson_normal(lambd_grande, size=10000)

print(f"Media teórica: {lambd_grande:.2f}")
print(f"Media simulada: {np.mean(muestras_normal):.2f}")
```

---

## Generación de Gamma

### Método de Ahrens-Dieter (α < 1)

```python
def generar_gamma_ahrens(alpha, beta, size=1):
    """Genera Gamma con α < 1 usando Ahrens-Dieter"""
    resultados = []
    
    while len(resultados) < size:
        U = np.random.random()
        V = np.random.random()
        
        if U <= (np.e / (np.e + alpha)):
            X = V**(1/alpha)
            if np.random.random() <= np.exp(-X):
                resultados.append(X / beta)
        else:
            X = -np.log((1-V))
            if np.random.random() <= X**(alpha-1):
                resultados.append(X / beta)
    
    return np.array(resultados)

# Ejemplo
alpha, beta = 0.5, 2
muestras = generar_gamma_ahrens(alpha, beta, size=10000)

from scipy.stats import gamma
dist_teo = gamma(a=alpha, scale=1/beta)

print(f"Media teórica: {dist_teo.mean():.4f}")
print(f"Media simulada: {np.mean(muestras):.4f}")
```

---

## Ejercicios Prácticos

### Ejercicio 1: Comparar Box-Muller vs Polar

Compare la eficiencia de ambos métodos para generar 100,000 variables normales.

### Ejercicio 2: Implementar Aceptación-Rechazo para Beta(3,2)

Derive la constante $c$ óptima y la función envoltura.

---

## Resumen

**Métodos Especiales:**
- Aceptación-Rechazo: Universal, funciona para cualquier PDF
- Box-Muller: Específico para Normal
- Polar: Más eficiente que Box-Muller
- Knuth: Poisson con λ pequeño
- Aproximación Normal: Poisson con λ grande

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Devroye (1986), Marsaglia & Bray (1964), Knuth (1997)*


---

<div align="center">

⬅️ [3.4.3 Composición](3.4.3.md) &nbsp;&nbsp;|&nbsp;&nbsp; [3.6 Pruebas Estadísticas](3.6.md) ➡️

</div>
