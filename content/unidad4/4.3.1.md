# 4.3.1 Sistemas de Líneas de Espera

Las líneas de espera (queueing systems) son uno de los casos más comunes en simulación, aplicables a manufactura, servicios, telecomunicaciones y sistemas computacionales. Esta sección cubre la teoría fundamental y su implementación práctica.

---

## Notación de Kendall

Un sistema de colas se describe como **A/B/c/K/N/D** donde:
- **A**: Distribución de tiempos entre llegadas
- **B**: Distribución de tiempos de servicio
- **c**: Número de servidores
- **K**: Capacidad del sistema (opcional, ∞ por defecto)
- **N**: Tamaño de la población (opcional, ∞ por defecto)
- **D**: Disciplina de la cola (opcional, FIFO por defecto)

**Códigos de distribución:**
- **M**: Markoviana (Exponencial) - "Memoryless"
- **D**: Determinística (constante)
- **E_k**: Erlang con parámetro k
- **H_k**: Hiperexponencial con parámetro k
- **G**: General (cualquier distribución)

**Ejemplos de notación:**
- **M/M/1**: Llegadas exponenciales, servicio exponencial, 1 servidor
- **M/M/c**: Llegadas exponenciales, servicio exponencial, c servidores
- **M/G/1**: Llegadas exponenciales, servicio general, 1 servidor
- **M/M/1/K**: M/M/1 con capacidad máxima K
- **M/M/c/K/N**: c servidores, capacidad K, población N

**Disciplinas de cola (D):**
- **FIFO** (First In First Out): El primero en llegar es el primero en ser atendido
- **LIFO** (Last In First Out): El último en llegar es el primero
- **SIRO** (Service In Random Order): Orden aleatorio
- **Priority**: Basado en prioridades

---

## Sistema M/M/1

El modelo más básico y fundamental de teoría de colas.

### Parámetros

- $\lambda$: Tasa de llegada (clientes/hora)
- $\mu$: Tasa de servicio (clientes/hora)
- $\rho = \lambda/\mu$: Factor de utilización (intensidad de tráfico)

### Condición de Estabilidad

$$\rho < 1$$

Si $\rho \geq 1$, la cola crece indefinidamente (sistema inestable).

### Métricas de Desempeño (Estado Estable)

**Probabilidad de n clientes en el sistema:**
$$P_n = (1-\rho)\rho^n$$

**Probabilidad de sistema vacío:**
$$P_0 = 1 - \rho$$

**Número de clientes:**
$$L = \frac{\rho}{1-\rho} \quad \text{(en sistema)}$$
$$L_q = \frac{\rho^2}{1-\rho} \quad \text{(en cola)}$$

**Tiempos:**
$$W = \frac{1}{\mu-\lambda} = \frac{1}{\mu(1-\rho)} \quad \text{(en sistema)}$$
$$W_q = \frac{\rho}{\mu-\lambda} = \frac{\rho}{\mu(1-\rho)} \quad \text{(en cola)}$$

**Ley de Little:**
$$L = \lambda W \quad \text{y} \quad L_q = \lambda W_q$$

### Ejemplo Numérico Completo

**Datos:**
- Llegadas: $\lambda = 3$ clientes/hora
- Servicio: $\mu = 4$ clientes/hora

**Cálculos:**
- $\rho = 3/4 = 0.75$ (75% de utilización)
- $P_0 = 1 - 0.75 = 0.25$ (25% del tiempo vacío)
- $L = 0.75/(1-0.75) = 3$ clientes en sistema
- $L_q = 0.75^2/(1-0.75) = 2.25$ clientes en cola
- $W = 1/(4-3) = 1$ hora = 60 minutos en sistema
- $W_q = 0.75/(4-3) = 0.75$ horas = 45 minutos en cola

**Interpretación:**
- En promedio hay 3 clientes en el sistema
- De esos 3, aproximadamente 2.25 están esperando
- Un cliente pasa 60 minutos total (45 esperando + 15 en servicio)
- El servidor está ocupado el 75% del tiempo

### Implementación Completa en SimPy

```python
import simpy
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats

class SistemaMM1:
    """Simulador completo de sistema M/M/1 con estadísticas detalladas"""
    
    def __init__(self, lambd, mu, tiempo_sim, semilla=None):
        self.lambd = lambd
        self.mu = mu
        self.tiempo_sim = tiempo_sim
        
        if semilla:
            np.random.seed(semilla)
        
        # Estadísticas
        self.tiempos_espera = []
        self.tiempos_sistema = []
        self.tiempos_servicio = []
        self.clientes_atendidos = 0
        self.clientes_generados = 0
        
        # Para calcular L(t) y Lq(t)
        self.historia_sistema = []
        self.historia_cola = []
        
    def cliente(self, env, nombre, servidor):
        """Proceso de un cliente"""
        self.clientes_generados += 1
        llegada = env.now
        
        # Registrar llegada
        n_en_cola = len(servidor.queue)
        n_en_sistema = len(servidor.queue) + len(servidor.users)
        
        with servidor.request() as req:
            yield req
            
            # Tiempo de espera
            espera = env.now - llegada
            self.tiempos_espera.append(espera)
            
            # Tiempo de servicio exponencial
            tiempo_servicio = np.random.exponential(1/self.mu)
            self.tiempos_servicio.append(tiempo_servicio)
            
            yield env.timeout(tiempo_servicio)
            
            # Tiempo total en sistema
            tiempo_total = env.now - llegada
            self.tiempos_sistema.append(tiempo_total)
            self.clientes_atendidos += 1
    
    def generador(self, env, servidor):
        """Genera clientes con llegadas Poisson"""
        i = 0
        while True:
            # Tiempo entre llegadas exponencial
            tiempo_entre_llegadas = np.random.exponential(1/self.lambd)
            yield env.timeout(tiempo_entre_llegadas)
            
            i += 1
            env.process(self.cliente(env, f'Cliente {i}', servidor))
    
    def monitor(self, env, servidor):
        """Monitorea el sistema periódicamente"""
        while True:
            n_en_sistema = len(servidor.queue) + len(servidor.users)
            n_en_cola = len(servidor.queue)
            
            self.historia_sistema.append((env.now, n_en_sistema))
            self.historia_cola.append((env.now, n_en_cola))
            
            yield env.timeout(0.1)  # Muestrear cada 0.1 unidades
    
    def ejecutar(self):
        """Ejecutar simulación"""
        env = simpy.Environment()
        servidor = simpy.Resource(env, capacity=1)
        
        env.process(self.generador(env, servidor))
        env.process(self.monitor(env, servidor))
        
        env.run(until=self.tiempo_sim)
        
        return self.obtener_estadisticas()
    
    def obtener_estadisticas(self):
        """Calcular estadísticas completas"""
        # Estadísticas simuladas
        Wq_sim = np.mean(self.tiempos_espera)
        W_sim = np.mean(self.tiempos_sistema)
        Lq_sim = self.lambd * Wq_sim  # Ley de Little
        L_sim = self.lambd * W_sim
        
        # Estadísticas teóricas
        rho = self.lambd / self.mu
        Wq_teo = rho / (self.mu * (1 - rho))
        W_teo = 1 / (self.mu - self.lambd)
        Lq_teo = rho**2 / (1 - rho)
        L_teo = rho / (1 - rho)
        
        return {
            # Simulación
            'clientes_generados': self.clientes_generados,
            'clientes_atendidos': self.clientes_atendidos,
            'Wq_sim': Wq_sim,
            'W_sim': W_sim,
            'Lq_sim': Lq_sim,
            'L_sim': L_sim,
            'rho_sim': self.clientes_atendidos / (self.tiempo_sim * self.mu),
            
            # Teoría
            'Wq_teo': Wq_teo,
            'W_teo': W_teo,
            'Lq_teo': Lq_teo,
            'L_teo': L_teo,
            'rho_teo': rho,
            
            # Errores
            'error_Wq': abs(Wq_sim - Wq_teo) / Wq_teo * 100,
            'error_W': abs(W_sim - W_teo) / W_teo * 100,
            'error_Lq': abs(Lq_sim - Lq_teo) / Lq_teo * 100,
            'error_L': abs(L_sim - L_teo) / L_teo * 100
        }
    
    def graficar_resultados(self):
        """Generar gráficos de análisis"""
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        
        # 1. Histograma de tiempos de espera
        ax = axes[0, 0]
        ax.hist(self.tiempos_espera, bins=30, density=True, alpha=0.7, edgecolor='black')
        ax.set_xlabel('Tiempo de Espera')
        ax.set_ylabel('Densidad')
        ax.set_title('Distribución de Tiempos de Espera')
        ax.grid(True, alpha=0.3)
        
        # 2. Histograma de tiempos en sistema
        ax = axes[0, 1]
        ax.hist(self.tiempos_sistema, bins=30, density=True, alpha=0.7, edgecolor='black')
        ax.set_xlabel('Tiempo en Sistema')
        ax.set_ylabel('Densidad')
        ax.set_title('Distribución de Tiempos en Sistema')
        ax.grid(True, alpha=0.3)
        
        # 3. Evolución de clientes en sistema
        ax = axes[1, 0]
        tiempos, valores = zip(*self.historia_sistema)
        ax.plot(tiempos, valores, linewidth=0.5)
        ax.axhline(y=self.lambd/(self.mu-self.lambd), color='r', linestyle='--', label='Teórico')
        ax.set_xlabel('Tiempo')
        ax.set_ylabel('Clientes en Sistema')
        ax.set_title('Evolución de L(t)')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # 4. Evolución de clientes en cola
        ax = axes[1, 1]
        tiempos, valores = zip(*self.historia_cola)
        ax.plot(tiempos, valores, linewidth=0.5)
        rho = self.lambd / self.mu
        ax.axhline(y=rho**2/(1-rho), color='r', linestyle='--', label='Teórico')
        ax.set_xlabel('Tiempo')
        ax.set_ylabel('Clientes en Cola')
        ax.set_title('Evolución de Lq(t)')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()

# Ejemplo de uso completo
print("="*60)
print("SIMULACIÓN M/M/1")
print("="*60)

lambd, mu = 3, 4
sistema = SistemaMM1(lambd, mu, tiempo_sim=1000, semilla=42)
stats = sistema.ejecutar()

print(f"\nPARÁMETROS:")
print(f"  λ (llegadas): {lambd} clientes/hora")
print(f"  μ (servicio): {mu} clientes/hora")
print(f"  Tiempo de simulación: 1000 horas")

print(f"\nRESULTADOS:")
print(f"  Clientes generados: {stats['clientes_generados']}")
print(f"  Clientes atendidos: {stats['clientes_atendidos']}")

print(f"\nUTILIZACIÓN:")
print(f"  Simulada: {stats['rho_sim']:.4f} ({stats['rho_sim']*100:.2f}%)")
print(f"  Teórica:  {stats['rho_teo']:.4f} ({stats['rho_teo']*100:.2f}%)")

print(f"\nTIEMPO EN COLA (Wq):")
print(f"  Simulado: {stats['Wq_sim']:.4f} horas = {stats['Wq_sim']*60:.2f} min")
print(f"  Teórico:  {stats['Wq_teo']:.4f} horas = {stats['Wq_teo']*60:.2f} min")
print(f"  Error:    {stats['error_Wq']:.2f}%")

print(f"\nTIEMPO EN SISTEMA (W):")
print(f"  Simulado: {stats['W_sim']:.4f} horas = {stats['W_sim']*60:.2f} min")
print(f"  Teórico:  {stats['W_teo']:.4f} horas = {stats['W_teo']*60:.2f} min")
print(f"  Error:    {stats['error_W']:.2f}%")

print(f"\nCLIENTES EN COLA (Lq):")
print(f"  Simulado: {stats['Lq_sim']:.4f}")
print(f"  Teórico:  {stats['Lq_teo']:.4f}")
print(f"  Error:    {stats['error_Lq']:.2f}%")

print(f"\nCLIENTES EN SISTEMA (L):")
print(f"  Simulado: {stats['L_sim']:.4f}")
print(f"  Teórico:  {stats['L_teo']:.4f}")
print(f"  Error:    {stats['error_L']:.2f}%")

# Generar gráficos
sistema.graficar_resultados()
```

---

## Sistema M/M/c

Múltiples servidores en paralelo con una cola común.

### Parámetros

- $c$: Número de servidores
- $\rho = \frac{\lambda}{c\mu}$: Utilización por servidor

### Condición de Estabilidad

$$\rho < 1 \quad \text{(equivalente a } \lambda < c\mu \text{)}$$

### Métricas de Desempeño

**Probabilidad de 0 clientes:**
$$P_0 = \left[\sum_{n=0}^{c-1}\frac{(\lambda/\mu)^n}{n!} + \frac{(\lambda/\mu)^c}{c!}\frac{1}{1-\rho}\right]^{-1}$$

**Probabilidad de esperar (Fórmula C de Erlang):**
$$P(W_q > 0) = C(c, \lambda/\mu) = \frac{(\lambda/\mu)^c}{c!(1-\rho)} P_0$$

**Clientes en cola:**
$$L_q = \frac{P_0(\lambda/\mu)^c\rho}{c!(1-\rho)^2}$$

**Tiempo en cola:**
$$W_q = \frac{L_q}{\lambda}$$

**Clientes en sistema:**
$$L = L_q + \frac{\lambda}{\mu}$$

**Tiempo en sistema:**
$$W = W_q + \frac{1}{\mu}$$

### Implementación en SimPy

```python
class SistemaMMC:
    """Simulador de sistema M/M/c"""
    
    def __init__(self, lambd, mu, c, tiempo_sim):
        self.lambd = lambd
        self.mu = mu
        self.c = c
        self.tiempo_sim = tiempo_sim
        self.tiempos_espera = []
        self.tiempos_sistema = []
        self.clientes_atendidos = 0
    
    def cliente(self, env, nombre, servidores):
        llegada = env.now
        
        with servidores.request() as req:
            yield req
            espera = env.now - llegada
            self.tiempos_espera.append(espera)
            
            tiempo_servicio = np.random.exponential(1/self.mu)
            yield env.timeout(tiempo_servicio)
            
            self.tiempos_sistema.append(env.now - llegada)
            self.clientes_atendidos += 1
    
    def generador(self, env, servidores):
        i = 0
        while True:
            yield env.timeout(np.random.exponential(1/self.lambd))
            i += 1
            env.process(self.cliente(env, f'Cliente {i}', servidores))
    
    def ejecutar(self):
        env = simpy.Environment()
        servidores = simpy.Resource(env, capacity=self.c)
        env.process(self.generador(env, servidores))
        env.run(until=self.tiempo_sim)
        
        return self.obtener_estadisticas()
    
    def obtener_estadisticas(self):
        Wq_sim = np.mean(self.tiempos_espera)
        W_sim = np.mean(self.tiempos_sistema)
        Lq_sim = self.lambd * Wq_sim
        L_sim = self.lambd * W_sim
        
        return {
            'clientes': self.clientes_atendidos,
            'Wq': Wq_sim,
            'W': W_sim,
            'Lq': Lq_sim,
            'L': L_sim,
            'rho': self.lambd / (self.c * self.mu)
        }

# Ejemplo: Call center con 3 agentes
print("\n" + "="*60)
print("CALL CENTER M/M/3")
print("="*60)

lambd, mu, c = 10, 4, 3
sistema = SistemaMMC(lambd, mu, c, tiempo_sim=1000)
stats = sistema.ejecutar()

print(f"\nCONFIGURACIÓN:")
print(f"  Llegadas: {lambd} llamadas/hora")
print(f"  Servicio: {mu} llamadas/hora por agente")
print(f"  Agentes: {c}")

print(f"\nRESULTADOS:")
print(f"  Utilización: {stats['rho']:.2%}")
print(f"  Tiempo de espera promedio: {stats['Wq']*60:.2f} minutos")
print(f"  Tiempo en sistema promedio: {stats['W']*60:.2f} minutos")
print(f"  Clientes en cola promedio: {stats['Lq']:.2f}")
print(f"  Clientes en sistema promedio: {stats['L']:.2f}")
```

---

## Caso de Estudio 1: Hospital - Sala de Emergencias

### Escenario

**Hospital Regional San José:**
- Llegadas de pacientes: Poisson con $\lambda = 5$ pacientes/hora
- Tiempo de atención: Exponencial con $\mu = 6$ pacientes/hora por médico
- Actualmente: 1 médico de guardia
- **Objetivo:** Tiempo de espera < 30 minutos en el 90% de los casos

### Análisis Actual (M/M/1)

```python
# Configuración actual
lambd, mu = 5, 6
rho = lambd / mu

print("CONFIGURACIÓN ACTUAL (1 médico):")
print(f"  ρ = {rho:.3f} ({rho*100:.1f}% utilización)")

Wq = rho / (mu * (1 - rho))
print(f"  Wq promedio = {Wq*60:.1f} minutos")

# Distribución de Wq es exponencial con parámetro μ(1-ρ)
prob_mayor_30 = 1 - np.exp(-mu*(1-rho)*0.5)  # 0.5 horas = 30 min
print(f"  P(Wq > 30 min) = {prob_mayor_30*100:.1f}%")
print(f"  ❌ NO cumple objetivo (debe ser <10%)")
```

**Resultado:**
- $\rho = 0.833$ (83.3% utilización)
- $W_q = 50$ minutos promedio
- P(Wq > 30 min) ≈ 37%
- **❌ No cumple objetivo**

### Propuesta: Agregar 1 Médico (M/M/2)

```python
# Simular M/M/2
sistema_propuesto = SistemaMMC(lambd=5, mu=6, c=2, tiempo_sim=10000)
stats = sistema_propuesto.ejecutar()

print("\nPROPUESTA (2 médicos):")
print(f"  ρ = {stats['rho']:.3f} ({stats['rho']*100:.1f}% utilización)")
print(f"  Wq promedio = {stats['Wq']*60:.1f} minutos")

# Calcular percentil 90
tiempos_ordenados = sorted(sistema_propuesto.tiempos_espera)
percentil_90 = tiempos_ordenados[int(len(tiempos_ordenados)*0.9)]
print(f"  Percentil 90 de Wq = {percentil_90*60:.1f} minutos")
print(f"  ✅ CUMPLE objetivo")
```

**Resultado esperado:**
- $\rho = 0.417$ (41.7% utilización)
- $W_q \approx 7$ minutos promedio
- Percentil 90 ≈ 15 minutos
- **✅ Cumple objetivo**

### Análisis Económico

```python
# Costos
costo_medico_hora = 50  # USD/hora
horas_dia = 24
dias_año = 365

# Configuración actual (1 médico)
costo_actual = 1 * costo_medico_hora * horas_dia * dias_año
print(f"\nCOSTO ACTUAL (1 médico):")
print(f"  ${costo_actual:,.0f}/año")

# Configuración propuesta (2 médicos)
costo_propuesto = 2 * costo_medico_hora * horas_dia * dias_año
costo_adicional = costo_propuesto - costo_actual
print(f"\nCOSTO PROPUESTO (2 médicos):")
print(f"  ${costo_propuesto:,.0f}/año")
print(f"  Costo adicional: ${costo_adicional:,.0f}/año")

# Beneficios
pacientes_año = lambd * horas_dia * dias_año
reduccion_espera = (50 - 7) / 60  # horas
valor_tiempo_paciente = 20  # USD/hora

ahorro_total = pacientes_año * reduccion_espera * valor_tiempo_paciente
print(f"\nBENEFICIOS:")
print(f"  Pacientes/año: {pacientes_año:,.0f}")
print(f"  Reducción de espera: {reduccion_espera*60:.0f} min/paciente")
print(f"  Ahorro total: ${ahorro_total:,.0f}/año")

beneficio_neto = ahorro_total - costo_adicional
print(f"\nBENEFICIO NETO: ${beneficio_neto:,.0f}/año")
print(f"ROI: {beneficio_neto/costo_adicional*100:.1f}%")
```

**Resultado:**
- Costo adicional: $438,000/año
- Ahorro en tiempo: $630,000/año
- **Beneficio neto: $192,000/año**
- **ROI: 44%**
- **✅ Inversión justificada**

---

## Caso de Estudio 2: Banco - Optimización de Cajeros

### Escenario

**Banco Metropolitano:**
- Sucursal atiende 200 clientes/día promedio
- Horario: 9am - 5pm (8 horas)
- Tiempo de servicio: 5 minutos promedio
- Actualmente: 3 cajeros
- **Objetivo:** Minimizar costo total (cajeros + espera)

### Análisis

```python
# Parámetros
clientes_dia = 200
horas_dia = 8
lambd = clientes_dia / horas_dia  # 25 clientes/hora
mu = 60 / 5  # 12 clientes/hora (5 min/cliente)

# Costos
costo_cajero_hora = 15  # USD/hora
valor_tiempo_cliente = 25  # USD/hora

# Probar diferentes configuraciones
resultados = []

for c in range(2, 7):
    sistema = SistemaMMC(lambd, mu, c, tiempo_sim=1000)
    stats = sistema.ejecutar()
    
    # Costos diarios
    costo_cajeros = c * costo_cajero_hora * horas_dia
    costo_espera = stats['Wq'] * lambd * horas_dia * valor_tiempo_cliente
    costo_total = costo_cajeros + costo_espera
    
    resultados.append({
        'cajeros': c,
        'utilizacion': stats['rho'],
        'Wq_min': stats['Wq'] * 60,
        'Lq': stats['Lq'],
        'costo_cajeros': costo_cajeros,
        'costo_espera': costo_espera,
        'costo_total': costo_total
    })

# Mostrar resultados
df = pd.DataFrame(resultados)
print("\nANÁLISIS DE CONFIGURACIONES:")
print(df.to_string(index=False))

# Encontrar óptimo
optimo = df.loc[df['costo_total'].idxmin()]
print(f"\n✓ CONFIGURACIÓN ÓPTIMA:")
print(f"  Cajeros: {optimo['cajeros']:.0f}")
print(f"  Utilización: {optimo['utilizacion']:.1%}")
print(f"  Tiempo de espera: {optimo['Wq_min']:.1f} min")
print(f"  Costo total/día: ${optimo['costo_total']:.2f}")
```

---

## Ejercicios Prácticos

### Ejercicio 1: Servidor Web

Un servidor web recibe:
- Requests: 100/segundo
- Tiempo de proceso: Exponencial(8 ms promedio)

**a)** Modele como M/M/1. ¿Cuál es la utilización?

**b)** ¿Cuál es el tiempo de respuesta promedio?

**c)** Si el SLA requiere 95% de requests <50ms, ¿cumple?

**d)** ¿Cuántos servidores se necesitan para utilización <70%?

### Ejercicio 2: Supermercado

Un supermercado tiene:
- Llegadas: 20 clientes/hora
- Servicio: 5 minutos/cliente (determinístico)
- 4 cajas

**a)** Modele como M/D/4 (use simulación, no hay fórmulas simples)

**b)** Calcule tiempo de espera promedio

**c)** ¿Cuántas cajas se necesitan para Wq < 2 minutos?

### Ejercicio 3: Centro de Llamadas

Un call center tiene:
- Llamadas: Poisson(50/hora)
- Tiempo de atención: Exponencial(4 min)
- 15 agentes
- 20% de llamadas abandonan si esperan >3 minutos

**a)** Modele el sistema (considere abandonos)

**b)** ¿Cuál es el porcentaje de abandonos?

**c)** ¿Cuántos agentes se necesitan para <10% abandonos?

---

## Resumen

**Cuándo usar fórmulas analíticas:**
- Sistema simple (M/M/1, M/M/c)
- Solo interesa estado estable
- Respuesta rápida para análisis preliminar

**Cuándo usar simulación:**
- Distribuciones no exponenciales (M/G/1, G/G/c)
- Lógica compleja (prioridades, bloqueos, abandonos)
- Comportamiento transitorio
- Validación de fórmulas
- Análisis de sensibilidad

**Métricas clave:**
- **L, Lq**: Clientes en sistema/cola
- **W, Wq**: Tiempo en sistema/cola
- **ρ**: Utilización (debe ser <1)
- **P0**: Probabilidad de sistema vacío

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Gross & Harris (2008), Banks et al. (2010), Law (2015)*


---

<div align="center">

⬅️ [4.3 Casos Prácticos](4.3.md) &nbsp;&nbsp;|&nbsp;&nbsp; [4.3.2 Inventarios](4.3.2.md) ➡️

</div>
