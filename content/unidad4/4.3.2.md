# 4.3.2 Sistemas de Inventarios

Los sistemas de inventarios controlan el nivel de existencias para satisfacer demanda minimizando costos. Esta sección cubre las políticas fundamentales de inventario y su implementación mediante simulación.

---

## Componentes de un Sistema de Inventario

### Variables de Decisión

- **Q**: Cantidad de pedido (cuánto ordenar)
- **R**: Punto de reorden (cuándo ordenar)
- **S**: Nivel máximo de inventario (en políticas (s,S))
- **T**: Periodo de revisión (en políticas periódicas)

### Parámetros del Sistema

**Costos:**
- **c**: Costo unitario del producto
- **K**: Costo fijo por pedido (setup cost)
- **h**: Costo de mantener inventario (holding cost, por unidad por periodo)
- **p**: Costo de faltante (stockout cost, por unidad faltante)
- **b**: Costo de pedido atrasado (backorder cost)

**Demanda:**
- **D**: Demanda por periodo (puede ser determinística o estocástica)
- **L**: Lead time (tiempo entre ordenar y recibir)

### Eventos Principales

1. **Llegada de demanda**: Cliente solicita producto
2. **Revisión de inventario**: Verificar nivel actual
3. **Generación de pedido**: Ordenar al proveedor
4. **Llegada de pedido**: Recibir reabastecimiento

### Métricas de Desempeño

- **Nivel promedio de inventario**: $\bar{I}$
- **Frecuencia de faltantes**: Veces que inventario = 0
- **Tasa de servicio**: % de demanda satisfecha inmediatamente
- **Costo total**: $TC = \text{Costo pedidos} + \text{Costo mantenimiento} + \text{Costo faltantes}$

---

## Políticas de Inventario

### 1. Política (Q,R) - Cantidad Fija, Punto de Reorden

**Regla:** Cuando el inventario cae a R o menos, ordenar Q unidades.

**Características:**
- Revisión continua del inventario
- Cantidad de pedido constante
- Momento de pedido variable

**Ejemplo:**
- R = 50 unidades
- Q = 200 unidades
- Cuando inventario ≤ 50, ordenar 200

**Ventajas:**
- Simple de implementar
- Cantidad de pedido optimizable (EOQ)

**Desventajas:**
- Requiere monitoreo continuo
- No aprovecha economías de escala variables

### 2. Política (s,S) - Mínimo-Máximo

**Regla:** Cuando el inventario cae a s o menos, ordenar hasta alcanzar S.

**Características:**
- Cantidad de pedido variable: $Q = S - I_{actual}$
- Útil cuando hay costos fijos altos

**Ejemplo:**
- s = 30 unidades
- S = 150 unidades
- Si inventario = 25, ordenar 150 - 25 = 125 unidades

**Ventajas:**
- Aprovecha economías de escala
- Mantiene inventario en rango deseado

**Desventajas:**
- Más compleja que (Q,R)
- Requiere determinar dos parámetros

### 3. Política de Revisión Periódica (T,S)

**Regla:** Cada T periodos, revisar inventario y ordenar hasta alcanzar S.

**Características:**
- Revisión periódica (no continua)
- Cantidad de pedido variable
- Momento de pedido fijo

**Ejemplo:**
- T = 7 días (revisar semanalmente)
- S = 200 unidades
- Cada lunes, ordenar hasta 200

**Ventajas:**
- Fácil de coordinar con proveedores
- Menor costo administrativo

**Desventajas:**
- Puede tener faltantes entre revisiones
- Requiere mayor inventario de seguridad

---

## Modelo EOQ (Economic Order Quantity)

Modelo determinístico para encontrar Q óptimo cuando:
- Demanda es constante y conocida
- Lead time es constante
- No hay faltantes
- Costos son constantes

### Fórmula EOQ

$$Q^* = \sqrt{\frac{2DK}{h}}$$

donde:
- D: Demanda anual
- K: Costo por pedido
- h: Costo de mantener por unidad por año

### Derivación

**Costo total anual:**
$$TC(Q) = \underbrace{\frac{D}{Q}K}_{\text{Costo pedidos}} + \underbrace{\frac{Q}{2}h}_{\text{Costo mantenimiento}}$$

**Minimizar:**
$$\frac{d(TC)}{dQ} = -\frac{DK}{Q^2} + \frac{h}{2} = 0$$

**Resolver:**
$$Q^* = \sqrt{\frac{2DK}{h}}$$

### Ejemplo Numérico

**Datos:**
- D = 10,000 unidades/año
- K = $100/pedido
- h = $5/unidad/año
- c = $20/unidad

**Cálculos:**
$$Q^* = \sqrt{\frac{2 \times 10000 \times 100}{5}} = \sqrt{400000} = 632.46 \approx 632 \text{ unidades}$$

**Número de pedidos por año:**
$$N = \frac{D}{Q^*} = \frac{10000}{632} = 15.82 \approx 16 \text{ pedidos}$$

**Tiempo entre pedidos:**
$$T = \frac{365}{N} = \frac{365}{16} = 22.8 \text{ días}$$

**Costo total anual:**
$$TC = \frac{10000}{632} \times 100 + \frac{632}{2} \times 5 = 1582 + 1580 = \$3,162$$

**Punto de reorden (con lead time):**
Si lead time L = 5 días:
$$R = D \times L = \frac{10000}{365} \times 5 = 137 \text{ unidades}$$

### Implementación en Python

```python
import numpy as np
import matplotlib.pyplot as plt

def calcular_eoq(D, K, h):
    """Calcular cantidad económica de pedido"""
    Q_star = np.sqrt(2 * D * K / h)
    return Q_star

def costo_total_eoq(Q, D, K, h):
    """Calcular costo total para una cantidad Q"""
    costo_pedidos = (D / Q) * K
    costo_mantenimiento = (Q / 2) * h
    return costo_pedidos + costo_mantenimiento

# Parámetros
D = 10000  # unidades/año
K = 100    # $/pedido
h = 5      # $/unidad/año

# Calcular EOQ
Q_star = calcular_eoq(D, K, h)
print(f"EOQ: {Q_star:.0f} unidades")

# Graficar costos
Q_values = np.linspace(100, 1500, 100)
TC_values = [costo_total_eoq(Q, D, K, h) for Q in Q_values]
costo_pedidos = [(D/Q)*K for Q in Q_values]
costo_mant = [(Q/2)*h for Q in Q_values]

plt.figure(figsize=(10, 6))
plt.plot(Q_values, TC_values, 'b-', linewidth=2, label='Costo Total')
plt.plot(Q_values, costo_pedidos, 'r--', label='Costo Pedidos')
plt.plot(Q_values, costo_mant, 'g--', label='Costo Mantenimiento')
plt.axvline(x=Q_star, color='k', linestyle=':', label=f'EOQ = {Q_star:.0f}')
plt.xlabel('Cantidad de Pedido (Q)')
plt.ylabel('Costo Anual ($)')
plt.title('Modelo EOQ: Análisis de Costos')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

print(f"\nCosto total mínimo: ${costo_total_eoq(Q_star, D, K, h):.2f}/año")
```

---

## Simulación de Inventarios Estocásticos

Cuando la demanda es variable, se requiere simulación.

### Implementación Completa en SimPy

```python
import simpy
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

class SistemaInventario:
    """Simulador de sistema de inventario con política (Q,R)"""
    
    def __init__(self, Q, R, S_inicial, demanda_media, lead_time_media, 
                 costo_pedido, costo_mant, costo_faltante, tiempo_sim):
        self.Q = Q
        self.R = R
        self.inventario = S_inicial
        self.demanda_media = demanda_media
        self.lead_time_media = lead_time_media
        self.costo_pedido = costo_pedido
        self.costo_mant = costo_mant
        self.costo_faltante = costo_faltante
        self.tiempo_sim = tiempo_sim
        
        # Estadísticas
        self.historia_inventario = []
        self.faltantes = []
        self.pedidos_realizados = 0
        self.demanda_total = 0
        self.demanda_satisfecha = 0
        self.pedido_pendiente = False
        
    def proceso_demanda(self, env):
        """Genera demanda de clientes"""
        while True:
            # Tiempo entre demandas (Poisson)
            yield env.timeout(np.random.exponential(1/self.demanda_media))
            
            # Cantidad demandada (asumimos 1 unidad por simplicidad)
            cantidad = 1
            self.demanda_total += cantidad
            
            if self.inventario >= cantidad:
                # Satisfacer demanda
                self.inventario -= cantidad
                self.demanda_satisfecha += cantidad
            else:
                # Faltante
                faltante = cantidad - self.inventario
                self.faltantes.append((env.now, faltante))
                self.inventario = 0
            
            # Revisar si se debe ordenar (política Q,R)
            if self.inventario <= self.R and not self.pedido_pendiente:
                env.process(self.realizar_pedido(env))
    
    def realizar_pedido(self, env):
        """Proceso de pedido y reabastecimiento"""
        self.pedido_pendiente = True
        self.pedidos_realizados += 1
        
        # Lead time (tiempo hasta recibir pedido)
        lead_time = np.random.exponential(self.lead_time_media)
        yield env.timeout(lead_time)
        
        # Recibir pedido
        self.inventario += self.Q
        self.pedido_pendiente = False
    
    def monitor(self, env):
        """Monitorea el inventario periódicamente"""
        while True:
            self.historia_inventario.append((env.now, self.inventario))
            yield env.timeout(0.1)  # Muestrear cada 0.1 unidades de tiempo
    
    def ejecutar(self):
        """Ejecutar simulación"""
        env = simpy.Environment()
        env.process(self.proceso_demanda(env))
        env.process(self.monitor(env))
        env.run(until=self.tiempo_sim)
        
        return self.obtener_estadisticas()
    
    def obtener_estadisticas(self):
        """Calcular estadísticas del sistema"""
        # Inventario promedio
        tiempos, niveles = zip(*self.historia_inventario)
        inventario_promedio = np.mean(niveles)
        
        # Nivel de servicio
        nivel_servicio = self.demanda_satisfecha / self.demanda_total if self.demanda_total > 0 else 0
        
        # Costos
        costo_pedidos_total = self.pedidos_realizados * self.costo_pedido
        costo_mant_total = inventario_promedio * self.costo_mant * self.tiempo_sim
        costo_faltantes_total = sum(f[1] for f in self.faltantes) * self.costo_faltante
        costo_total = costo_pedidos_total + costo_mant_total + costo_faltantes_total
        
        return {
            'inventario_promedio': inventario_promedio,
            'nivel_servicio': nivel_servicio,
            'pedidos_realizados': self.pedidos_realizados,
            'demanda_total': self.demanda_total,
            'demanda_satisfecha': self.demanda_satisfecha,
            'num_faltantes': len(self.faltantes),
            'costo_pedidos': costo_pedidos_total,
            'costo_mantenimiento': costo_mant_total,
            'costo_faltantes': costo_faltantes_total,
            'costo_total': costo_total
        }
    
    def graficar_resultados(self):
        """Generar gráficos de análisis"""
        fig, axes = plt.subplots(2, 1, figsize=(12, 8))
        
        # 1. Evolución del inventario
        ax = axes[0]
        tiempos, niveles = zip(*self.historia_inventario)
        ax.plot(tiempos, niveles, linewidth=0.8)
        ax.axhline(y=self.R, color='r', linestyle='--', label=f'Punto de reorden (R={self.R})')
        ax.axhline(y=self.Q, color='g', linestyle='--', label=f'Cantidad de pedido (Q={self.Q})')
        ax.set_xlabel('Tiempo')
        ax.set_ylabel('Nivel de Inventario')
        ax.set_title('Evolución del Inventario')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # 2. Histograma de niveles de inventario
        ax = axes[1]
        ax.hist(niveles, bins=30, edgecolor='black', alpha=0.7)
        ax.axvline(x=np.mean(niveles), color='r', linestyle='--', linewidth=2, 
                   label=f'Promedio = {np.mean(niveles):.1f}')
        ax.set_xlabel('Nivel de Inventario')
        ax.set_ylabel('Frecuencia')
        ax.set_title('Distribución de Niveles de Inventario')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()

# Ejemplo de uso
print("="*60)
print("SIMULACIÓN DE INVENTARIO (Q,R)")
print("="*60)

# Parámetros
Q = 200          # Cantidad de pedido
R = 50           # Punto de reorden
S_inicial = 150  # Inventario inicial
demanda_media = 10  # Demanda promedio por unidad de tiempo
lead_time_media = 5  # Lead time promedio
costo_pedido = 100
costo_mant = 2    # Por unidad por unidad de tiempo
costo_faltante = 50  # Por unidad faltante

# Ejecutar simulación
sistema = SistemaInventario(Q, R, S_inicial, demanda_media, lead_time_media,
                           costo_pedido, costo_mant, costo_faltante, tiempo_sim=365)
stats = sistema.ejecutar()

# Mostrar resultados
print(f"\nPARÁMETROS:")
print(f"  Q (cantidad pedido): {Q}")
print(f"  R (punto reorden): {R}")
print(f"  Inventario inicial: {S_inicial}")
print(f"  Demanda media: {demanda_media}/día")
print(f"  Lead time medio: {lead_time_media} días")

print(f"\nRESULTADOS:")
print(f"  Inventario promedio: {stats['inventario_promedio']:.2f} unidades")
print(f"  Nivel de servicio: {stats['nivel_servicio']:.2%}")
print(f"  Pedidos realizados: {stats['pedidos_realizados']}")
print(f"  Demanda total: {stats['demanda_total']:.0f}")
print(f"  Demanda satisfecha: {stats['demanda_satisfecha']:.0f}")
print(f"  Número de faltantes: {stats['num_faltantes']}")

print(f"\nCOSTOS:")
print(f"  Costo pedidos: ${stats['costo_pedidos']:.2f}")
print(f"  Costo mantenimiento: ${stats['costo_mantenimiento']:.2f}")
print(f"  Costo faltantes: ${stats['costo_faltantes']:.2f}")
print(f"  COSTO TOTAL: ${stats['costo_total']:.2f}")

# Graficar
sistema.graficar_resultados()
```

---

## Caso de Estudio 1: Supermercado - Gestión de Inventario

### Escenario

**Supermercado "El Ahorro":**
- Producto: Leche (SKU #12345)
- Demanda: Poisson(λ=50 unidades/día)
- Lead time: 2 días (determinístico)
- Costo producto: $2/unidad
- Costo pedido: $50
- Costo mantenimiento: $0.10/unidad/día (5% del costo anual)
- Costo faltante: $5/unidad (venta perdida + insatisfacción)
- **Objetivo:** Nivel de servicio > 95%

### Análisis con EOQ

```python
# Parámetros anuales
D_anual = 50 * 365  # 18,250 unidades/año
K = 50
h_anual = 0.10 * 365  # $36.5/unidad/año

# Calcular EOQ
Q_eoq = calcular_eoq(D_anual, K, h_anual)
print(f"EOQ: {Q_eoq:.0f} unidades")

# Punto de reorden (demanda durante lead time)
L = 2  # días
R = 50 * L  # 100 unidades

print(f"Punto de reorden: {R} unidades")
```

### Simulación

```python
# Simular con política EOQ
sistema_eoq = SistemaInventario(
    Q=int(Q_eoq), R=R, S_inicial=int(Q_eoq),
    demanda_media=50, lead_time_media=2,
    costo_pedido=50, costo_mant=0.10, costo_faltante=5,
    tiempo_sim=365
)

stats_eoq = sistema_eoq.ejecutar()

print("\nRESULTADOS CON EOQ:")
print(f"  Nivel de servicio: {stats_eoq['nivel_servicio']:.2%}")
print(f"  Costo total/año: ${stats_eoq['costo_total']:.2f}")

if stats_eoq['nivel_servicio'] < 0.95:
    print("  ❌ NO cumple objetivo de servicio")
    print("  Solución: Aumentar R (inventario de seguridad)")
else:
    print("  ✅ Cumple objetivo")
```

### Optimización

```python
# Probar diferentes valores de R para lograr 95% servicio
resultados_opt = []

for R_test in range(80, 150, 10):
    sistema_test = SistemaInventario(
        Q=int(Q_eoq), R=R_test, S_inicial=int(Q_eoq),
        demanda_media=50, lead_time_media=2,
        costo_pedido=50, costo_mant=0.10, costo_faltante=5,
        tiempo_sim=365
    )
    stats_test = sistema_test.ejecutar()
    
    resultados_opt.append({
        'R': R_test,
        'nivel_servicio': stats_test['nivel_servicio'],
        'inventario_prom': stats_test['inventario_promedio'],
        'costo_total': stats_test['costo_total']
    })

df_opt = pd.DataFrame(resultados_opt)
print("\nOPTIMIZACIÓN DE R:")
print(df_opt.to_string(index=False))

# Encontrar R mínimo que cumple objetivo
R_optimo = df_opt[df_opt['nivel_servicio'] >= 0.95]['R'].min()
print(f"\n✓ R óptimo: {R_optimo} unidades")
```

---

## Caso de Estudio 2: Manufactura - MRP Simplificado

### Escenario

**Fábrica de Bicicletas:**
- Producto final: Bicicleta
- Componente crítico: Ruedas (2 por bicicleta)
- Demanda de bicicletas: Normal(μ=100, σ=20) por semana
- Lead time ruedas: 3 semanas
- Costo pedido: $500
- Costo mantenimiento: $1/rueda/semana
- **Política:** (s,S) con s=300, S=800

### Implementación

```python
class SistemaInventarioManufactura:
    """Sistema de inventario para manufactura con BOM"""
    
    def __init__(self, s, S, S_inicial, demanda_media, demanda_std,
                 bom_ratio, lead_time, tiempo_sim):
        self.s = s
        self.S = S
        self.inventario = S_inicial
        self.demanda_media = demanda_media
        self.demanda_std = demanda_std
        self.bom_ratio = bom_ratio  # Componentes por producto final
        self.lead_time = lead_time
        self.tiempo_sim = tiempo_sim
        
        self.pedidos = []
        self.faltantes = 0
        self.historia = []
    
    def proceso_produccion(self, env):
        """Proceso de producción semanal"""
        semana = 0
        while True:
            yield env.timeout(1)  # 1 semana
            semana += 1
            
            # Demanda de productos finales
            demanda_productos = max(0, int(np.random.normal(self.demanda_media, self.demanda_std)))
            
            # Demanda de componentes
            demanda_componentes = demanda_productos * self.bom_ratio
            
            if self.inventario >= demanda_componentes:
                self.inventario -= demanda_componentes
            else:
                self.faltantes += (demanda_componentes - self.inventario)
                self.inventario = 0
            
            # Política (s,S)
            if self.inventario <= self.s:
                cantidad_ordenar = self.S - self.inventario
                env.process(self.recibir_pedido(env, cantidad_ordenar))
            
            self.historia.append((env.now, self.inventario))
    
    def recibir_pedido(self, env, cantidad):
        """Recibir pedido después del lead time"""
        yield env.timeout(self.lead_time)
        self.inventario += cantidad
        self.pedidos.append((env.now, cantidad))
    
    def ejecutar(self):
        env = simpy.Environment()
        env.process(self.proceso_produccion(env))
        env.run(until=self.tiempo_sim)
        
        tiempos, niveles = zip(*self.historia)
        return {
            'inventario_promedio': np.mean(niveles),
            'pedidos_realizados': len(self.pedidos),
            'faltantes_total': self.faltantes
        }

# Simular
sistema_mfg = SistemaInventarioManufactura(
    s=300, S=800, S_inicial=600,
    demanda_media=100, demanda_std=20,
    bom_ratio=2, lead_time=3, tiempo_sim=52  # 1 año = 52 semanas
)

stats_mfg = sistema_mfg.ejecutar()

print("\nMANUFACTURA - SISTEMA (s,S):")
print(f"  Inventario promedio: {stats_mfg['inventario_promedio']:.0f} ruedas")
print(f"  Pedidos realizados: {stats_mfg['pedidos_realizados']}")
print(f"  Faltantes totales: {stats_mfg['faltantes_total']:.0f} ruedas")
```

---

## Ejercicios Prácticos

### Ejercicio 1: Farmacia

Una farmacia vende un medicamento con:
- Demanda: Poisson(λ=15 unidades/día)
- Lead time: 5 días
- Costo pedido: $30
- Costo mantenimiento: $0.50/unidad/día
- Costo faltante: $10/unidad

**a)** Calcule EOQ asumiendo demanda determinística

**b)** Simule con política (Q,R) donde Q=EOQ y R=demanda durante lead time

**c)** ¿Qué nivel de servicio se logra?

**d)** Ajuste R para lograr 98% de servicio

### Ejercicio 2: E-commerce

Amazon maneja un producto con:
- Demanda: 1000 unidades/día
- Lead time: Uniforme(2,4) días
- Política actual: (Q,R) con Q=5000, R=3000

**a)** Simule el sistema por 365 días

**b)** Calcule inventario promedio y nivel de servicio

**c)** Proponga una política (s,S) alternativa

**d)** Compare costos de ambas políticas

---

## Resumen

**Políticas de inventario:**
- **(Q,R)**: Cantidad fija, punto de reorden
- **(s,S)**: Mínimo-máximo
- **(T,S)**: Revisión periódica

**Modelo EOQ:**
- Útil para demanda determinística
- Fórmula: $Q^* = \sqrt{2DK/h}$
- Base para políticas estocásticas

**Simulación es necesaria cuando:**
- Demanda es estocástica
- Lead time es variable
- Múltiples productos con restricciones
- Políticas complejas

**Métricas clave:**
- Inventario promedio
- Nivel de servicio
- Costo total

---

*Referencia: Programa SCD-1022 - TecNM*
*Fuentes: Silver et al. (1998), Nahmias (2015), Zipkin (2000)*


---

<div align="center">

⬅️ [4.3.1 Líneas de Espera](4.3.1.md) &nbsp;&nbsp;|&nbsp;&nbsp; [4.4 Validación](4.4.md) ➡️

</div>
