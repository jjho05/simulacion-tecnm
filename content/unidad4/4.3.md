# 4.3 Aplicación de un lenguaje o simulador a un caso específico

Esta sección demuestra cómo aplicar herramientas de simulación a dos casos fundamentales: **sistemas de líneas de espera** y **sistemas de inventarios**. Ambos son pilares de la investigación de operaciones y tienen aplicaciones directas en manufactura, servicios, logística y comercio.

---

## Importancia de los Casos de Estudio

### ¿Por qué estos dos sistemas?

**1. Líneas de Espera (Queueing Systems):**
- **Servicios:** Bancos, hospitales, call centers, restaurantes
- **Manufactura:** Estaciones de trabajo, líneas de producción, inspección
- **Tecnología:** Servidores web, redes de telecomunicaciones, bases de datos
- **Transporte:** Aeropuertos, peajes, estaciones de servicio

**Impacto económico:**
- Tiempo de espera = Costo de oportunidad
- Utilización de recursos = Eficiencia operativa
- Nivel de servicio = Satisfacción del cliente

**2. Sistemas de Inventarios:**
- **Retail:** Tiendas departamentales, supermercados, e-commerce
- **Manufactura:** Materias primas, work-in-process, productos terminados
- **Logística:** Centros de distribución, almacenes
- **Salud:** Medicamentos, suministros médicos

**Impacto económico:**
- Inventario = Capital inmovilizado
- Faltantes = Ventas perdidas
- Obsolescencia = Pérdidas directas

### Estadísticas de Impacto

**Líneas de espera:**
- El 75% de los clientes abandona si espera >10 minutos (retail)
- Reducir espera de 5 a 3 minutos puede aumentar ventas 15%
- Costo de espera en aeropuertos: $30 billones/año (USA)

**Inventarios:**
- Inventario promedio en retail: 30-40% del capital de trabajo
- Costo de faltantes: 4-5% de ventas anuales
- Reducción de 10% en inventario libera millones en capital

---

## Metodología de Aplicación

### Paso 1: Entender el Sistema Real

**Actividades:**
1. **Observación directa:** Visitar el sitio, cronometrar procesos
2. **Entrevistas:** Hablar con operadores, gerentes, clientes
3. **Recolección de datos:** Tiempos, llegadas, demanda histórica
4. **Identificación de componentes:**
   - Entidades (clientes, productos)
   - Recursos (servidores, almacenes)
   - Eventos (llegadas, servicios, pedidos)
   - Restricciones (capacidades, horarios)

**Ejemplo - Banco:**
```
Observaciones (1 semana):
- Llegadas: 15-25 clientes/hora (pico 12-2pm)
- Servicio: 3-8 minutos/cliente
- Cajeros: 4 (2 en horario valle)
- Abandonos: 5% cuando cola >10 personas
```

### Paso 2: Recolectar y Analizar Datos

**Datos necesarios:**

**Para colas:**
- Tiempos entre llegadas (100+ observaciones)
- Tiempos de servicio (100+ observaciones)
- Número de servidores
- Capacidad del sistema
- Prioridades (si aplica)

**Para inventarios:**
- Demanda diaria (6+ meses)
- Lead time de proveedores
- Costos (pedido, mantenimiento, faltante)
- Restricciones de almacenamiento

**Herramientas de análisis:**

```python
import numpy as np
import pandas as pd
from scipy import stats
import matplotlib.pyplot as plt

# Ejemplo: Analizar tiempos entre llegadas
datos_llegadas = [12, 8, 15, 6, 10, 14, 9, 11, 7, 13]  # minutos

# Estadísticas descriptivas
print(f"Media: {np.mean(datos_llegadas):.2f} min")
print(f"Desv.Est: {np.std(datos_llegadas):.2f} min")

# Ajustar distribución exponencial
lambd_estimado = 1/np.mean(datos_llegadas)
print(f"Lambda estimado: {lambd_estimado:.4f} llegadas/min")

# Prueba de bondad de ajuste
ks_stat, p_value = stats.kstest(datos_llegadas, 'expon', args=(0, np.mean(datos_llegadas)))
print(f"K-S test p-value: {p_value:.4f}")

if p_value > 0.05:
    print("✓ Los datos se ajustan a distribución exponencial")
else:
    print("✗ Los datos NO se ajustan a distribución exponencial")

# Visualizar
plt.figure(figsize=(10, 5))
plt.hist(datos_llegadas, bins=10, density=True, alpha=0.7, edgecolor='black')
x = np.linspace(0, max(datos_llegadas), 100)
plt.plot(x, stats.expon.pdf(x, scale=np.mean(datos_llegadas)), 'r-', linewidth=2)
plt.xlabel('Tiempo entre llegadas (min)')
plt.ylabel('Densidad')
plt.title('Ajuste de Distribución')
plt.legend(['Exponencial teórica', 'Datos observados'])
plt.grid(True, alpha=0.3)
plt.show()
```

### Paso 3: Seleccionar Herramienta

**Criterios de decisión:**

| Característica del Sistema | Herramienta Recomendada |
|----------------------------|-------------------------|
| Sistema simple (M/M/1, EOQ) | Fórmulas analíticas |
| Sistema moderado (M/M/c, (Q,R)) | SimPy o Arena |
| Sistema complejo (redes, múltiples productos) | SimPy (flexibilidad) |
| Requiere presentación visual | Arena o AnyLogic |
| Presupuesto limitado | SimPy (gratis) |
| Equipo sin programación | Arena |

**Ejemplo de decisión:**

**Caso:** Centro de llamadas con 10 agentes, 3 niveles de prioridad, enrutamiento complejo

**Análisis:**
- ❌ Fórmulas analíticas: Demasiado complejo
- ✅ SimPy: Máxima flexibilidad para lógica compleja
- ⚠️ Arena: Posible pero limitado para enrutamiento complejo

**Decisión:** SimPy

### Paso 4: Construir Modelo

**Principio:** Comenzar simple, agregar complejidad gradualmente

**Versión 1:** Modelo básico
- Solo componentes esenciales
- Distribuciones simples (exponencial)
- Sin detalles menores

**Versión 2:** Agregar realismo
- Distribuciones ajustadas a datos
- Variabilidad en parámetros

**Versión 3:** Detalles operativos
- Prioridades
- Turnos de trabajo
- Fallas de equipo

**Ejemplo - Desarrollo incremental:**

```python
# VERSIÓN 1: M/M/1 básico
class ModeloV1:
    def cliente(self, env, servidor):
        with servidor.request() as req:
            yield req
            yield env.timeout(np.random.exponential(5))

# VERSIÓN 2: Agregar recolección de estadísticas
class ModeloV2:
    def __init__(self):
        self.tiempos_espera = []
    
    def cliente(self, env, servidor):
        llegada = env.now
        with servidor.request() as req:
            yield req
            self.tiempos_espera.append(env.now - llegada)
            yield env.timeout(np.random.exponential(5))

# VERSIÓN 3: Agregar prioridades
class ModeloV3:
    def cliente(self, env, servidor, prioridad):
        llegada = env.now
        with servidor.request(priority=prioridad) as req:
            yield req
            self.tiempos_espera.append(env.now - llegada)
            yield env.timeout(np.random.exponential(5))
```

### Paso 5: Verificar

**Checklist de verificación:**

- [ ] **Entidades se crean correctamente**
  - Verificar tasa de llegadas
  - Contar entidades generadas

- [ ] **Recursos se usan correctamente**
  - Verificar que se toman y liberan
  - No hay deadlocks

- [ ] **Lógica de proceso es correcta**
  - Entidades siguen el flujo esperado
  - Decisiones se toman correctamente

- [ ] **Estadísticas se recolectan**
  - Verificar que los datos se guardan
  - No hay valores faltantes

**Técnicas de verificación:**

```python
# 1. Ejecutar con pocos clientes
env = simpy.Environment()
# ... configurar modelo
env.run(until=10)  # Solo 10 unidades de tiempo

# 2. Imprimir eventos
def cliente_debug(env, nombre, servidor):
    print(f"{env.now:.2f}: {nombre} llega")
    with servidor.request() as req:
        yield req
        print(f"{env.now:.2f}: {nombre} inicia servicio")
        yield env.timeout(5)
        print(f"{env.now:.2f}: {nombre} termina")

# 3. Verificar balances
print(f"Clientes generados: {clientes_generados}")
print(f"Clientes atendidos: {clientes_atendidos}")
print(f"Clientes en sistema: {clientes_generados - clientes_atendidos}")
```

### Paso 6: Validar

**Validación = ¿El modelo representa la realidad?**

**Métodos:**

**1. Comparación con teoría (si existe):**

```python
# Para M/M/1
rho_sim = clientes_atendidos / (tiempo_sim * mu)
rho_teo = lambd / mu

error = abs(rho_sim - rho_teo) / rho_teo
assert error < 0.05, f"Utilización incorrecta: {error*100:.1f}% error"
```

**2. Comparación con datos reales:**

```python
# Comparar distribución de tiempos de espera
tiempos_reales = [...]  # Datos del sistema real
tiempos_simulados = [...]  # Datos de la simulación

# Prueba de Kolmogorov-Smirnov
ks_stat, p_value = stats.ks_2samp(tiempos_reales, tiempos_simulados)

if p_value > 0.05:
    print("✓ Modelo validado: distribuciones son similares")
else:
    print("✗ Modelo requiere ajustes")
```

**3. Validación con expertos:**
- Presentar resultados a operadores
- ¿Los resultados son creíbles?
- ¿Captura el comportamiento observado?

### Paso 7: Experimentar

**Diseño de experimentos:**

**Escenarios "What-If":**
- ¿Qué pasa si agregamos 1 servidor?
- ¿Qué pasa si la demanda aumenta 20%?
- ¿Qué pasa si reducimos el tiempo de servicio 10%?

**Ejemplo - Análisis de sensibilidad:**

```python
# Experimentar con diferentes números de servidores
resultados = []

for c in range(1, 6):
    sistema = SistemaMMC(lambd=10, mu=4, c=c, tiempo_sim=1000)
    stats = sistema.ejecutar()
    
    resultados.append({
        'servidores': c,
        'Wq': stats['Wq'],
        'utilizacion': 10/(c*4),
        'costo_espera': stats['Wq'] * 10 * 20,  # $20/hora valor tiempo
        'costo_servidores': c * 50 * 8,  # $50/hora por servidor, 8 horas
        'costo_total': stats['Wq'] * 10 * 20 + c * 50 * 8
    })

df = pd.DataFrame(resultados)
print(df)

# Encontrar óptimo
optimo = df.loc[df['costo_total'].idxmin()]
print(f"\nConfiguración óptima: {optimo['servidores']} servidores")
print(f"Costo total: ${optimo['costo_total']:.2f}")
```

---

## Estructura de esta Sección

### 4.3.1 Sistemas de Líneas de Espera

**Contenido:**
- Notación de Kendall (A/B/c/K/N/D)
- Sistemas M/M/1, M/M/c, M/G/1
- Fórmulas analíticas vs simulación
- Implementaciones completas en SimPy
- Casos reales:
  - Hospital (sala de emergencias)
  - Call center
  - Banco
  - Servidor web

**Métricas clave:**
- $L$: Clientes en sistema
- $L_q$: Clientes en cola
- $W$: Tiempo en sistema
- $W_q$: Tiempo en cola
- $\rho$: Utilización

### 4.3.2 Sistemas de Inventarios

**Contenido:**
- Políticas (Q,R), (s,S), revisión periódica
- Modelo EOQ y extensiones
- Simulación de inventarios estocásticos
- Casos reales:
  - Retail (supermercado)
  - Manufactura (MRP)
  - E-commerce (Amazon)
  - Farmacia

**Métricas clave:**
- Nivel promedio de inventario
- Frecuencia de faltantes
- Costo total
- Nivel de servicio

---

## Comparación: Líneas de Espera vs Inventarios

| Aspecto | Líneas de Espera | Inventarios |
|---------|------------------|-------------|
| **Entidades** | Clientes, trabajos, paquetes | Productos, SKUs, órdenes |
| **Recursos** | Servidores, cajeros, máquinas | Almacén, capital, espacio |
| **Eventos clave** | Llegada, inicio servicio, salida | Demanda, pedido, llegada stock |
| **Decisiones** | Cuántos servidores, prioridades | Cuánto ordenar, cuándo ordenar |
| **Métricas** | Tiempo espera, utilización | Nivel inventario, faltantes |
| **Complejidad** | Media | Media-Alta |
| **Teoría** | Extensa (teoría de colas) | Moderada (EOQ, newsvendor) |
| **Software** | SimPy, Arena, SIMUL8 | SimPy, Arena, Excel |

---

## Ejemplo Integrado: Sistema de Producción

Muchos sistemas reales combinan colas e inventarios.

**Escenario: Fábrica de Widgets**

**Componentes:**
1. **Estación de ensamble** (cola M/M/2)
   - Llegada de piezas: Poisson(λ=10/hora)
   - Tiempo de ensamble: Exponencial(μ=6/hora)
   - 2 máquinas

2. **Almacén de productos terminados** (inventario (Q,R))
   - Capacidad: 500 unidades
   - Política: R=100, Q=200
   - Demanda: Poisson(λ=8/hora)

3. **Pedidos de materia prima**
   - Lead time: Exponencial(24 horas)
   - Costo pedido: $500
   - Costo mantenimiento: $2/unidad/día

**Interacciones:**
- Productos ensamblados → Almacén
- Demanda de clientes ← Almacén
- Si inventario < R → Ordenar materias primas
- Materias primas → Estación de ensamble

**Implementación (esquema):**

```python
class SistemaIntegrado:
    def __init__(self, env):
        self.env = env
        self.maquinas = simpy.Resource(env, capacity=2)
        self.almacen = simpy.Container(env, capacity=500, init=200)
        self.pedido_pendiente = False
    
    def ensamble(self):
        """Proceso de ensamble"""
        while True:
            yield self.env.timeout(np.random.exponential(1/10))  # Llegada pieza
            
            with self.maquinas.request() as req:
                yield req
                yield self.env.timeout(np.random.exponential(1/6))  # Ensamblar
                
                # Agregar al almacén
                yield self.almacen.put(1)
    
    def demanda(self):
        """Proceso de demanda de clientes"""
        while True:
            yield self.env.timeout(np.random.exponential(1/8))  # Demanda
            
            if self.almacen.level > 0:
                yield self.almacen.get(1)  # Satisfacer
            else:
                # Faltante
                pass
            
            # Revisar política (Q,R)
            if self.almacen.level <= 100 and not self.pedido_pendiente:
                self.env.process(self.ordenar())
    
    def ordenar(self):
        """Proceso de pedido"""
        self.pedido_pendiente = True
        yield self.env.timeout(np.random.exponential(24))  # Lead time
        yield self.almacen.put(200)  # Llega pedido
        self.pedido_pendiente = False
```

Este tipo de sistema **requiere simulación** (no hay fórmulas analíticas).

---

## Herramientas Recomendadas por Caso

### Para Líneas de Espera

**Sistemas simples (M/M/1, M/M/c):**
- **Fórmulas analíticas** primero (respuesta inmediata)
- **SimPy** para validación y escenarios complejos
- **Arena** si se requiere animación para presentaciones

**Sistemas complejos (prioridades, redes, bloqueos):**
- **SimPy** (máxima flexibilidad, control total)
- **AnyLogic** (si se combina con otros paradigmas)

**Ejemplo de decisión:**
- Call center simple (M/M/c) → Fórmulas
- Call center con IVR, transferencias, abandonos → SimPy

### Para Inventarios

**Sistemas simples (EOQ, newsvendor):**
- **Fórmulas analíticas** (Excel suficiente)

**Sistemas estocásticos (demanda variable, lead time variable):**
- **SimPy** (control total, fácil experimentación)
- **Excel con VBA** (si el equipo no programa)

**Múltiples productos con restricciones:**
- **SimPy** o **Arena**
- **Software especializado** (SAP, Oracle)

---

## Ejercicio Integrador

**Diseñe un modelo que combine colas e inventarios:**

**Sistema: Tienda de Conveniencia**

**Componentes:**
1. **Caja registradora** (cola)
   - Llegadas: Poisson(λ=20 clientes/hora)
   - Servicio: Exponencial(μ=25 clientes/hora)
   - 1 cajero

2. **Inventario de productos**
   - 100 SKUs diferentes
   - Demanda: Poisson(λ=5 unidades/día por SKU)
   - Política: (Q,R) con R=20, Q=50
   - Lead time: 3 días

**Preguntas:**
1. ¿Cuál es el tiempo promedio de espera en caja?
2. ¿Cuál es el nivel promedio de inventario?
3. ¿Cuántos faltantes ocurren por semana?
4. ¿Cómo afecta agregar 1 cajero al inventario necesario?

---

## Recursos Adicionales

**Teoría de Colas:**
- Libro: "Fundamentals of Queueing Theory" - Gross & Harris
- Software: QTS (Queueing Theory Software)
- Online: http://www.supositorio.com/rcalc/rcalclite.htm

**Inventarios:**
- Libro: "Inventory Management and Production Planning" - Silver et al.
- Software: Inventory Analyst (Rockwell)
- Online: Calculadoras EOQ

**Simulación:**
- SimPy: https://simpy.readthedocs.io
- Arena: Rockwell University
- Cursos: Coursera "Simulation and Modeling"

---

## Resumen

**Aplicar simulación exitosamente requiere:**

1. **Entender el sistema real** profundamente
2. **Recolectar datos** de calidad
3. **Seleccionar herramienta** apropiada
4. **Construir incrementalmente** (simple → complejo)
5. **Verificar** lógica del modelo
6. **Validar** contra realidad
7. **Experimentar** sistemáticamente

**Casos fundamentales:**
- **Líneas de espera:** Optimizar recursos vs nivel de servicio
- **Inventarios:** Balancear costos vs disponibilidad

**Próximos pasos:**
- Estudiar 4.3.1 para dominar colas
- Estudiar 4.3.2 para dominar inventarios
- Practicar con casos reales de su industria

---

*Referencia: Programa SCD-1022 - TecNM*
*Las subsecciones 4.3.1 y 4.3.2 desarrollan estos temas en detalle con código completo y casos de estudio.*


---

<div align="center">

⬅️ [4.2 Aprendizaje](4.2.md) &nbsp;&nbsp;|&nbsp;&nbsp; [4.3.1 Líneas de Espera](4.3.1.md) ➡️

</div>
