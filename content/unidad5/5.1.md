# 5.1 An√°lisis y modelado de un sistema para su estudio mediante simulaci√≥n

Esta secci√≥n integra todos los conocimientos adquiridos en el curso para desarrollar un proyecto completo de simulaci√≥n. Es la culminaci√≥n del aprendizaje y demuestra la capacidad de aplicar simulaci√≥n a problemas reales del mundo industrial.

---

## Objetivo del Proyecto Integrador

Desarrollar un modelo de simulaci√≥n completo de un sistema real que permita:
1. **Analizar** el comportamiento actual del sistema
2. **Identificar** cuellos de botella y problemas
3. **Proponer** mejoras basadas en evidencia
4. **Validar** las propuestas mediante simulaci√≥n
5. **Comunicar** resultados a stakeholders

---

## Metodolog√≠a de 7 Fases

### Fase 1: Definici√≥n del Problema

**Objetivo:** Entender claramente qu√© se quiere resolver.

**Actividades:**
1. **Identificar el sistema a estudiar**
   - ¬øQu√© proceso/sistema se va a simular?
   - ¬øPor qu√© es importante estudiarlo?

2. **Definir objetivos espec√≠ficos**
   - ¬øQu√© preguntas se quieren responder?
   - ¬øQu√© decisiones se tomar√°n con los resultados?

3. **Establecer alcance**
   - ¬øQu√© se incluye en el modelo?
   - ¬øQu√© se excluye (y por qu√©)?

**Ejemplo:**

```markdown
## Definici√≥n del Problema

**Sistema:** L√≠nea de producci√≥n de ensamble de laptops

**Problema:** 
- Producci√≥n actual: 80 unidades/d√≠a
- Meta: 100 unidades/d√≠a
- Cuello de botella desconocido

**Objetivos:**
1. Identificar estaci√≥n limitante
2. Evaluar impacto de agregar 1 operador
3. Determinar configuraci√≥n √≥ptima

**Alcance:**
- Incluye: 5 estaciones de ensamble, 2 inspecciones
- Excluye: Almac√©n de materias primas, empaque final
```

### Fase 2: Recolecci√≥n de Datos

**Objetivo:** Obtener datos confiables del sistema real.

**Tipos de datos necesarios:**

**1. Tiempos de proceso:**
- Medir con cron√≥metro (100+ observaciones)
- Registros hist√≥ricos del MES/ERP
- Estudio de tiempos y movimientos

**2. Tiempos entre llegadas:**
- √ìrdenes de producci√≥n
- Llegadas de clientes
- Fallas de equipo

**3. Recursos:**
- N√∫mero de operadores
- N√∫mero de m√°quinas
- Capacidades de almacenamiento

**4. L√≥gica del sistema:**
- Reglas de prioridad
- Pol√≠ticas de inventario
- Turnos de trabajo

**Herramientas de recolecci√≥n:**

```python
import pandas as pd
import numpy as np
from datetime import datetime

# Template para recolecci√≥n de datos
datos_proceso = {
    'fecha': [],
    'estacion': [],
    'operador': [],
    'tiempo_inicio': [],
    'tiempo_fin': [],
    'tiempo_proceso': [],
    'unidades': [],
    'defectos': []
}

# Ejemplo de registro
datos_proceso['fecha'].append('2024-01-15')
datos_proceso['estacion'].append('Ensamble CPU')
datos_proceso['operador'].append('Juan P.')
datos_proceso['tiempo_inicio'].append('09:15:30')
datos_proceso['tiempo_fin'].append('09:22:45')
datos_proceso['tiempo_proceso'].append(7.25)  # minutos
datos_proceso['unidades'].append(1)
datos_proceso['defectos'].append(0)

# Convertir a DataFrame
df = pd.DataFrame(datos_proceso)
df.to_excel('datos_recolectados.xlsx', index=False)
```

**An√°lisis de datos:**

```python
# Estad√≠sticas descriptivas
print("=== AN√ÅLISIS DE TIEMPOS DE PROCESO ===")
print(f"Media: {df['tiempo_proceso'].mean():.2f} min")
print(f"Desv.Est: {df['tiempo_proceso'].std():.2f} min")
print(f"M√≠nimo: {df['tiempo_proceso'].min():.2f} min")
print(f"M√°ximo: {df['tiempo_proceso'].max():.2f} min")

# Ajustar distribuci√≥n
from scipy import stats

# Probar distribuci√≥n normal
stat, p_value = stats.shapiro(df['tiempo_proceso'])
print(f"\nPrueba de normalidad: p-value = {p_value:.4f}")

if p_value > 0.05:
    print("‚Üí Usar distribuci√≥n Normal")
    mu = df['tiempo_proceso'].mean()
    sigma = df['tiempo_proceso'].std()
    print(f"   N({mu:.2f}, {sigma:.2f})")
else:
    print("‚Üí Probar otras distribuciones (Lognormal, Weibull, etc.)")
```

### Fase 3: Construcci√≥n del Modelo

**Objetivo:** Traducir el sistema real a un modelo de simulaci√≥n.

**Pasos:**

**1. Seleccionar herramienta:**
- SimPy (flexibilidad, gratis)
- Arena (visual, presentaciones)
- AnyLogic (sistemas complejos)

**2. Desarrollar modelo conceptual:**

```
[Llegada √ìrdenes] ‚Üí [Cola] ‚Üí [Estaci√≥n 1] ‚Üí [Estaci√≥n 2] ‚Üí [Inspecci√≥n] ‚Üí [Salida]
                                  ‚Üì                ‚Üì              ‚Üì
                              [Operador 1]    [Operador 2]   [Inspector]
```

**3. Implementar modelo:**

```python
import simpy
import numpy as np

class LineaProduccion:
    """Modelo de l√≠nea de producci√≥n"""
    
    def __init__(self, env):
        self.env = env
        self.estacion1 = simpy.Resource(env, capacity=1)
        self.estacion2 = simpy.Resource(env, capacity=1)
        self.inspector = simpy.Resource(env, capacity=1)
        
        # Estad√≠sticas
        self.unidades_producidas = 0
        self.tiempos_ciclo = []
    
    def proceso_orden(self, orden_id):
        """Proceso completo de una orden"""
        llegada = self.env.now
        
        # Estaci√≥n 1
        with self.estacion1.request() as req:
            yield req
            tiempo_est1 = np.random.normal(7.5, 1.2)
            yield self.env.timeout(tiempo_est1)
        
        # Estaci√≥n 2
        with self.estacion2.request() as req:
            yield req
            tiempo_est2 = np.random.normal(6.8, 1.0)
            yield self.env.timeout(tiempo_est2)
        
        # Inspecci√≥n
        with self.inspector.request() as req:
            yield req
            tiempo_insp = np.random.normal(3.2, 0.5)
            yield self.env.timeout(tiempo_insp)
        
        # Completado
        tiempo_total = self.env.now - llegada
        self.tiempos_ciclo.append(tiempo_total)
        self.unidades_producidas += 1
    
    def generador_ordenes(self):
        """Genera √≥rdenes de producci√≥n"""
        orden_id = 0
        while True:
            yield self.env.timeout(6)  # Una orden cada 6 minutos
            orden_id += 1
            self.env.process(self.proceso_orden(orden_id))

# Ejecutar simulaci√≥n
env = simpy.Environment()
linea = LineaProduccion(env)
env.process(linea.generador_ordenes())
env.run(until=480)  # 8 horas = 480 minutos

print(f"Unidades producidas: {linea.unidades_producidas}")
print(f"Tiempo de ciclo promedio: {np.mean(linea.tiempos_ciclo):.2f} min")
```

### Fase 4: Verificaci√≥n

**Objetivo:** Asegurar que el modelo funciona correctamente (sin errores de programaci√≥n).

**Checklist de verificaci√≥n:**

- [ ] **Entidades se crean correctamente**
  ```python
  print(f"√ìrdenes generadas: {orden_id}")
  print(f"√ìrdenes procesadas: {linea.unidades_producidas}")
  assert orden_id == linea.unidades_producidas, "¬°√ìrdenes perdidas!"
  ```

- [ ] **Recursos se usan correctamente**
  ```python
  # Verificar que no hay deadlocks
  # Verificar que recursos se liberan
  ```

- [ ] **Tiempos son razonables**
  ```python
  assert all(t > 0 for t in linea.tiempos_ciclo), "Tiempos negativos!"
  assert all(t < 60 for t in linea.tiempos_ciclo), "Tiempos sospechosos!"
  ```

- [ ] **Estad√≠sticas se recolectan**
  ```python
  assert len(linea.tiempos_ciclo) > 0, "No se recolectaron datos!"
  ```

**T√©cnica de debugging:**

```python
# Modo debug con prints
def proceso_orden_debug(self, orden_id):
    print(f"{self.env.now:.1f}: Orden {orden_id} llega")
    
    with self.estacion1.request() as req:
        yield req
        print(f"{self.env.now:.1f}: Orden {orden_id} inicia Est1")
        yield self.env.timeout(7.5)
        print(f"{self.env.now:.1f}: Orden {orden_id} termina Est1")
    
    # ... continuar
```

### Fase 5: Validaci√≥n

**Objetivo:** Asegurar que el modelo representa el sistema real.

**M√©todos:**

**1. Comparaci√≥n con datos reales:**

```python
# Datos reales
unidades_reales_dia = 80
tiempo_ciclo_real = 18.5  # minutos

# Datos simulados
unidades_sim_dia = linea.unidades_producidas
tiempo_ciclo_sim = np.mean(linea.tiempos_ciclo)

# Comparar
error_produccion = abs(unidades_sim_dia - unidades_reales_dia) / unidades_reales_dia
error_tiempo = abs(tiempo_ciclo_sim - tiempo_ciclo_real) / tiempo_ciclo_real

print(f"Error en producci√≥n: {error_produccion*100:.1f}%")
print(f"Error en tiempo de ciclo: {error_tiempo*100:.1f}%")

if error_produccion < 0.10 and error_tiempo < 0.10:
    print("‚úì MODELO V√ÅLIDO (error < 10%)")
else:
    print("‚úó MODELO REQUIERE AJUSTES")
```

**2. Pruebas estad√≠sticas:**

```python
from scipy import stats

# Recolectar datos reales de tiempos de ciclo
tiempos_reales = [18.2, 19.1, 17.8, 18.9, 17.5, ...]  # 30+ observaciones

# Prueba t
t_stat, p_value = stats.ttest_ind(tiempos_reales, linea.tiempos_ciclo)

print(f"Prueba t: p-value = {p_value:.4f}")
if p_value > 0.05:
    print("‚úì No hay diferencia significativa")
else:
    print("‚úó Hay diferencia significativa")
```

**3. Validaci√≥n con expertos:**
- Presentar l√≥gica del modelo
- Mostrar animaci√≥n (si es posible)
- ¬øLos resultados son cre√≠bles?

### Fase 6: Experimentaci√≥n

**Objetivo:** Probar escenarios "what-if" para tomar decisiones.

**Dise√±o de experimentos:**

```python
# Escenario 1: Configuraci√≥n actual (baseline)
# Escenario 2: Agregar 1 operador en Estaci√≥n 1
# Escenario 3: Agregar 1 operador en Estaci√≥n 2
# Escenario 4: Reducir tiempo de inspecci√≥n 20%

resultados = []

# Escenario 1: Baseline
env = simpy.Environment()
linea = LineaProduccion(env, config='baseline')
env.process(linea.generador_ordenes())
env.run(until=480)

resultados.append({
    'escenario': 'Baseline',
    'produccion': linea.unidades_producidas,
    'tiempo_ciclo': np.mean(linea.tiempos_ciclo),
    'costo': 0  # Sin cambios
})

# Escenario 2: +1 operador Est1
env = simpy.Environment()
linea = LineaProduccion(env, config='est1_extra')
env.process(linea.generador_ordenes())
env.run(until=480)

resultados.append({
    'escenario': '+1 Op Est1',
    'produccion': linea.unidades_producidas,
    'tiempo_ciclo': np.mean(linea.tiempos_ciclo),
    'costo': 25 * 8  # $25/hora √ó 8 horas
})

# ... continuar con otros escenarios

# Analizar resultados
df_resultados = pd.DataFrame(resultados)
print(df_resultados)

# Encontrar mejor escenario
df_resultados['beneficio'] = (df_resultados['produccion'] - 80) * 50  # $50 utilidad/unidad
df_resultados['beneficio_neto'] = df_resultados['beneficio'] - df_resultados['costo']

mejor = df_resultados.loc[df_resultados['beneficio_neto'].idxmax()]
print(f"\n‚úì MEJOR ESCENARIO: {mejor['escenario']}")
print(f"  Producci√≥n: {mejor['produccion']} unidades")
print(f"  Beneficio neto: ${mejor['beneficio_neto']:.2f}")
```

### Fase 7: Documentaci√≥n y Presentaci√≥n

**Objetivo:** Comunicar resultados de manera efectiva.

**Estructura del reporte:**

```markdown
# Proyecto de Simulaci√≥n: L√≠nea de Producci√≥n XYZ

## 1. Resumen Ejecutivo
- Problema identificado
- Soluci√≥n propuesta
- Resultados clave
- Recomendaci√≥n

## 2. Introducci√≥n
- Contexto del problema
- Objetivos del estudio
- Alcance

## 3. Metodolog√≠a
- Herramienta utilizada (SimPy)
- Datos recolectados
- Supuestos del modelo

## 4. Modelo de Simulaci√≥n
- Diagrama conceptual
- Descripci√≥n de componentes
- Par√°metros utilizados

## 5. Validaci√≥n
- Comparaci√≥n con sistema real
- Pruebas estad√≠sticas
- Conclusi√≥n de validez

## 6. Resultados
- Escenarios evaluados
- M√©tricas de desempe√±o
- An√°lisis comparativo

## 7. Recomendaciones
- Configuraci√≥n √≥ptima
- An√°lisis costo-beneficio
- Plan de implementaci√≥n

## 8. Conclusiones
- Hallazgos principales
- Limitaciones del estudio
- Trabajo futuro
```

**Visualizaciones clave:**

```python
import matplotlib.pyplot as plt

# Gr√°fico de comparaci√≥n de escenarios
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Producci√≥n por escenario
ax = axes[0]
ax.bar(df_resultados['escenario'], df_resultados['produccion'])
ax.axhline(y=100, color='r', linestyle='--', label='Meta')
ax.set_ylabel('Unidades Producidas')
ax.set_title('Producci√≥n por Escenario')
ax.legend()
ax.grid(True, alpha=0.3)

# Beneficio neto
ax = axes[1]
colors = ['green' if x > 0 else 'red' for x in df_resultados['beneficio_neto']]
ax.bar(df_resultados['escenario'], df_resultados['beneficio_neto'], color=colors)
ax.set_ylabel('Beneficio Neto ($)')
ax.set_title('An√°lisis Econ√≥mico')
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('resultados_simulacion.png', dpi=300)
plt.show()
```

---

## R√∫brica de Evaluaci√≥n

| Criterio | Puntos | Descripci√≥n |
|----------|--------|-------------|
| **Definici√≥n del problema** | 10 | Claridad de objetivos y alcance |
| **Recolecci√≥n de datos** | 15 | Cantidad y calidad de datos |
| **Modelo conceptual** | 10 | Diagrama y descripci√≥n clara |
| **Implementaci√≥n** | 20 | C√≥digo funcional y bien estructurado |
| **Verificaci√≥n** | 10 | Evidencia de debugging y pruebas |
| **Validaci√≥n** | 15 | Comparaci√≥n con sistema real |
| **Experimentaci√≥n** | 10 | Escenarios relevantes y bien dise√±ados |
| **Documentaci√≥n** | 10 | Reporte completo y profesional |
| **TOTAL** | **100** | |

---

## Ejemplos de Sistemas Apropiados

### Manufactura
- L√≠nea de ensamble
- Sistema de pintura
- Proceso de empaque
- Mantenimiento preventivo

### Servicios
- Banco (cajas)
- Hospital (emergencias)
- Call center
- Restaurante de comida r√°pida

### Log√≠stica
- Centro de distribuci√≥n
- Sistema de transporte
- Almac√©n automatizado
- Puerto mar√≠timo

### Retail
- Supermercado (cajas)
- Tienda departamental
- E-commerce (fulfillment)

---

## Checklist de Completitud

Antes de entregar, verificar:

- [ ] **Problema bien definido**
  - Objetivos claros
  - Alcance delimitado

- [ ] **Datos suficientes**
  - 100+ observaciones por variable
  - Distribuciones ajustadas

- [ ] **Modelo verificado**
  - Sin errores de l√≥gica
  - Resultados razonables

- [ ] **Modelo validado**
  - Comparado con sistema real
  - Pruebas estad√≠sticas aplicadas

- [ ] **Experimentos completos**
  - Al menos 3 escenarios
  - M√∫ltiples r√©plicas (30+)

- [ ] **Documentaci√≥n profesional**
  - Reporte completo
  - Gr√°ficos de calidad
  - C√≥digo comentado

- [ ] **Presentaci√≥n preparada**
  - Slides claros
  - Tiempo de 15-20 minutos
  - Respuestas a preguntas anticipadas

---

## Consejos Finales

**1. Comenzar temprano:**
- Recolecci√≥n de datos toma tiempo
- Debugging puede ser largo
- Dejar tiempo para iteraciones

**2. Documentar todo:**
- Supuestos
- Decisiones de dise√±o
- Problemas encontrados

**3. Comunicar con stakeholders:**
- Validar supuestos
- Presentar avances
- Ajustar seg√∫n feedback

**4. Ser realista:**
- No modelar TODO
- Enfocarse en lo importante
- Simplicidad es clave

**5. Preparar para preguntas:**
- ¬øPor qu√© usaste esa distribuci√≥n?
- ¬øC√≥mo validaste el modelo?
- ¬øQu√© pasa si cambia X par√°metro?

---

## Recursos Adicionales

**Templates:**
- Formato de recolecci√≥n de datos
- Template de reporte
- Checklist de verificaci√≥n

**Software:**
- SimPy: https://simpy.readthedocs.io
- Arena: Rockwell University
- Python: Pandas, NumPy, Matplotlib

**Bibliograf√≠a:**
- Law, A. (2015). "Simulation Modeling and Analysis"
- Banks, J. et al. (2010). "Discrete-Event System Simulation"

---

## Resumen

**Proyecto integrador = Aplicaci√≥n completa de simulaci√≥n**

**7 Fases:**
1. Definici√≥n del problema
2. Recolecci√≥n de datos
3. Construcci√≥n del modelo
4. Verificaci√≥n
5. Validaci√≥n
6. Experimentaci√≥n
7. Documentaci√≥n

**Entregables:**
- C√≥digo fuente
- Reporte t√©cnico
- Presentaci√≥n
- Datos utilizados

**√âxito = Modelo v√°lido + Recomendaciones accionables**

---

*Referencia: Programa SCD-1022 - TecNM*
*Este es el proyecto final que integra todas las competencias del curso.*


---

<div align="center">

‚¨ÖÔ∏è [Inicio Unidad 5](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Fin del Curso](../../README.md) üèÅ

</div>
